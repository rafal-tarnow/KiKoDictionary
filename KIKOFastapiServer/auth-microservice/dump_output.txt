===============================
Ścieżka do pliku: ./alembic.ini

Zawartość pliku:

# A generic, single database configuration.

[alembic]
# path to migration scripts.
# this is typically a path given in POSIX (e.g. forward slashes)
# format, relative to the token %(here)s which refers to the location of this
# ini file
script_location = %(here)s/migrations

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.  for multiple paths, the path separator
# is defined by "path_separator" below.
prepend_sys_path = .


# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library and tzdata library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to <script_location>/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "path_separator"
# below.
# version_locations = %(here)s/bar:%(here)s/bat:%(here)s/alembic/versions

# path_separator; This indicates what character is used to split lists of file
# paths, including version_locations and prepend_sys_path within configparser
# files such as alembic.ini.
# The default rendered in new alembic.ini files is "os", which uses os.pathsep
# to provide os-dependent path splitting.
#
# Note that in order to support legacy alembic.ini files, this default does NOT
# take place if path_separator is not present in alembic.ini.  If this
# option is omitted entirely, fallback logic is as follows:
#
# 1. Parsing of the version_locations option falls back to using the legacy
#    "version_path_separator" key, which if absent then falls back to the legacy
#    behavior of splitting on spaces and/or commas.
# 2. Parsing of the prepend_sys_path option falls back to the legacy
#    behavior of splitting on spaces, commas, or colons.
#
# Valid values for path_separator are:
#
# path_separator = :
# path_separator = ;
# path_separator = space
# path_separator = newline
#
# Use os.pathsep. Default configuration used for new projects.
path_separator = os

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

# database URL.  This is consumed by the user-maintained env.py script only.
# other means of configuring database URLs may be customized within the env.py
# file.
sqlalchemy.url = sqlite+aiosqlite:///./users.db


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration.  This is also consumed by the user-maintained
# env.py script only.
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S



===============================
Ścieżka do pliku: ./pytest.ini

Zawartość pliku:

[pytest]
asyncio_mode = auto
filterwarnings =
    ignore:.*crypt.*deprecated:DeprecationWarning


===============================
Ścieżka do pliku: ./tests/test_main.py

Zawartość pliku:

import pytest
from src.db.models.user import User
from src.core.security import pwd_context
from sqlalchemy.future import select
from tests.conftest import TestingSessionLocal

@pytest.mark.asyncio
async def test_not_found(client):
    response = client.get("/invalid-endpoint")
    assert response.status_code == 404
    assert response.json() == {"detail": "Not Found"}

@pytest.mark.asyncio
async def test_get_root(client):
    response = client.get("/")
    assert response.status_code == 200
    assert response.headers["content-type"] == "application/json"
    assert response.json() == {"status": "ok"}

@pytest.fixture
def valid_register_data():
    return {
        "email": "user2@example.com",
        "username": "john2_doe",
        "password": "secure123"
    }

@pytest.mark.asyncio
async def test_post_register_user(client, valid_register_data):
    response = client.post("/api/v1/auth/register", json=valid_register_data)
    assert response.status_code == 201
    assert response.headers["content-type"] == "application/json"
    response_json = response.json()
    assert "id" in response_json
    assert response_json["username"] == valid_register_data["username"]
    assert response_json["email"] == valid_register_data["email"]


@pytest.mark.asyncio
@pytest.mark.parametrize("invalid_email", [
    "invalid-email",
    "user@",
    "@domain.com",
    "user@domain",
    "user.domain.com",
    "user@.com"
])
async def test_post_register_user_invalid_email(client, valid_register_data, invalid_email):
    invalid_data = valid_register_data.copy()
    invalid_data["email"] = invalid_email
    response = client.post("/api/v1/auth/register", json=invalid_data)
    assert response.status_code == 422

    response_json = response.json()
    assert "detail" in response_json
    assert response_json["detail"][0]["loc"] == ["body", "email"]

    errors = response_json["detail"]
    assert any(
        error["loc"] == ["body", "email"] and error["type"] == "value_error"
        for error in errors
    )
    assert any(
        error["loc"] == ["body", "email"] and "email address" in error["msg"].lower()
        for error in errors
    )


@pytest.mark.asyncio
@pytest.mark.parametrize("invalid_username, expected_error_msg", [
    ("", "Value error, The username cannot be empty or consist only of whitespace."),
    ("   ", "Value error, The username cannot be empty or consist only of whitespace."),
    ("  john", "Value error, The username cannot contain spaces at the beginning or end."),
    ("john  ", "Value error, The username cannot contain spaces at the beginning or end."),
])
async def test_post_register_user_invalid_username(client, valid_register_data, invalid_username, expected_error_msg):
    invalid_data = valid_register_data.copy()
    invalid_data["username"] = invalid_username
    response = client.post("/api/v1/auth/register", json=invalid_data)
    assert response.status_code == 422
    response_json = response.json()
    assert "detail" in response_json
    errors = response_json["detail"]
    assert any(
        error["loc"] == ["body", "username"] and error["msg"] == expected_error_msg
        for error in errors
    ), f"Expected error with loc=['body', 'username'] and msg='{expected_error_msg}', got {errors}"


async def test_post_register_user_saves_to_database(client, valid_register_data):
    response = client.post("/api/v1/auth/register", json=valid_register_data)
    assert response.status_code == 201
    response_json = response.json()
    assert response_json["username"] == valid_register_data["username"]
    assert response_json["email"] == valid_register_data["email"]
    assert "id" in response_json
    assert response_json["account_role"] == "REGULAR"
    assert response_json["account_subscription"] == "FREE"

    async with TestingSessionLocal() as session:
        result = await session.execute(
            select(User).filter(User.email == valid_register_data["email"])
        )
        db_user = result.scalars().first()

        assert db_user is not None
        assert db_user.username == valid_register_data["username"]
        assert db_user.email == valid_register_data["email"]
        assert db_user.account_role == "REGULAR"
        assert db_user.account_subscription == "FREE"
        assert db_user.created_at is not None
        assert pwd_context.verify(valid_register_data["password"], db_user.hashed_password)


@pytest.mark.asyncio
async def test_post_regitster_user_duplicate_username(client, valid_register_data):
    response = client.post("/api/v1/auth/register", json=valid_register_data)
    assert response.status_code == 201
    assert response.json()["username"] == valid_register_data["username"]

    duplicate_data = valid_register_data.copy()
    duplicate_data["email"] = "different@example.com"
    response = client.post("/api/v1/auth/register", json=duplicate_data)

    assert response.status_code == 409
    assert response.json() == {"detail":"Username already taken"}


@pytest.mark.asyncio
async def test_logout_user(client, valid_register_data):
    # 1. Zarejestruj i zaloguj użytkownika, aby uzyskać tokeny
    client.post("/api/v1/auth/register", json=valid_register_data)
    login_payload = {
        "username": valid_register_data["email"],
        "password": valid_register_data["password"]
    }
    login_response = client.post("/api/v1/auth/login", data=login_payload)
    assert login_response.status_code == 200
    tokens = login_response.json()
    access_token = tokens["access_token"]
    refresh_token = tokens["refresh_token"]

    # 2. Sprawdź, czy chroniony endpoint działa
    headers = {"Authorization": f"Bearer {access_token}"}
    protected_response = client.get("/api/v1/data/test-data", headers=headers)
    assert protected_response.status_code == 200

    # 3. Wyloguj użytkownika
    logout_response = client.post("/api/v1/auth/logout", json={"refresh_token": refresh_token})
    assert logout_response.status_code == 204

     # 4. Sprawdź, czy odświeżenie tokena teraz zawiedzie
    refresh_response = client.post("/api/v1/auth/refresh", json={"refresh_token": refresh_token})
    assert refresh_response.status_code == 401
    assert "Invalid or expired refresh token" in refresh_response.json()["detail"]
    





===============================
Ścieżka do pliku: ./tests/conftest.py

Zawartość pliku:

# tests/conftest.py
import pytest
from fastapi.testclient import TestClient
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from src.main import app
from src.db.session import get_db
from src.db.models.user import Base

# Create an in-memory SQLite database for tests
TEST_DATABASE_URL = "sqlite+aiosqlite:///test.db"
test_engine = create_async_engine(TEST_DATABASE_URL, echo=True)
TestingSessionLocal = sessionmaker(
    autocommit=False, autoflush=False, bind=test_engine, class_=AsyncSession
)

# Override the get_db dependency to use the test database
async def override_get_db():
    async with TestingSessionLocal() as session:
        yield session

app.dependency_overrides[get_db] = override_get_db

# Create a test client fixture
@pytest.fixture
def client():
    return TestClient(app)

# Fixture to set up and tear down the database for each test
@pytest.fixture(autouse=True, scope="function")
async def setup_database():
    # Create tables before each test
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)  # Ensure clean state
        await conn.run_sync(Base.metadata.create_all)
    yield
    # Clean up after each test
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)


===============================
Ścieżka do pliku: ./systemd_files/install_systemd_service.sh

Zawartość pliku:

#!/bin/bash
sudo apt install python3-poetry
poetry config virtualenvs.in-project true
poetry install

sudo cp maia-auth.service /etc/systemd/system/maia-auth.service



===============================
Ścieżka do pliku: ./src/__init__.py

Zawartość pliku:




===============================
Ścieżka do pliku: ./src/dependencies.py

Zawartość pliku:


from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.config import settings
from src.db.models.user import User as UserDb
from src.db.repository.user_repository import UserRepository
from src.db.session import get_db
from src.api.v1.schemas.token import TokenData

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")

async def get_current_user(
        db: AsyncSession = Depends(get_db), token: str = Depends(oauth2_scheme)
) -> UserDb:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id: str = payload.get("sub")
        token_type: str = payload.get("type")
        
        if user_id is None or token_type != "access":
            raise credentials_exception
        token_data = TokenData(user_id=user_id)
    except JWTError:
        raise credentials_exception
    
    repo = UserRepository(db)
    user = await repo.get_by_id(user_id=token_data.user_id)
    
    # [ZMIANA]: Sprawdzamy czy user istnieje ORAZ czy nie ma zbanowanego/usuniętego konta
    if user is None or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User account is deactivated or deleted"
        )
        
    return user
    

    


===============================
Ścieżka do pliku: ./src/main.py

Zawartość pliku:

from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import Response, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.exc import OperationalError

from src.core.config import settings
from src.api.v1.routers import auth
from src.api.v1.routers import test
from src.db.models.user import Base
from src.db.models.refresh_token import RefreshToken
from src.db.models.password_reset import PasswordResetToken
from src.db.session import engine
from src.api.v1.routers.health import health_router
from src.api.v1.routers import users

import yaml

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Skoro mamy Alembica, aplikacja nie powinna sama tworzyć tabel!
    # async with engine.begin() as conn:
    #     await conn.run_sync(Base.metadata.create_all)
    yield

app = FastAPI(
    title="My Users Service", 
    description="API for User Management and Authentication", 
    version="1.0.0",
    lifespan=lifespan
    )


@app.exception_handler(OperationalError)
async def db_connection_handler(request: Request, exc: OperationalError):
    # Log dla Ciebie w konsoli
    print(f"LOG: Database OperationalError caught: {exc}")

    # Przypadek 1: Baza zablokowana (SQLite Lock)
    if "database is locked" in str(exc):
        return JSONResponse(
            status_code=503, 
            content={
                # Tutaj dodajemy jasną informację, że to wina bazy
                "detail": "Database error: Resource is locked. Service temporarily unavailable.",
                "error_code": "DB_LOCKED"
            }
        )
    
    # Przypadek 2: Inne błędy (np. zerwane połączenie, błąd składni SQL, brak serwera)
    return JSONResponse(
        status_code=500,
        content={
            # Tutaj też jasne info o bazie
            "detail": "Database error: Internal operation failed.",
            "error_code": "DB_ERROR"
        }
    )


# <--- 2. Konfiguracja Middleware (PRO)
# Dodajemy middleware TYLKO JEŚLI zdefiniowano dozwolone domeny.
# Jeśli lista jest pusta -> CORS nie działa -> Bezpieczeństwo zachowane (blokada wszystkiego z zewnątrz).
if settings.BACKEND_CORS_ORIGINS:
    app.add_middleware(
        CORSMiddleware,
        allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

app.include_router(auth.router)
app.include_router(test.router)
app.include_router(health_router, prefix="/health", tags=["Health & Operations"])
app.include_router(users.router)


@app.get("/docs.yaml")
async def yaml_docs():
    try:
        openapi_schema = app.openapi()
        yaml_content = yaml.dump(openapi_schema, sort_keys=False)
        return Response(
            content=yaml_content,
            media_type="application/yaml",
            headers={"Content-Disposition": "attachment; filename=docs.yaml"}
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating YAML: {str(e)}")


@app.get("/", tags=['Health Check'])
async def root():
    return {"status": "ok"}


===============================
Ścieżka do pliku: ./src/core/config.py

Zawartość pliku:

import os
from typing import List, Union
from pydantic import field_validator, AnyHttpUrl
from pydantic_settings import BaseSettings
from dotenv import load_dotenv

load_dotenv()

class Settings(BaseSettings):
    VERSION: str = "1.0.0"
    CAPTCHA_SERVICE_URL: str = os.getenv("CAPTCHA_SERVICE_URL", "http://127.0.0.1:8001/api/v1") 
    # JWT Settings
    SECRET_KEY: str = os.getenv("SECRET_KEY", "Z9X8v5y7_kJqP3mW2nL4rT6uY8iO0pQ2xR5tV7wU9")
    ALGORITHM: str = os.getenv("ALGORITHM", "HS256")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", 30))
    REFRESH_TOKEN_EXPIRE_DAYS: int = int(os.getenv("REFRESH_TOKEN_EXPIRE_DAYS", 7))

    # Database Settings
    DATABASE_URL: str = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./users.db")

    # Password Reset
    RESET_TOKEN_EXPIRE_MINUTES: int = int(os.getenv("RESET_TOKEN_EXPIRE_MINUTES", 15))
    
    # --- URL CONFIGURATION ---
    # Główny adres frontendu (np. strona główna)
    FRONTEND_URL: str = os.getenv("FRONTEND_URL", "http://localhost:3000")
    
    # Dedykowany URL do strony resetowania hasła.
    # Jeśli nie jest podany w .env, domyślnie składa się z FRONTEND_URL + /auth/reset-password
    # Dzięki temu w .env możesz wpisać PEŁNY, specyficzny link do pliku .html
    RESET_PASSWORD_URL: str = os.getenv("RESET_PASSWORD_URL", None)

    
    # Email Settings (przykładowe pod Gmail lub SMTP)
    SMTP_HOST: str = os.getenv("SMTP_HOST", "smtp.gmail.com")
    SMTP_PORT: int = int(os.getenv("SMTP_PORT", 587))
    SMTP_USER: str = os.getenv("SMTP_USER", "twoj-email@gmail.com")
    SMTP_PASSWORD: str = os.getenv("SMTP_PASSWORD", "twoje-haslo-aplikacji")
    # Adres e-mail, z którego system "technicznie" wysyła wiadomości.
    # To na ten adres użytkownik spróbuje odpisać, jeśli kliknie "Odpowiedz".
    # os.getenv(...) sprawdza czy w pliku .env jest klucz EMAILS_FROM_EMAIL.
    # Jeśli nie ma, używa wartości domyślnej "info@myapp.com".
    EMAILS_FROM_EMAIL: str = os.getenv("EMAILS_FROM_EMAIL", "info@myapp.com")
    # Nazwa wyświetlana (Friendly Name), którą użytkownik widzi na liście wiadomości
    # zamiast surowego adresu e-mail. Buduje to zaufanie i profesjonalny wizerunek.
    # Np. zamiast widzieć "info@myapp.com", użytkownik zobaczy "My Users Service".
    EMAILS_FROM_NAME: str = os.getenv("EMAILS_FROM_NAME", "English Learner")
    # --- CORS CONFIGURATION (PRO) ---
    # To pole wczyta string z .env i zamieni go na listę dzięki walidatorowi poniżej.
    # Domyślnie pusta lista (bezpieczeństwo).
    # ZMIANA TUTAJ:
    # Zmieniamy List[str] na Union[List[str], str].
    # Dzięki temu Pydantic nie wymusza JSON-a na starcie, a walidator i tak zamieni to na listę.
    BACKEND_CORS_ORIGINS: Union[List[str], str] = []

    @field_validator("BACKEND_CORS_ORIGINS", mode="before")
    @classmethod
    def assemble_cors_origins(cls, v: Union[str, List[str]]) -> Union[List[str], str]:
        # Ta logika jest poprawna i teraz zadziała, bo Pydantic dopuścił stringa na wejściu
        if isinstance(v, str) and not v.startswith("["):
            return [i.strip() for i in v.split(",")]
        elif isinstance(v, (list, str)):
            return v
        raise ValueError(v)

    def get_reset_password_link(self, token: str) -> str:
        """
        Inteligentnie buduje link. Jeśli w .env zdefiniowano RESET_PASSWORD_URL, używa go.
        W przeciwnym razie buduje domyślną ścieżkę dla SPA (Single Page App).
        """
        base_url = self.RESET_PASSWORD_URL
        
        # Fallback: Jeśli nie zdefiniowano specyficznego URL, budujemy standardowy
        if not base_url:
            base_url = f"{self.FRONTEND_URL}/auth/reset-password"
            
        return f"{base_url}?token={token}"
    
settings = Settings()


===============================
Ścieżka do pliku: ./src/core/security.py

Zawartość pliku:

from datetime import datetime, timedelta, timezone
from typing import Optional

from jose import JWTError, jwt
from passlib.context import CryptContext

from .config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def verify_password(plain_password: str, hashed_password: str) ->bool:
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire, "type": "access"})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


def create_refresh_token(data: dict) -> str:
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire, "type": "refresh"})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


===============================
Ścieżka do pliku: ./src/services/email/service.py

Zawartość pliku:

import os
from pathlib import Path
from typing import List

from fastapi_mail import FastMail, MessageSchema, ConnectionConfig, MessageType
from src.core.config import settings

# Ustalanie ścieżki do szablonów w sposób niezależny od systemu operacyjnego
# __file__ to ścieżka do tego pliku (service.py).
# .parent to katalog 'email', a / 'templates' to podkatalog.
TEMPLATE_FOLDER = Path(__file__).resolve().parent / "templates"

class EmailService:
    def __init__(self):
        # Konfiguracja połączenia SMTP
        self.conf = ConnectionConfig(
            MAIL_USERNAME=settings.SMTP_USER,
            MAIL_PASSWORD=settings.SMTP_PASSWORD,
            MAIL_FROM=settings.EMAILS_FROM_EMAIL,
            MAIL_PORT=settings.SMTP_PORT,
            MAIL_SERVER=settings.SMTP_HOST,
            MAIL_FROM_NAME=settings.EMAILS_FROM_NAME,
            MAIL_STARTTLS=True,  # Zazwyczaj True dla portu 587
            MAIL_SSL_TLS=False,  # Zazwyczaj False dla portu 587 (True dla 465)
            USE_CREDENTIALS=True,
            VALIDATE_CERTS=True,
            TEMPLATE_FOLDER=TEMPLATE_FOLDER
        )
        self.fast_mail = FastMail(self.conf)

    async def send_reset_password_email(self, email_to: str, token: str):
        """
        Wysyła prawdziwy email z użyciem szablonu HTML.
        """
        # 1. Przygotowanie danych do szablonu (Context)
        # ZMIANA: Używamy metody z settings do poprawnego zbudowania linku
        reset_link = settings.get_reset_password_link(token)
        
        template_body = {
            "app_name": settings.EMAILS_FROM_NAME,
            "link": reset_link,
            "valid_minutes": settings.RESET_TOKEN_EXPIRE_MINUTES,
            "subject": "Reset Your Password"
        }

        # 2. Tworzenie wiadomości
        message = MessageSchema(
            subject="Reset Your Password - Action Required",
            recipients=[email_to],
            template_body=template_body,
            subtype=MessageType.html
        )

        # 3. Wysyłka
        try:
            await self.fast_mail.send_message(message, template_name="reset_password.html")
            print(f"LOG: Email sent to {email_to} with link: {reset_link}")
        except Exception as e:
            print(f"ERROR: Failed to send email to {email_to}. Error: {e}")


email_service = EmailService()


===============================
Ścieżka do pliku: ./src/services/email/__init__.py

Zawartość pliku:




===============================
Ścieżka do pliku: ./src/services/email/templates/base.html

Zawartość pliku:

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>{{ subject }}</title>
    <style>
        body { font-family: Arial, sans-serif; background-color: #f4f4f4; padding: 20px; }
        .container { max-width: 600px; margin: 0 auto; background: #ffffff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .header { text-align: center; border-bottom: 1px solid #eee; padding-bottom: 20px; margin-bottom: 20px; }
        .footer { margin-top: 30px; text-align: center; font-size: 12px; color: #888; }
        .button { background-color: #007bff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; display: inline-block; margin-top: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h2>{{ app_name }}</h2>
        </div>
        
        <div class="content">
            {% block content %}{% endblock %}
        </div>

        <div class="footer">
            <p>&copy; 2026 {{ app_name }}. All rights reserved.</p>
            <p>If you did not request this email, please ignore it.</p>
        </div>
    </div>
</body>
</html>


===============================
Ścieżka do pliku: ./src/services/email/templates/reset_password.html

Zawartość pliku:

{% extends "base.html" %}

{% block content %}
<h3>Hello,</h3>
<p>We received a request to reset your password for your account at <strong>{{ app_name }}</strong>.</p>
<p>Please click the button below to set a new password:</p>

<div style="text-align: center;">
    <a href="{{ link }}" class="button">Reset Password</a>
</div>

<p>Or copy and paste this link into your browser:</p>
<p><a href="{{ link }}">{{ link }}</a></p>

<p>This link is valid for <strong>{{ valid_minutes }} minutes</strong>.</p>
{% endblock %}


===============================
Ścieżka do pliku: ./src/api/v1/routers/auth.py

Zawartość pliku:

import httpx
import secrets
from uuid import uuid4
from jose import JWTError, jwt
from datetime import datetime, timedelta, timezone
from fastapi import APIRouter, Depends, HTTPException, status, Response, BackgroundTasks
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.config import settings
from src.core.security import get_password_hash

from src.db.session import get_db
from src.db.repository.user_repository import UserRepository
from src.db.repository.refresh_token_repository import RefreshTokenRepository
from src.db.repository.password_reset_repository import PasswordResetRepository
from src.db.models.password_reset import PasswordResetToken

from src.core.security import verify_password, create_access_token, create_refresh_token

from src.api.v1.schemas import user as user_schema
from src.api.v1.schemas.user import UserRegister, UserCreate 
from src.api.v1.schemas import token as token_schema
from src.api.v1.schemas.auth import ForgotPasswordRequest, ResetPasswordRequest

from src.services.email.service import email_service




router = APIRouter(prefix="/api/v1/auth", tags=["Authentication"])


@router.post("/register", response_model=user_schema.UserPublic, status_code=status.HTTP_201_CREATED)
async def register_user(
    user_in: UserRegister, # <--- Używamy schematu zawierającego pola captcha
    db: AsyncSession = Depends(get_db)
):
    # --- 1. WERYFIKACJA CAPTCHA Z TIMEOUTEM ---
    captcha_url = f"{settings.CAPTCHA_SERVICE_URL}/captcha/verify"
    
    captcha_payload = {
        "id": str(user_in.captcha_id),
        "answer": user_in.captcha_answer
    }

    # Ustawienie timeout na 5 sekund
    # timeout=5.0 oznacza: max 5s na nawiązanie połączenia, max 5s na odczyt danych itd.
    async with httpx.AsyncClient(timeout=5.0) as client:
        try:
            response = await client.post(captcha_url, json=captcha_payload)
            response.raise_for_status() # Rzuci błąd jeśli Captcha Service zwróci 4xx lub 5xx
            
            verify_data = response.json()
            
            if not verify_data.get("is_valid"):
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST, 
                    detail="Invalid CAPTCHA answer"
                )

        except httpx.TimeoutException:
            # Obsługa przekroczenia czasu oczekiwania (5 sekund)
            print("Błąd: Serwis Captcha nie odpowiedział w ciągu 5 sekund.")
            raise HTTPException(
                status_code=status.HTTP_504_GATEWAY_TIMEOUT, 
                detail="Captcha verification timed out. Please try again later."
            )
            
        except httpx.RequestError as exc:
            # Obsługa braku połączenia (np. serwis leży, zły adres URL)
            print(f"Błąd połączenia z serwisem Captcha: {exc}")
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE, 
                detail="Captcha service unavailable. Please try again later."
            )
        
        except httpx.HTTPStatusError as exc:
            # Obsługa błędów HTTP (np. 500 z serwera Captcha)
            print(f"Serwis Captcha zwrócił błąd HTTP: {exc.response.status_code}")
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Error communicating with captcha service."
            )

    # --- 2. LOGIKA BIZNESOWA REJESTRACJI ---
    
    # Konwersja UserRegister -> UserCreate (usuwamy pola captcha)
    user_create_data = UserCreate(
        **user_in.model_dump(exclude={"captcha_id", "captcha_answer"})
    )

    repo = UserRepository(db)
    
    # Sprawdzenie czy email istnieje
    db_user = await repo.get_by_email(email=user_create_data.email)
    if db_user:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Email already registered")
    
    # Sprawdzenie czy username istnieje
    db_user = await repo.get_by_username(username=user_create_data.username)
    if db_user:
        suggested_username = await repo.suggest_available_username(user_create_data.username)
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT, 
            detail={
                "message": "Username already taken",
                "suggestion": suggested_username
            }
        )
    
    # Utworzenie użytkownika
    user = await repo.create(user_data=user_create_data)
    return user


@router.post("/login", response_model=token_schema.Token)
async def login_for_access_token(
    db: AsyncSession = Depends(get_db), 
    form_data: OAuth2PasswordRequestForm = Depends()):

    repo = UserRepository(db)
    user = await repo.get_by_email(email=form_data.username)
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token = create_access_token(data={"sub": str(user.id)})
    refresh_token = create_refresh_token(data={"sub": str(user.id)})

    # save RefreshToken
    refresh_token_repo = RefreshTokenRepository(db)
    expires_at = datetime.now(timezone.utc) + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    await refresh_token_repo.create(
        user_id=user.id,
        token=refresh_token,
        expires_at=expires_at
    )
    
    return {"access_token": access_token, "refresh_token": refresh_token, "token_type": "bearer"}


@router.post("/logout", status_code=status.HTTP_204_NO_CONTENT)
async def logout(
    token_request: token_schema.RefreshTokenRequest,
    db: AsyncSession = Depends(get_db)):

    refresh_token_repo = RefreshTokenRepository(db)

    # find token in database
    db_token = await refresh_token_repo.get_by_token(token=token_request.refresh_token)
    
    # if token exist, delete it
    if db_token:
        await refresh_token_repo.delete(token_id=db_token.id)

    return Response(status_code=status.HTTP_204_NO_CONTENT)


@router.post("/refresh", response_model=token_schema.Token)
async def refresh_access_token(
    token_request: token_schema.RefreshTokenRequest,
    db: AsyncSession = Depends(get_db)
):
    refresh_token_repo = RefreshTokenRepository(db)
    
    # 1. Znajdź token odświeżający w bazie danych
    db_refresh_token = await refresh_token_repo.get_by_token(token=token_request.refresh_token)

    # 2. Sprawdź, czy token istnieje i czy nie wygasł
    if not db_refresh_token or db_refresh_token.expires_at < datetime.now(timezone.utc):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired refresh token",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 3. Jeśli token istnieje, ALE WYGASŁ, usuń go i odrzuć
    if db_refresh_token.expires_at < datetime.now(timezone.utc):
        await refresh_token_repo.delete(token_id=db_refresh_token.id) # <-- DODANA LINIA
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired refresh token", # Można zostawić ten sam komunikat
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 4. Zweryfikuj poprawność samego JWT (chociaż baza jest głównym źródłem prawdy)
    try:
        payload = jwt.decode(
            token_request.refresh_token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]
        )
        if payload.get("type") != "refresh":
             raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token type")
    except JWTError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Could not validate token")

    # 5. Stwórz nowy token dostępowy
    new_access_token = create_access_token(data={"sub": str(db_refresh_token.user_id)})
    
    # (Token Rotation): unieważnij stary i wydaj nowy refresh token
    await refresh_token_repo.delete(token_id=db_refresh_token.id)
    new_refresh_token = create_refresh_token(data={"sub": str(db_refresh_token.user_id)})
    expires_at = datetime.now(timezone.utc) + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    await refresh_token_repo.create(
        user_id=db_refresh_token.user_id,
        token=new_refresh_token,
        expires_at=expires_at
    )

    return {
        "access_token": new_access_token,
        "refresh_token": new_refresh_token,
        "token_type": "bearer"
    }

@router.post("/forgot-password", status_code=status.HTTP_202_ACCEPTED)
async def forgot_password(
    request: ForgotPasswordRequest,
    background_tasks: BackgroundTasks, # <--- Wstrzykiwanie zadań w tle
    db: AsyncSession = Depends(get_db)
):
    """
    Inicjuje proces resetowania hasła.
    Zwraca 202 Accepted niezależnie od tego, czy email istnieje (Security).
    """
    user_repo = UserRepository(db)
    user = await user_repo.get_by_email(request.email)

    if user:
        # 1. Generujemy bezpieczny token (URL-safe string)
        token = secrets.token_urlsafe(32)
        
        # 2. Zapisujemy token w bazie
        reset_repo = PasswordResetRepository(db)
        expires_at = datetime.now(timezone.utc) + timedelta(minutes=settings.RESET_TOKEN_EXPIRE_MINUTES)
        
        await reset_repo.create(
            user_id=user.id,
            token=token,
            expires_at=expires_at
        )

        # 3. Wysyłamy email w tle (nie blokujemy odpowiedzi API)
        background_tasks.add_task(
            email_service.send_reset_password_email,
            email_to=user.email,
            token=token
        )

    # ZAWSZE zwracamy ten sam komunikat dla bezpieczeństwa
    return {"message": "If the email exists, a reset link has been sent."}


@router.post("/reset-password", status_code=status.HTTP_200_OK)
async def reset_password(
    request: ResetPasswordRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    Ustawia nowe hasło na podstawie ważnego tokena.
    """
    reset_repo = PasswordResetRepository(db)
    user_repo = UserRepository(db)

    # 1. Sprawdź czy token jest poprawny i ważny
    db_token = await reset_repo.get_valid_token(request.token)
    if not db_token:
        # Tutaj możemy rzucić 400, bo user już wszedł w link i oczekuje efektu
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid or expired reset token"
        )

    # 2. Znajdź użytkownika
    user = await user_repo.get_by_id(db_token.user_id)
    if not user:
         raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )

    # 3. Zhashuj nowe hasło i zaktualizuj usera
    new_hashed_password = get_password_hash(request.new_password)
    
    # Robimy to elegancko:
    user.hashed_password = new_hashed_password # Zmieniamy pole na obiekcie
    # Zlecamy zapis repozytorium
    await user_repo.update(user)

    # 4. Oznacz token jako zużyty
    await reset_repo.mark_as_used(db_token.id)
    
    # 5. WYLOGUJ ZE WSZYSTKICH URZĄDZEŃ (Bezpieczeństwo)
    refresh_token_repo = RefreshTokenRepository(db)
    await refresh_token_repo.delete_all_for_user(user.id) 

    # await db.commit() <--- TO MOŻESZ USUNĄĆ, bo metody repozytoriów (mark_as_used, delete_all...) 
    # robią commit wewnątrz siebie. Nadmiarowy commit nie szkodzi, ale nie jest potrzebny.

    return {"message": "Password has been reset successfully"}


===============================
Ścieżka do pliku: ./src/api/v1/routers/users.py

Zawartość pliku:

from fastapi import APIRouter, Depends, status, Response
from sqlalchemy.ext.asyncio import AsyncSession

from src.db.session import get_db
from src.db.models.user import User as UserDb
from src.dependencies import get_current_user
from src.db.repository.user_repository import UserRepository
from src.db.repository.refresh_token_repository import RefreshTokenRepository
from src.api.v1.schemas import user as user_schema

# Tworzymy oddzielny router do zarządzania profilami użytkowników
router = APIRouter(prefix="/api/v1/users", tags=["Users"])

@router.get("/me", response_model=user_schema.UserPublic)
async def read_users_me(current_user: UserDb = Depends(get_current_user)):
    """
    Pobiera dane aktualnie zalogowanego użytkownika.
    """
    return current_user

@router.delete("/me", status_code=status.HTTP_204_NO_CONTENT)
async def delete_user_me(
    current_user: UserDb = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Trwale usuwa konto aktualnie zalogowanego użytkownika.
    Operacja wykorzystuje bezpieczne 'Soft Delete' z anonimizacją danych.
    """
    user_repo = UserRepository(db)
    refresh_token_repo = RefreshTokenRepository(db)
    
    # 1. Wyloguj użytkownika ze wszystkich urządzeń (usuń Refresh Tokeny)
    await refresh_token_repo.delete_all_for_user(current_user.id)
    
    # 2. Zastosuj anonimizację i Soft Delete na koncie
    await user_repo.soft_delete_user(current_user)
    
    # Zwracamy 204 No Content (Standard HTTP przy udanym usunięciu zasobu)
    return Response(status_code=status.HTTP_204_NO_CONTENT)


===============================
Ścieżka do pliku: ./src/api/v1/routers/test.py

Zawartość pliku:

from fastapi import APIRouter, Depends
from typing import Dict
from src.db.models.user import User as UserDb
from src.dependencies import get_current_user

router = APIRouter(prefix="/api/v1/data", tags=["Data"])

@router.get("/test-data", response_model=Dict[str, str])
async def get_test_data(current_user: UserDb = Depends(get_current_user)):
    return {"message": "This is protected test data", "user_id": str(current_user.id)}



===============================
Ścieżka do pliku: ./src/api/v1/routers/health.py

Zawartość pliku:

from fastapi import APIRouter, status
from src.api.v1.schemas.health import HealthCheckResponse
from src.core.config import settings

health_router = APIRouter()

@health_router.get(
    "/live",
    response_model=HealthCheckResponse,
    status_code=status.HTTP_200_OK,
    summary="Liveness Probe",
    description="Sprawdza czy aplikacja jest uruchomiona. Nie sprawdza zależności."
)
async def liveness_probe():
    """
    Szybki check dla Kubernetesa. Jeśli to nie działa, K8s restartuje poda.
    """
    return HealthCheckResponse(
        status="ok",
        version=settings.VERSION
    )


===============================
Ścieżka do pliku: ./src/api/v1/schemas/auth.py

Zawartość pliku:

from pydantic import BaseModel, EmailStr, Field, field_validator
from src.api.v1.schemas.user import UserCreate  # Importujemy, żeby użyć walidatora hasła

class ForgotPasswordRequest(BaseModel):
    email: EmailStr

class ResetPasswordRequest(BaseModel):
    token: str
    new_password: str = Field(..., description="New password")

    # RE-USE LOGIC: Używamy tej samej walidacji co przy rejestracji!
    @field_validator("new_password")
    @classmethod
    def validate_password(cls, v):
        return UserCreate.validate_password_content(v)


===============================
Ścieżka do pliku: ./src/api/v1/schemas/token.py

Zawartość pliku:

from pydantic import BaseModel
from typing import Optional

class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"


class TokenData(BaseModel):
    user_id: Optional[str] = None


class RefreshTokenRequest(BaseModel):
    refresh_token: str


===============================
Ścieżka do pliku: ./src/api/v1/schemas/user.py

Zawartość pliku:

from pydantic import BaseModel, EmailStr, field_validator, ConfigDict, Field
from typing import Optional, Any
from uuid import UUID
from datetime import datetime
from src.db.models.user import AccountRole, AccountSubscription
import re


# Lista słów, których nie można użyć jako nazwy użytkownika
RESERVED_USERNAMES = {
    "admin", "administrator", "root", "system", "support", "help", 
    "moderator", "superuser", "guest", "api", "auth", "login", 
    "logout", "register", "dashboard", "settings", "profile"
}

# Regex: Startuje od litery, potem litery, cyfry, _ lub -. 
# Nie pozwala na _ lub - na końcu lub na początku (opcjonalnie).
# Tutaj prosta wersja: a-z, 0-9, _, -
USERNAME_REGEX = r"^[a-zA-Z0-9_-]+$"

class UserBase(BaseModel):
    email: EmailStr
    # ZMIANA: Usunięto min_length i max_length z Field(), aby uniknąć generycznych błędów Pydantic.
    # Walidacja długości odbywa się teraz w validate_username_security.
    username: str = Field(
        ..., 
        description="Username must be 3-30 characters, strictly alphanumeric, underscores or hyphens."
    )

    # Używamy mode='before', żeby naprawić dane zanim Pydantic zacznie marudzić
    @field_validator("email", mode="before")
    @classmethod
    def case_insensitive_email(cls, v: Any) -> Any:
        # Sprawdzamy czy to string, żeby nie wysadzić serwera
        # gdyby ktoś złośliwie przysłał int albo tablicę w polu email.
        if isinstance(v, str):
            return v.lower()
        return v


    @field_validator("username")
    @classmethod
    def validate_username_security(cls, value: str) -> str:
        # --- WAŻNE: NIE USUWAĆ PONIŻSZEGO BLOKU ---
        # Sprawdzamy długość ręcznie tutaj, zamiast w Field(), aby zwrócić
        # precyzyjny komunikat błędu dla Frontendu, zamiast generycznego
        # "String should have at least X characters" z Pydantic.
        if len(value) < 3:
            raise ValueError("Username must be at least 3 characters long.")
        if len(value) > 30:
            raise ValueError("Username cannot be longer than 30 characters.")
        # ------------------------------------------

        # 1. Sprawdzenie znaków (Regex)
        if not re.match(USERNAME_REGEX, value):
            raise ValueError("Username can only contain letters, numbers, underscores (_), and hyphens (-).")

        # 2. Sprawdzenie słów zastrzeżonych
        if value.lower() in RESERVED_USERNAMES:
            raise ValueError("This username is reserved and cannot be used.")
            
        # 3. Sprawdzenie czy nie wygląda jak email (żeby ludzie nie wpisywali tu maila)
        if "@" in value:
             raise ValueError("Username cannot contain '@' symbol.")

        # 4. Podwójne kropki/podkreślenia (opcjonalne - estetyka)
        if "__" in value or "--" in value:
            raise ValueError("Username cannot contain consecutive underscores or hyphens.")

        return value
    

class UserCreate(UserBase):
    # ZMIANA: Usuwamy 'min_length=6' stąd, żeby uniknąć błędu "String should have..."
    # Zostawiamy description dla dokumentacji
    password: str = Field(..., description="Password must be at least 6 characters long")

    @field_validator("password")
    @classmethod
    def validate_password_content(cls, value: str) -> str:
        # 1. ZMIANA: Dodajemy walidację długości TUTAJ, żeby mieć własny komunikat
        if len(value) < 6:
            raise ValueError("Password must be at least 6 characters long")

        # 2. Wymaganie: minimum jedna cyfra
        if not re.search(r"\d", value):
            raise ValueError("Password must contain at least one digit")
        
        # 3. Wymaganie: minimum jedna litera (duża lub mała)
        if not re.search(r"[a-zA-Z]", value):
            raise ValueError("Password must contain at least one letter")
            
        return value

class UserRegister(UserCreate):
    captcha_id: UUID
    captcha_answer: str
    
class UserPublic(UserBase):
    id: UUID
    account_role: AccountRole
    account_subscription: AccountSubscription
    subscription_expires_at: Optional[datetime] = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


===============================
Ścieżka do pliku: ./src/api/v1/schemas/health.py

Zawartość pliku:

from pydantic import BaseModel
from typing import Dict, Optional

class HealthCheckResponse(BaseModel):
    status: str
    version: str
    uptime: Optional[float] = None
    components: Optional[Dict[str, str]] = None

    class Config:
        json_schema_extra = {
            "example": {
                "status": "ok",
                "version": "1.0.0",
                "components": {
                    "database": "operational",
                    "redis": "down"
                }
            }
        }


===============================
Ścieżka do pliku: ./src/db/session.py

Zawartość pliku:

from typing import AsyncGenerator
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from src.core.config import settings

engine = create_async_engine(settings.DATABASE_URL, echo=True)
AsyncSessionLocal = sessionmaker(
    autocommit=False, 
    autoflush=False, 
    bind=engine, 
    class_=AsyncSession,
    expire_on_commit=False  # <--- DODAJ TĘ LINIĘ
)

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    async with AsyncSessionLocal() as session:
        yield session


===============================
Ścieżka do pliku: ./src/db/models/refresh_token.py

Zawartość pliku:

# src/db/models/refresh_token.py
import uuid
from sqlalchemy import Column, String, DateTime, func, ForeignKey
from sqlalchemy.orm import relationship
from .user import Base

class RefreshToken(Base):
    __tablename__ = "refresh_tokens"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    user_id = Column(String, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    refresh_token = Column(String, unique=True, index=True, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    created_at = Column(DateTime, server_default=func.now(), nullable=False)

    user = relationship("User")


===============================
Ścieżka do pliku: ./src/db/models/password_reset.py

Zawartość pliku:

import uuid
from sqlalchemy import Column, String, DateTime, func, ForeignKey, Boolean
from sqlalchemy.orm import relationship
from src.db.models.user import Base

class PasswordResetToken(Base):
    __tablename__ = "password_reset_tokens"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    user_id = Column(String, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    token = Column(String, unique=True, index=True, nullable=False)
    expires_at = Column(DateTime(timezone=True), nullable=False)
    is_used = Column(Boolean, default=False, nullable=False)
    created_at = Column(DateTime, server_default=func.now(), nullable=False)

    user = relationship("User")

    


===============================
Ścieżka do pliku: ./src/db/models/user.py

Zawartość pliku:

import uuid
import enum
from sqlalchemy import Column, String, DateTime, func, Enum, Index, Boolean
from sqlalchemy.orm import declarative_base

Base = declarative_base()

class AccountSubscription(str, enum.Enum):
    FREE = "FREE"
    PRO = "PRO"

class AccountRole(str, enum.Enum):
    ADMIN = "ADMIN"
    MODERATOR = "MODERATOR"
    REGULAR = "REGULAR"

class User(Base):
    __tablename__ = "users"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    # Usuwamy index=True stąd, bo dodajemy niestandardowy index poniżej
    username = Column(String, unique=False, nullable=False) 
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    
    account_role = Column(Enum(AccountRole), default=AccountRole.REGULAR, nullable=False)

    account_subscription = Column(Enum(AccountSubscription), default=AccountSubscription.FREE, nullable=False)
    subscription_expires_at = Column(DateTime(timezone=True), nullable=True)

    # --- [ZMIANA]: SOFT DELETE FIELDS ---
    is_active = Column(Boolean, default=True, nullable=False) # Określa czy konto działa
    deleted_at = Column(DateTime(timezone=True), nullable=True) # Data usunięcia konta
    # ------------------------------------

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)

    # --- PROFESJONALNE ZABEZPIECZENIE ---
    __table_args__ = (
        # 1. Unikalny index na małych literach username.
        # To gwarantuje, że 'Tom' i 'tom' nie mogą istnieć obok siebie w bazie.
        # Jest to najwydajniejszy sposób na case-insensitive uniqueness.
        Index('ix_users_username_lower', func.lower(username), unique=True),
        
        # 2. Zwykły index dla username (opcjonalny, jeśli często szukamy case-sensitive, ale rzadko to robimy)
        # W tym modelu index funkcyjny wyżej załatwia większość spraw.
    )


===============================
Ścieżka do pliku: ./src/db/repository/refresh_token_repository.py

Zawartość pliku:

from typing import Optional
from datetime import datetime
from sqlalchemy import delete
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload

from src.db.models.refresh_token import RefreshToken

class RefreshTokenRepository:
    def __init__(self, db_session: AsyncSession):
        self.db = db_session

    async def create(self, user_id: str, token: str, expires_at: datetime) -> RefreshToken:
        db_token = RefreshToken(
            user_id=user_id,
            refresh_token=token,
            expires_at=expires_at
        )
        self.db.add(db_token)
        await self.db.commit()
        await self.db.refresh(db_token)
        return db_token

    async def get_by_token(self, token: str) -> Optional[RefreshToken]:
        result = await self.db.execute(
            select(RefreshToken)
            .options(selectinload(RefreshToken.user)) # Opcjonalnie, aby załadować od razu dane usera
            .filter(RefreshToken.refresh_token == token)
        )
        return result.scalars().first()
    
    async def delete(self, token_id: str) -> None:
        db_token = await self.db.get(RefreshToken, token_id)
        if db_token:
            await self.db.delete(db_token)
            await self.db.commit()

    # Dodaj to na końcu klasy RefreshTokenRepository
    async def delete_all_for_user(self, user_id: str) -> None:
        """
        Usuwa wszystkie tokeny odświeżające danego użytkownika.
        Używane przy zmianie hasła, aby wylogować użytkownika ze wszystkich urządzeń.
        """
        # Importujemy delete wewnątrz metody lub na górze pliku
        from sqlalchemy import delete 
        
        stmt = delete(RefreshToken).where(RefreshToken.user_id == user_id)
        await self.db.execute(stmt)
        await self.db.commit()


===============================
Ścieżka do pliku: ./src/db/repository/password_reset_repository.py

Zawartość pliku:

from typing import Optional
from datetime import datetime, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from src.db.models.password_reset import PasswordResetToken

class PasswordResetRepository:
    def __init__(self, db_session: AsyncSession):
        self.db = db_session

    async def create(self, user_id: str, token: str, expires_at: datetime) -> PasswordResetToken:
        # Opcjonalnie: Możesz tu najpierw unieważnić poprzednie niewykorzystane tokeny tego usera
        db_token = PasswordResetToken(
            user_id=user_id,
            token=token,
            expires_at=expires_at,
            is_used=False
        )
        self.db.add(db_token)
        await self.db.commit()
        await self.db.refresh(db_token)
        return db_token

    async def get_valid_token(self, token: str) -> Optional[PasswordResetToken]:
        """
        Pobiera token, jeśli istnieje, nie został użyty i nie wygasł.
        """
        query = select(PasswordResetToken).filter(
            PasswordResetToken.token == token,
            PasswordResetToken.is_used == False,
            PasswordResetToken.expires_at > datetime.now(timezone.utc)
        )
        result = await self.db.execute(query)
        return result.scalars().first()

    async def mark_as_used(self, token_id: str) -> None:
        db_token = await self.db.get(PasswordResetToken, token_id)
        if db_token:
            db_token.is_used = True
            await self.db.commit()


===============================
Ścieżka do pliku: ./src/db/repository/user_repository.py

Zawartość pliku:

from typing import Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy import or_, func
from datetime import datetime, timezone
import uuid

from src.db.models.user import User
from src.api.v1.schemas.user import UserCreate
from src.core.security import get_password_hash
import re

class UserRepository:
    def __init__(self, db_session: AsyncSession):
        self.db = db_session

    async def get_by_email(self, email: str) -> Optional[User]:
        email_lower = email.lower()
        # [ZMIANA]: Pobieramy tylko aktywnych użytkowników
        result = await self.db.execute(
            select(User).filter(User.email == email_lower, User.is_active == True)
        )
        return result.scalars().first()
    

    async def get_by_username(self, username: str) -> Optional[User]:
        """
        Wyszukuje użytkownika ignorując wielkość liter.
        Dla wejścia 'tom' znajdzie użytkownika 'Tom'.
        """
        username_lower = username.lower()
        # [ZMIANA]: Pobieramy tylko aktywnych użytkowników
        result = await self.db.execute(
            select(User).filter(
                func.lower(User.username) == username_lower,
                User.is_active == True
            )
        )
        return result.scalars().first()
    
    async def get_by_id(self, user_id: str) -> Optional[User]:
        result = await self.db.execute(select(User).filter(User.id == user_id))
        # [ZMIANA UWAGA]: Celowo nie sprawdzamy tu is_active, 
        # bo system może potrzebować pobrać usuniętego usera np. żeby wyświetlić "Konto Usunięte" w komentarzach.
        return result.scalars().first()
    

    async def get_by_email_or_username(self, identifier: str) -> Optional[User]:
        """
        Logowanie: Sprawdza czy identyfikator pasuje do emaila lub username
        (w obu przypadkach case-insensitive).
        """
        identifier_lower = identifier.lower()
        # Szukamy po emailu LUB po username (ignorując wielkość liter w obu przypadkach)
        # [ZMIANA]: Pobieramy tylko aktywnych użytkowników
        result = await self.db.execute(
            select(User).filter(
                or_(
                    User.email == identifier_lower,
                    func.lower(User.username) == identifier_lower
                ),
                User.is_active == True
            )
        )
        return result.scalars().first()
    

    async def create(self, user_data: UserCreate) -> User:
        hashed_password = get_password_hash(user_data.password)
        
        # WAŻNE: Zapisujemy user_data.username W ORYGINALE (np. "RafalDev").
        # Unikalność ("rafaldev" vs "RafalDev") jest pilnowana przez:
        # 1. get_by_username() użyte w routerze przed zapisem (Application Layer check)
        # 2. Index unique na func.lower(username) w bazie (Database Layer check)
        
        db_user = User(
            username=user_data.username, # Zachowujemy casing dla ładnego wyświetlania
            email=user_data.email.lower(),
            hashed_password=hashed_password,
        )
        self.db.add(db_user)
        await self.db.commit()
        await self.db.refresh(db_user)
        return db_user
    

    async def update(self, user: User) -> User:
        """
        Zapisuje zmiany dokonane na obiekcie użytkownika.
        """
        self.db.add(user) # Oznaczamy obiekt jako "do zapisania"
        await self.db.commit() # Fizyczny zapis w bazie
        await self.db.refresh(user) # Odświeżenie danych (np. updated_at)
        return user


    async def suggest_available_username(self, username: str) -> str:
        """
        Generuje unikalną nazwę użytkownika, dodając liczbę na końcu.
        Np. jeśli 'Tom' jest zajęty, szuka 'Tom1', 'Tom2'... i zwraca pierwszy wolny.
        """
        base_username = username
        
        # Pobieramy wszystkie loginy, które zaczynają się tak samo (ignorując wielkość liter)
        # Używamy LIKE 'username%', żeby znaleźć 'Tom', 'Tom1', 'Tom999'
        query = select(User.username).filter(
            func.lower(User.username).like(f"{base_username.lower()}%")
        )
        result = await self.db.execute(query)
        existing_usernames = result.scalars().all()

        # Jeśli nie ma żadnych konfliktów (teoretycznie funkcja wywoływana tylko gdy są), zwracamy oryginał
        if not existing_usernames:
            return base_username

        # Tworzymy zbiór małych liter dla szybkiego sprawdzania
        existing_set = {u.lower() for u in existing_usernames}

        # Jeśli podstawowa nazwa jest wolna (np. ktoś usunął konto w międzyczasie), zwracamy ją
        if base_username.lower() not in existing_set:
            return base_username

        # Szukamy pierwszej wolnej liczby
        counter = 1
        while True:
            new_username = f"{base_username}{counter}"
            if new_username.lower() not in existing_set:
                return new_username
            counter += 1

    # --- [ZMIANA]: NOWA METODA - PROFESJONALNE USUWANIE KONTA ---
    async def soft_delete_user(self, user: User) -> None:
        """
        Soft Delete + Anonimizacja danych (Zgodność z RODO/GDPR).
        Zwalnia email i username dla przyszłych rejestracji innych osób.
        """
        random_suffix = uuid.uuid4().hex[:8]
        
        # 1. Anonimizacja danych wrażliwych
        # email musi być unikalny, więc dodajemy UUID, ale wciąż musi mieć format maila wg Pydantic (jeśli gdzieś validujemy baze)
        user.email = f"deleted_{user.id}@anonymized.local" 
        # Zmieniamy username, by uwolnić oryginalny nick
        user.username = f"DeletedUser_{random_suffix}" 
        # Kasujemy hasło, nikt się już nie zaloguje
        user.hashed_password = "DELETED_ACCOUNT" 
        
        # 2. Ustawienie flag usunięcia
        user.is_active = False
        user.deleted_at = datetime.now(timezone.utc)

        # Zapis do bazy
        self.db.add(user)
        await self.db.commit()


===============================
Ścieżka do pliku: ./migrations/env.py

Zawartość pliku:

from logging.config import fileConfig
from sqlalchemy.ext.asyncio import create_async_engine
from alembic import context
from src.db.models.user import Base  # Importuj klasę Base z modeli
from src.core.config import settings  # Importuj ustawienia z DATABASE_URL
from src.db.models.refresh_token import RefreshToken

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
target_metadata = Base.metadata

def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = settings.DATABASE_URL
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()

async def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    connectable = create_async_engine(settings.DATABASE_URL, echo=True)

    async with connectable.connect() as connection:
        await connection.run_sync(
            lambda sync_conn: context.configure(
                connection=sync_conn,
                target_metadata=target_metadata,
                render_as_batch=True
            )
        )

        async with context.begin_transaction():
            await connection.run_sync(lambda sync_conn: context.run_migrations())

if context.is_offline_mode():
    run_migrations_offline()
else:
    import asyncio
    asyncio.run(run_migrations_online())


===============================
Ścieżka do pliku: ./migrations/versions/57c457fd2492_add_case_insensitive_username_index.py

Zawartość pliku:

"""add case insensitive username index

Revision ID: 57c457fd2492
Revises: 82e631a4ad32
Create Date: 2026-02-02 20:58:58.583350

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '57c457fd2492'
down_revision: Union[str, None] = '82e631a4ad32'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # 1. Modyfikujemy tylko tabelę users
    with op.batch_alter_table('users', schema=None) as batch_op:
        # Usuwamy stary, zwykły indeks (case-sensitive)
        # UWAGA: Upewnij się, że nazwa 'ix_users_username' jest poprawna. 
        # Jeśli masz wątpliwości, sprawdź w DB Browser for SQLite lub innym narzędziu.
        batch_op.drop_index('ix_users_username')

        # 2. Tworzymy nowy indeks funkcyjny (case-insensitive)
        # Ręcznie dodajemy sa.text('lower(username)')
        batch_op.create_index(
            'ix_users_username_lower',
            [sa.text('lower(username)')], 
            unique=True
        )


def downgrade() -> None:
    """Downgrade schema."""
    with op.batch_alter_table('users', schema=None) as batch_op:
        # Usuwamy nasz nowy indeks
        batch_op.drop_index('ix_users_username_lower')

        # Przywracamy stary indeks
        batch_op.create_index('ix_users_username', ['username'], unique=True)


===============================
Ścieżka do pliku: ./migrations/versions/82e631a4ad32_update_user_model.py

Zawartość pliku:

"""Update User model

Revision ID: 82e631a4ad32
Revises: 
Create Date: 2025-06-13 14:44:17.004060

"""
from typing import Sequence, Union
from alembic import op
import sqlalchemy as sa
import enum

# revision identifiers, used by Alembic.
revision: str = '82e631a4ad32'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

class AccountRole(enum.Enum):
    ADMIN = "ADMIN"
    MODERATOR = "MODERATOR"
    REGULAR = "REGULAR"

class AccountSubscription(enum.Enum):
    FREE = "FREE"
    PRO = "PRO"

def upgrade() -> None:
    """Upgrade schema."""
    # Utwórz tymczasową tabelę z nowym schematem
    op.create_table(
        'users_temp',
        sa.Column('id', sa.String(), primary_key=True),
        sa.Column('username', sa.String(), nullable=False),
        sa.Column('email', sa.String(), nullable=False),
        sa.Column('hashed_password', sa.String(), nullable=False),
        sa.Column('account_role', sa.Enum(AccountRole, name='accountrole'), nullable=False),
        sa.Column('account_subscription', sa.Enum(AccountSubscription, name='accountsubscription'), nullable=False),
        sa.Column('subscription_expires_at', sa.DateTime(), nullable=True),
        sa.Column('created_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
        sa.Column('updated_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    )

    # Skopiuj dane z istniejącej tabeli
    op.execute(
        """
        INSERT INTO users_temp (id, username, email, hashed_password, account_role, account_subscription, subscription_expires_at, created_at, updated_at)
        SELECT CAST(id AS TEXT), '', '', '', 'REGULAR', 'FREE', NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
        FROM users
        """
    )

    # Usuń starą tabelę
    op.drop_table('users')

    # Zmień nazwę tymczasowej tabeli
    op.rename_table('users_temp', 'users')

    # Dodaj indeksy
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)
    op.create_index(op.f('ix_users_username'), 'users', ['username'], unique=True)

def downgrade() -> None:
    """Downgrade schema."""
    # Utwórz tymczasową tabelę ze starym schematem
    op.create_table(
        'users_temp',
        sa.Column('id', sa.NUMERIC(), primary_key=True),
    )

    # Skopiuj dane z powrotem
    op.execute(
        """
        INSERT INTO users_temp (id)
        SELECT CAST(id AS NUMERIC) FROM users
        """
    )

    # Usuń nową tabelę
    op.drop_table('users')

    # Zmień nazwę tymczasowej tabeli
    op.rename_table('users_temp', 'users')

    # Usuń indeks


===============================
Ścieżka do pliku: ./migrations/versions/21befe77be08_add_soft_delete_to_user.py

Zawartość pliku:

"""add_soft_delete_to_user

Revision ID: 21befe77be08
Revises: 57c457fd2492
Create Date: 2026-02-23 20:18:50.186397

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '21befe77be08'
down_revision: Union[str, None] = '57c457fd2492'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # [ZMIANA]: Usunięto kod kasujący tabelę password_reset_tokens!
    with op.batch_alter_table('users', schema=None) as batch_op:
        # [ZMIANA]: Dodano server_default='1', aby zapobiec błędowi w SQLite
        batch_op.add_column(sa.Column('is_active', sa.Boolean(), nullable=False, server_default='1'))
        batch_op.add_column(sa.Column('deleted_at', sa.DateTime(timezone=True), nullable=True))


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.drop_column('deleted_at')
        batch_op.drop_column('is_active')



