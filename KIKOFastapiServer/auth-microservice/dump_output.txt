===============================
Ścieżka do pliku: ./src/__init__.py

Zawartość pliku:




===============================
Ścieżka do pliku: ./src/dependencies.py

Zawartość pliku:


from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.config import settings
from src.db.models.user import User as UserDb
from src.db.repository.user_repository import UserRepository
from src.db.session import get_db
from src.api.v1.schemas.token import TokenData

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")

async def get_current_user(
        db: AsyncSession = Depends(get_db), token: str = Depends(oauth2_scheme)
) -> UserDb:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id: str = payload.get("sub")
        token_type: str = payload.get("type")
        
        if user_id is None or token_type != "access":
            raise credentials_exception
        token_data = TokenData(user_id=user_id)
    except JWTError:
        raise credentials_exception
    
    repo = UserRepository(db)
    user = await repo.get_by_id(user_id=token_data.user_id)
    if user is None:
        raise credentials_exception
    return user
    

    


===============================
Ścieżka do pliku: ./src/main.py

Zawartość pliku:

from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import Response, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.exc import OperationalError

from src.api.v1.routers import auth
from src.api.v1.routers import test
from src.db.models.user import Base
from src.db.models.refresh_token import RefreshToken
from src.db.models.password_reset import PasswordResetToken
from src.db.session import engine
from src.api.v1.routers.health import health_router

import yaml

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup logic: Create database tables
    async with engine.begin() as conn:
        # await conn.run_sync(Base.metadata.drop_all)  # Uncomment to reset DB if needed
        await conn.run_sync(Base.metadata.create_all)
    yield
    # Shutdown logic (optional): Add cleanup tasks here if needed
    # Example: await engine.dispose() to close the database connection
    pass

app = FastAPI(
    title="My Users Service", 
    description="API for User Management and Authentication", 
    version="1.0.0",
    lifespan=lifespan
    )


@app.exception_handler(OperationalError)
async def db_connection_handler(request: Request, exc: OperationalError):
    # Log dla Ciebie w konsoli
    print(f"LOG: Database OperationalError caught: {exc}")

    # Przypadek 1: Baza zablokowana (SQLite Lock)
    if "database is locked" in str(exc):
        return JSONResponse(
            status_code=503, 
            content={
                # Tutaj dodajemy jasną informację, że to wina bazy
                "detail": "Database error: Resource is locked. Service temporarily unavailable.",
                "error_code": "DB_LOCKED"
            }
        )
    
    # Przypadek 2: Inne błędy (np. zerwane połączenie, błąd składni SQL, brak serwera)
    return JSONResponse(
        status_code=500,
        content={
            # Tutaj też jasne info o bazie
            "detail": "Database error: Internal operation failed.",
            "error_code": "DB_ERROR"
        }
    )


# <--- 2. Konfiguracja Middleware
# W środowisku deweloperskim (Wasm lokalnie) najlepiej zezwolić na wszystko ("*")
# W produkcji powinieneś tu wpisać konkretny adres, z którego serwowany jest plik .wasm/.html
origins = [
    "*", 
    # "http://localhost:8000",
    # "http://127.0.0.1:8000",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,      # Zezwól na zapytania z tych źródeł
    allow_credentials=True,
    allow_methods=["*"],        # Zezwól na wszystkie metody (GET, POST, OPTIONS itd.)
    allow_headers=["*"],        # Zezwól na wszystkie nagłówki (w tym Content-Type)
)

app.include_router(auth.router)
app.include_router(test.router)
app.include_router(health_router, prefix="/health", tags=["Health & Operations"])


@app.get("/docs.yaml")
async def yaml_docs():
    try:
        openapi_schema = app.openapi()
        yaml_content = yaml.dump(openapi_schema, sort_keys=False)
        return Response(
            content=yaml_content,
            media_type="application/yaml",
            headers={"Content-Disposition": "attachment; filename=docs.yaml"}
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating YAML: {str(e)}")


@app.get("/", tags=['Health Check'])
async def root():
    return {"status": "ok"}


===============================
Ścieżka do pliku: ./src/core/config.py

Zawartość pliku:

import os
from pydantic_settings import BaseSettings
from dotenv import load_dotenv

load_dotenv()

class Settings(BaseSettings):
    VERSION: str = "1.0.0"
    CAPTCHA_SERVICE_URL: str = os.getenv("CAPTCHA_SERVICE_URL", "http://127.0.0.1:8001/api/v1") 
    # JWT Settings
    SECRET_KEY: str = os.getenv("SECRET_KEY", "Z9X8v5y7_kJqP3mW2nL4rT6uY8iO0pQ2xR5tV7wU9")
    ALGORITHM: str = os.getenv("ALGORITHM", "HS256")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", 30))
    REFRESH_TOKEN_EXPIRE_DAYS: int = int(os.getenv("REFRESH_TOKEN_EXPIRE_DAYS", 7))

    # Database Settings
    DATABASE_URL: str = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./users.db")

    # Password Reset
    RESET_TOKEN_EXPIRE_MINUTES: int = int(os.getenv("RESET_TOKEN_EXPIRE_MINUTES", 15))
    FRONTEND_URL: str = os.getenv("FRONTEND_URL", "http://localhost:3000")
    
    # Email Settings (przykładowe pod Gmail lub SMTP)
    SMTP_HOST: str = os.getenv("SMTP_HOST", "smtp.gmail.com")
    SMTP_PORT: int = int(os.getenv("SMTP_PORT", 587))
    SMTP_USER: str = os.getenv("SMTP_USER", "twoj-email@gmail.com")
    SMTP_PASSWORD: str = os.getenv("SMTP_PASSWORD", "twoje-haslo-aplikacji")
    # Adres e-mail, z którego system "technicznie" wysyła wiadomości.
    # To na ten adres użytkownik spróbuje odpisać, jeśli kliknie "Odpowiedz".
    # os.getenv(...) sprawdza czy w pliku .env jest klucz EMAILS_FROM_EMAIL.
    # Jeśli nie ma, używa wartości domyślnej "info@myapp.com".
    EMAILS_FROM_EMAIL: str = os.getenv("EMAILS_FROM_EMAIL", "info@myapp.com")
    # Nazwa wyświetlana (Friendly Name), którą użytkownik widzi na liście wiadomości
    # zamiast surowego adresu e-mail. Buduje to zaufanie i profesjonalny wizerunek.
    # Np. zamiast widzieć "info@myapp.com", użytkownik zobaczy "My Users Service".
    EMAILS_FROM_NAME: str = os.getenv("EMAILS_FROM_NAME", "English Learner")
    
settings = Settings()


===============================
Ścieżka do pliku: ./src/core/security.py

Zawartość pliku:

from datetime import datetime, timedelta, timezone
from typing import Optional

from jose import JWTError, jwt
from passlib.context import CryptContext

from .config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def verify_password(plain_password: str, hashed_password: str) ->bool:
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire, "type": "access"})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


def create_refresh_token(data: dict) -> str:
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire, "type": "refresh"})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


===============================
Ścieżka do pliku: ./src/services/email/service.py

Zawartość pliku:

import os
from pathlib import Path
from typing import List

from fastapi_mail import FastMail, MessageSchema, ConnectionConfig, MessageType
from src.core.config import settings

# Ustalanie ścieżki do szablonów w sposób niezależny od systemu operacyjnego
# __file__ to ścieżka do tego pliku (service.py).
# .parent to katalog 'email', a / 'templates' to podkatalog.
TEMPLATE_FOLDER = Path(__file__).resolve().parent / "templates"

class EmailService:
    def __init__(self):
        # Konfiguracja połączenia SMTP
        self.conf = ConnectionConfig(
            MAIL_USERNAME=settings.SMTP_USER,
            MAIL_PASSWORD=settings.SMTP_PASSWORD,
            MAIL_FROM=settings.EMAILS_FROM_EMAIL,
            MAIL_PORT=settings.SMTP_PORT,
            MAIL_SERVER=settings.SMTP_HOST,
            MAIL_FROM_NAME=settings.EMAILS_FROM_NAME,
            MAIL_STARTTLS=True,  # Zazwyczaj True dla portu 587
            MAIL_SSL_TLS=False,  # Zazwyczaj False dla portu 587 (True dla 465)
            USE_CREDENTIALS=True,
            VALIDATE_CERTS=True,
            TEMPLATE_FOLDER=TEMPLATE_FOLDER
        )
        self.fast_mail = FastMail(self.conf)

    async def send_reset_password_email(self, email_to: str, token: str):
        """
        Wysyła prawdziwy email z użyciem szablonu HTML.
        """
        # 1. Przygotowanie danych do szablonu (Context)
        reset_link = f"{settings.FRONTEND_URL}/auth/reset-password?token={token}"
        
        template_body = {
            "app_name": settings.EMAILS_FROM_NAME,
            "link": reset_link,
            "valid_minutes": settings.RESET_TOKEN_EXPIRE_MINUTES,
            "subject": "Reset Your Password" # Przekazujemy też do base.html
        }

        # 2. Tworzenie wiadomości
        message = MessageSchema(
            subject="Reset Your Password - Action Required",
            recipients=[email_to], # Lista odbiorców
            template_body=template_body,
            subtype=MessageType.html # Ważne: wysyłamy HTML
        )

        # 3. Wysyłka
        try:
            # template_name musi pasować do nazwy pliku w katalogu templates
            await self.fast_mail.send_message(message, template_name="reset_password.html")
            print(f"LOG: Email sent to {email_to}")
        except Exception as e:
            print(f"ERROR: Failed to send email to {email_to}. Error: {e}")
            # W produkcji tutaj dodałbyś logowanie do pliku lub Sentry
            # Nie rzucamy wyjątku, żeby nie przerywać działania aplikacji (to leci w tle)

email_service = EmailService()


===============================
Ścieżka do pliku: ./src/services/email/__init__.py

Zawartość pliku:




===============================
Ścieżka do pliku: ./src/services/email/templates/base.html

Zawartość pliku:

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>{{ subject }}</title>
    <style>
        body { font-family: Arial, sans-serif; background-color: #f4f4f4; padding: 20px; }
        .container { max-width: 600px; margin: 0 auto; background: #ffffff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .header { text-align: center; border-bottom: 1px solid #eee; padding-bottom: 20px; margin-bottom: 20px; }
        .footer { margin-top: 30px; text-align: center; font-size: 12px; color: #888; }
        .button { background-color: #007bff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; display: inline-block; margin-top: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h2>{{ app_name }}</h2>
        </div>
        
        <div class="content">
            {% block content %}{% endblock %}
        </div>

        <div class="footer">
            <p>&copy; 2026 {{ app_name }}. All rights reserved.</p>
            <p>If you did not request this email, please ignore it.</p>
        </div>
    </div>
</body>
</html>


===============================
Ścieżka do pliku: ./src/services/email/templates/reset_password.html

Zawartość pliku:

{% extends "base.html" %}

{% block content %}
<h3>Hello,</h3>
<p>We received a request to reset your password for your account at <strong>{{ app_name }}</strong>.</p>
<p>Please click the button below to set a new password:</p>

<div style="text-align: center;">
    <a href="{{ link }}" class="button">Reset Password</a>
</div>

<p>Or copy and paste this link into your browser:</p>
<p><a href="{{ link }}">{{ link }}</a></p>

<p>This link is valid for <strong>{{ valid_minutes }} minutes</strong>.</p>
{% endblock %}


===============================
Ścieżka do pliku: ./src/api/v1/routers/auth.py

Zawartość pliku:

import httpx
import secrets
from uuid import uuid4
from jose import JWTError, jwt
from datetime import datetime, timedelta, timezone
from fastapi import APIRouter, Depends, HTTPException, status, Response, BackgroundTasks
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.config import settings
from src.core.security import get_password_hash

from src.db.session import get_db
from src.db.repository.user_repository import UserRepository
from src.db.repository.refresh_token_repository import RefreshTokenRepository
from src.db.repository.password_reset_repository import PasswordResetRepository
from src.db.models.password_reset import PasswordResetToken

from src.core.security import verify_password, create_access_token, create_refresh_token

from src.api.v1.schemas import user as user_schema
from src.api.v1.schemas.user import UserRegister, UserCreate 
from src.api.v1.schemas import token as token_schema
from src.api.v1.schemas.auth import ForgotPasswordRequest, ResetPasswordRequest

from src.services.email.service import email_service




router = APIRouter(prefix="/api/v1/auth", tags=["Authentication"])


@router.post("/register", response_model=user_schema.UserPublic, status_code=status.HTTP_201_CREATED)
async def register_user(
    user_in: UserRegister, # <--- Używamy schematu zawierającego pola captcha
    db: AsyncSession = Depends(get_db)
):
    # --- 1. WERYFIKACJA CAPTCHA Z TIMEOUTEM ---
    captcha_url = f"{settings.CAPTCHA_SERVICE_URL}/captcha/verify"
    
    captcha_payload = {
        "id": str(user_in.captcha_id),
        "answer": user_in.captcha_answer
    }

    # Ustawienie timeout na 5 sekund
    # timeout=5.0 oznacza: max 5s na nawiązanie połączenia, max 5s na odczyt danych itd.
    async with httpx.AsyncClient(timeout=5.0) as client:
        try:
            response = await client.post(captcha_url, json=captcha_payload)
            response.raise_for_status() # Rzuci błąd jeśli Captcha Service zwróci 4xx lub 5xx
            
            verify_data = response.json()
            
            if not verify_data.get("is_valid"):
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST, 
                    detail="Invalid CAPTCHA answer"
                )

        except httpx.TimeoutException:
            # Obsługa przekroczenia czasu oczekiwania (5 sekund)
            print("Błąd: Serwis Captcha nie odpowiedział w ciągu 5 sekund.")
            raise HTTPException(
                status_code=status.HTTP_504_GATEWAY_TIMEOUT, 
                detail="Captcha verification timed out. Please try again later."
            )
            
        except httpx.RequestError as exc:
            # Obsługa braku połączenia (np. serwis leży, zły adres URL)
            print(f"Błąd połączenia z serwisem Captcha: {exc}")
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE, 
                detail="Captcha service unavailable. Please try again later."
            )
        
        except httpx.HTTPStatusError as exc:
            # Obsługa błędów HTTP (np. 500 z serwera Captcha)
            print(f"Serwis Captcha zwrócił błąd HTTP: {exc.response.status_code}")
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Error communicating with captcha service."
            )

    # --- 2. LOGIKA BIZNESOWA REJESTRACJI ---
    
    # Konwersja UserRegister -> UserCreate (usuwamy pola captcha)
    user_create_data = UserCreate(
        **user_in.model_dump(exclude={"captcha_id", "captcha_answer"})
    )

    repo = UserRepository(db)
    
    # Sprawdzenie czy email istnieje
    db_user = await repo.get_by_email(email=user_create_data.email)
    if db_user:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Email already registered")
    
    # Sprawdzenie czy username istnieje
    db_user = await repo.get_by_username(username=user_create_data.username)
    if db_user:
        suggested_username = await repo.suggest_available_username(user_create_data.username)
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT, 
            detail={
                "message": "Username already taken",
                "suggestion": suggested_username
            }
        )
    
    # Utworzenie użytkownika
    user = await repo.create(user_data=user_create_data)
    return user


@router.post("/login", response_model=token_schema.Token)
async def login_for_access_token(
    db: AsyncSession = Depends(get_db), 
    form_data: OAuth2PasswordRequestForm = Depends()):

    repo = UserRepository(db)
    user = await repo.get_by_email(email=form_data.username)
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token = create_access_token(data={"sub": str(user.id)})
    refresh_token = create_refresh_token(data={"sub": str(user.id)})

    # save RefreshToken
    refresh_token_repo = RefreshTokenRepository(db)
    expires_at = datetime.now(timezone.utc) + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    await refresh_token_repo.create(
        user_id=user.id,
        token=refresh_token,
        expires_at=expires_at
    )
    
    return {"access_token": access_token, "refresh_token": refresh_token, "token_type": "bearer"}


@router.post("/logout", status_code=status.HTTP_204_NO_CONTENT)
async def logout(
    token_request: token_schema.RefreshTokenRequest,
    db: AsyncSession = Depends(get_db)):

    refresh_token_repo = RefreshTokenRepository(db)

    # find token in database
    db_token = await refresh_token_repo.get_by_token(token=token_request.refresh_token)
    
    # if token exist, delete it
    if db_token:
        await refresh_token_repo.delete(token_id=db_token.id)

    return Response(status_code=status.HTTP_204_NO_CONTENT)


@router.post("/refresh", response_model=token_schema.Token)
async def refresh_access_token(
    token_request: token_schema.RefreshTokenRequest,
    db: AsyncSession = Depends(get_db)
):
    refresh_token_repo = RefreshTokenRepository(db)
    
    # 1. Znajdź token odświeżający w bazie danych
    db_refresh_token = await refresh_token_repo.get_by_token(token=token_request.refresh_token)

    # 2. Sprawdź, czy token istnieje i czy nie wygasł
    if not db_refresh_token or db_refresh_token.expires_at < datetime.now(timezone.utc):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired refresh token",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 3. Jeśli token istnieje, ALE WYGASŁ, usuń go i odrzuć
    if db_refresh_token.expires_at < datetime.now(timezone.utc):
        await refresh_token_repo.delete(token_id=db_refresh_token.id) # <-- DODANA LINIA
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired refresh token", # Można zostawić ten sam komunikat
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 4. Zweryfikuj poprawność samego JWT (chociaż baza jest głównym źródłem prawdy)
    try:
        payload = jwt.decode(
            token_request.refresh_token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]
        )
        if payload.get("type") != "refresh":
             raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token type")
    except JWTError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Could not validate token")

    # 5. Stwórz nowy token dostępowy
    new_access_token = create_access_token(data={"sub": str(db_refresh_token.user_id)})
    
    # (Token Rotation): unieważnij stary i wydaj nowy refresh token
    await refresh_token_repo.delete(token_id=db_refresh_token.id)
    new_refresh_token = create_refresh_token(data={"sub": str(db_refresh_token.user_id)})
    expires_at = datetime.now(timezone.utc) + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    await refresh_token_repo.create(
        user_id=db_refresh_token.user_id,
        token=new_refresh_token,
        expires_at=expires_at
    )

    return {
        "access_token": new_access_token,
        "refresh_token": new_refresh_token,
        "token_type": "bearer"
    }

@router.post("/forgot-password", status_code=status.HTTP_202_ACCEPTED)
async def forgot_password(
    request: ForgotPasswordRequest,
    background_tasks: BackgroundTasks, # <--- Wstrzykiwanie zadań w tle
    db: AsyncSession = Depends(get_db)
):
    """
    Inicjuje proces resetowania hasła.
    Zwraca 202 Accepted niezależnie od tego, czy email istnieje (Security).
    """
    user_repo = UserRepository(db)
    user = await user_repo.get_by_email(request.email)

    if user:
        # 1. Generujemy bezpieczny token (URL-safe string)
        token = secrets.token_urlsafe(32)
        
        # 2. Zapisujemy token w bazie
        reset_repo = PasswordResetRepository(db)
        expires_at = datetime.now(timezone.utc) + timedelta(minutes=settings.RESET_TOKEN_EXPIRE_MINUTES)
        
        await reset_repo.create(
            user_id=user.id,
            token=token,
            expires_at=expires_at
        )

        # 3. Wysyłamy email w tle (nie blokujemy odpowiedzi API)
        background_tasks.add_task(
            email_service.send_reset_password_email,
            email_to=user.email,
            token=token
        )

    # ZAWSZE zwracamy ten sam komunikat dla bezpieczeństwa
    return {"message": "If the email exists, a reset link has been sent."}


@router.post("/reset-password", status_code=status.HTTP_200_OK)
async def reset_password(
    request: ResetPasswordRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    Ustawia nowe hasło na podstawie ważnego tokena.
    """
    reset_repo = PasswordResetRepository(db)
    user_repo = UserRepository(db)

    # 1. Sprawdź czy token jest poprawny i ważny
    db_token = await reset_repo.get_valid_token(request.token)
    if not db_token:
        # Tutaj możemy rzucić 400, bo user już wszedł w link i oczekuje efektu
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid or expired reset token"
        )

    # 2. Znajdź użytkownika
    user = await user_repo.get_by_id(db_token.user_id)
    if not user:
         raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )

    # 3. Zhashuj nowe hasło i zaktualizuj usera
    new_hashed_password = get_password_hash(request.new_password)
    
    # Robimy to elegancko:
    user.hashed_password = new_hashed_password # Zmieniamy pole na obiekcie
    # Zlecamy zapis repozytorium
    await user_repo.update(user)

    # 4. Oznacz token jako zużyty
    await reset_repo.mark_as_used(db_token.id)
    
    # 5. WYLOGUJ ZE WSZYSTKICH URZĄDZEŃ (Bezpieczeństwo)
    refresh_token_repo = RefreshTokenRepository(db)
    await refresh_token_repo.delete_all_for_user(user.id) 

    # await db.commit() <--- TO MOŻESZ USUNĄĆ, bo metody repozytoriów (mark_as_used, delete_all...) 
    # robią commit wewnątrz siebie. Nadmiarowy commit nie szkodzi, ale nie jest potrzebny.

    return {"message": "Password has been reset successfully"}


===============================
Ścieżka do pliku: ./src/api/v1/routers/test.py

Zawartość pliku:

from fastapi import APIRouter, Depends
from typing import Dict
from src.db.models.user import User as UserDb
from src.dependencies import get_current_user

router = APIRouter(prefix="/api/v1/data", tags=["Data"])

@router.get("/test-data", response_model=Dict[str, str])
async def get_test_data(current_user: UserDb = Depends(get_current_user)):
    return {"message": "This is protected test data", "user_id": str(current_user.id)}



===============================
Ścieżka do pliku: ./src/api/v1/routers/health.py

Zawartość pliku:

from fastapi import APIRouter, status
from src.api.v1.schemas.health import HealthCheckResponse
from src.core.config import settings

health_router = APIRouter()

@health_router.get(
    "/live",
    response_model=HealthCheckResponse,
    status_code=status.HTTP_200_OK,
    summary="Liveness Probe",
    description="Sprawdza czy aplikacja jest uruchomiona. Nie sprawdza zależności."
)
async def liveness_probe():
    """
    Szybki check dla Kubernetesa. Jeśli to nie działa, K8s restartuje poda.
    """
    return HealthCheckResponse(
        status="ok",
        version=settings.VERSION
    )


===============================
Ścieżka do pliku: ./src/api/v1/schemas/auth.py

Zawartość pliku:

from pydantic import BaseModel, EmailStr, Field, field_validator
from src.api.v1.schemas.user import UserCreate  # Importujemy, żeby użyć walidatora hasła

class ForgotPasswordRequest(BaseModel):
    email: EmailStr

class ResetPasswordRequest(BaseModel):
    token: str
    new_password: str = Field(..., description="New password")

    # RE-USE LOGIC: Używamy tej samej walidacji co przy rejestracji!
    @field_validator("new_password")
    @classmethod
    def validate_password(cls, v):
        return UserCreate.validate_password_content(v)


===============================
Ścieżka do pliku: ./src/api/v1/schemas/token.py

Zawartość pliku:

from pydantic import BaseModel
from typing import Optional

class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"


class TokenData(BaseModel):
    user_id: Optional[str] = None


class RefreshTokenRequest(BaseModel):
    refresh_token: str


===============================
Ścieżka do pliku: ./src/api/v1/schemas/user.py

Zawartość pliku:

from pydantic import BaseModel, EmailStr, field_validator, ConfigDict, Field
from typing import Optional, Any
from uuid import UUID
from datetime import datetime
from src.db.models.user import AccountRole, AccountSubscription
import re


# Lista słów, których nie można użyć jako nazwy użytkownika
RESERVED_USERNAMES = {
    "admin", "administrator", "root", "system", "support", "help", 
    "moderator", "superuser", "guest", "api", "auth", "login", 
    "logout", "register", "dashboard", "settings", "profile"
}

# Regex: Startuje od litery, potem litery, cyfry, _ lub -. 
# Nie pozwala na _ lub - na końcu lub na początku (opcjonalnie).
# Tutaj prosta wersja: a-z, 0-9, _, -
USERNAME_REGEX = r"^[a-zA-Z0-9_-]+$"

class UserBase(BaseModel):
    email: EmailStr
    # ZMIANA: Usunięto min_length i max_length z Field(), aby uniknąć generycznych błędów Pydantic.
    # Walidacja długości odbywa się teraz w validate_username_security.
    username: str = Field(
        ..., 
        description="Username must be 3-30 characters, strictly alphanumeric, underscores or hyphens."
    )

    # Używamy mode='before', żeby naprawić dane zanim Pydantic zacznie marudzić
    @field_validator("email", mode="before")
    @classmethod
    def case_insensitive_email(cls, v: Any) -> Any:
        # Sprawdzamy czy to string, żeby nie wysadzić serwera
        # gdyby ktoś złośliwie przysłał int albo tablicę w polu email.
        if isinstance(v, str):
            return v.lower()
        return v


    @field_validator("username")
    @classmethod
    def validate_username_security(cls, value: str) -> str:
        # --- WAŻNE: NIE USUWAĆ PONIŻSZEGO BLOKU ---
        # Sprawdzamy długość ręcznie tutaj, zamiast w Field(), aby zwrócić
        # precyzyjny komunikat błędu dla Frontendu, zamiast generycznego
        # "String should have at least X characters" z Pydantic.
        if len(value) < 3:
            raise ValueError("Username must be at least 3 characters long.")
        if len(value) > 30:
            raise ValueError("Username cannot be longer than 30 characters.")
        # ------------------------------------------

        # 1. Sprawdzenie znaków (Regex)
        if not re.match(USERNAME_REGEX, value):
            raise ValueError("Username can only contain letters, numbers, underscores (_), and hyphens (-).")

        # 2. Sprawdzenie słów zastrzeżonych
        if value.lower() in RESERVED_USERNAMES:
            raise ValueError("This username is reserved and cannot be used.")
            
        # 3. Sprawdzenie czy nie wygląda jak email (żeby ludzie nie wpisywali tu maila)
        if "@" in value:
             raise ValueError("Username cannot contain '@' symbol.")

        # 4. Podwójne kropki/podkreślenia (opcjonalne - estetyka)
        if "__" in value or "--" in value:
            raise ValueError("Username cannot contain consecutive underscores or hyphens.")

        return value
    

class UserCreate(UserBase):
    # ZMIANA: Usuwamy 'min_length=6' stąd, żeby uniknąć błędu "String should have..."
    # Zostawiamy description dla dokumentacji
    password: str = Field(..., description="Password must be at least 6 characters long")

    @field_validator("password")
    @classmethod
    def validate_password_content(cls, value: str) -> str:
        # 1. ZMIANA: Dodajemy walidację długości TUTAJ, żeby mieć własny komunikat
        if len(value) < 6:
            raise ValueError("Password must be at least 6 characters long")

        # 2. Wymaganie: minimum jedna cyfra
        if not re.search(r"\d", value):
            raise ValueError("Password must contain at least one digit")
        
        # 3. Wymaganie: minimum jedna litera (duża lub mała)
        if not re.search(r"[a-zA-Z]", value):
            raise ValueError("Password must contain at least one letter")
            
        return value

class UserRegister(UserCreate):
    captcha_id: UUID
    captcha_answer: str
    
class UserPublic(UserBase):
    id: UUID
    account_role: AccountRole
    account_subscription: AccountSubscription
    subscription_expires_at: Optional[datetime] = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


===============================
Ścieżka do pliku: ./src/api/v1/schemas/health.py

Zawartość pliku:

from pydantic import BaseModel
from typing import Dict, Optional

class HealthCheckResponse(BaseModel):
    status: str
    version: str
    uptime: Optional[float] = None
    components: Optional[Dict[str, str]] = None

    class Config:
        json_schema_extra = {
            "example": {
                "status": "ok",
                "version": "1.0.0",
                "components": {
                    "database": "operational",
                    "redis": "down"
                }
            }
        }


===============================
Ścieżka do pliku: ./src/db/session.py

Zawartość pliku:

from typing import AsyncGenerator
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from src.core.config import settings

engine = create_async_engine(settings.DATABASE_URL, echo=True)
AsyncSessionLocal = sessionmaker(
    autocommit=False, 
    autoflush=False, 
    bind=engine, 
    class_=AsyncSession,
    expire_on_commit=False  # <--- DODAJ TĘ LINIĘ
)

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    async with AsyncSessionLocal() as session:
        yield session


===============================
Ścieżka do pliku: ./src/db/models/refresh_token.py

Zawartość pliku:

# src/db/models/refresh_token.py
import uuid
from sqlalchemy import Column, String, DateTime, func, ForeignKey
from sqlalchemy.orm import relationship
from .user import Base

class RefreshToken(Base):
    __tablename__ = "refresh_tokens"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    user_id = Column(String, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    refresh_token = Column(String, unique=True, index=True, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    created_at = Column(DateTime, server_default=func.now(), nullable=False)

    user = relationship("User")


===============================
Ścieżka do pliku: ./src/db/models/password_reset.py

Zawartość pliku:

import uuid
from sqlalchemy import Column, String, DateTime, func, ForeignKey, Boolean
from sqlalchemy.orm import relationship
from src.db.models.user import Base

class PasswordResetToken(Base):
    __tablename__ = "password_reset_tokens"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    user_id = Column(String, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    token = Column(String, unique=True, index=True, nullable=False)
    expires_at = Column(DateTime(timezone=True), nullable=False)
    is_used = Column(Boolean, default=False, nullable=False)
    created_at = Column(DateTime, server_default=func.now(), nullable=False)

    user = relationship("User")

    


===============================
Ścieżka do pliku: ./src/db/models/user.py

Zawartość pliku:

import uuid
import enum
from sqlalchemy import Column, String, DateTime, func, Enum, Index
from sqlalchemy.orm import declarative_base

Base = declarative_base()

class AccountSubscription(str, enum.Enum):
    FREE = "FREE"
    PRO = "PRO"

class AccountRole(str, enum.Enum):
    ADMIN = "ADMIN"
    MODERATOR = "MODERATOR"
    REGULAR = "REGULAR"

class User(Base):
    __tablename__ = "users"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    # Usuwamy index=True stąd, bo dodajemy niestandardowy index poniżej
    username = Column(String, unique=False, nullable=False) 
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    
    account_role = Column(Enum(AccountRole), default=AccountRole.REGULAR, nullable=False)

    account_subscription = Column(Enum(AccountSubscription), default=AccountSubscription.FREE, nullable=False)
    subscription_expires_at = Column(DateTime(timezone=True), nullable=True)

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)

    # --- PROFESJONALNE ZABEZPIECZENIE ---
    __table_args__ = (
        # 1. Unikalny index na małych literach username.
        # To gwarantuje, że 'Tom' i 'tom' nie mogą istnieć obok siebie w bazie.
        # Jest to najwydajniejszy sposób na case-insensitive uniqueness.
        Index('ix_users_username_lower', func.lower(username), unique=True),
        
        # 2. Zwykły index dla username (opcjonalny, jeśli często szukamy case-sensitive, ale rzadko to robimy)
        # W tym modelu index funkcyjny wyżej załatwia większość spraw.
    )


===============================
Ścieżka do pliku: ./src/db/repository/refresh_token_repository.py

Zawartość pliku:

from typing import Optional
from datetime import datetime
from sqlalchemy import delete
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload

from src.db.models.refresh_token import RefreshToken

class RefreshTokenRepository:
    def __init__(self, db_session: AsyncSession):
        self.db = db_session

    async def create(self, user_id: str, token: str, expires_at: datetime) -> RefreshToken:
        db_token = RefreshToken(
            user_id=user_id,
            refresh_token=token,
            expires_at=expires_at
        )
        self.db.add(db_token)
        await self.db.commit()
        await self.db.refresh(db_token)
        return db_token

    async def get_by_token(self, token: str) -> Optional[RefreshToken]:
        result = await self.db.execute(
            select(RefreshToken)
            .options(selectinload(RefreshToken.user)) # Opcjonalnie, aby załadować od razu dane usera
            .filter(RefreshToken.refresh_token == token)
        )
        return result.scalars().first()
    
    async def delete(self, token_id: str) -> None:
        db_token = await self.db.get(RefreshToken, token_id)
        if db_token:
            await self.db.delete(db_token)
            await self.db.commit()

    # Dodaj to na końcu klasy RefreshTokenRepository
    async def delete_all_for_user(self, user_id: str) -> None:
        """
        Usuwa wszystkie tokeny odświeżające danego użytkownika.
        Używane przy zmianie hasła, aby wylogować użytkownika ze wszystkich urządzeń.
        """
        # Importujemy delete wewnątrz metody lub na górze pliku
        from sqlalchemy import delete 
        
        stmt = delete(RefreshToken).where(RefreshToken.user_id == user_id)
        await self.db.execute(stmt)
        await self.db.commit()


===============================
Ścieżka do pliku: ./src/db/repository/password_reset_repository.py

Zawartość pliku:

from typing import Optional
from datetime import datetime, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from src.db.models.password_reset import PasswordResetToken

class PasswordResetRepository:
    def __init__(self, db_session: AsyncSession):
        self.db = db_session

    async def create(self, user_id: str, token: str, expires_at: datetime) -> PasswordResetToken:
        # Opcjonalnie: Możesz tu najpierw unieważnić poprzednie niewykorzystane tokeny tego usera
        db_token = PasswordResetToken(
            user_id=user_id,
            token=token,
            expires_at=expires_at,
            is_used=False
        )
        self.db.add(db_token)
        await self.db.commit()
        await self.db.refresh(db_token)
        return db_token

    async def get_valid_token(self, token: str) -> Optional[PasswordResetToken]:
        """
        Pobiera token, jeśli istnieje, nie został użyty i nie wygasł.
        """
        query = select(PasswordResetToken).filter(
            PasswordResetToken.token == token,
            PasswordResetToken.is_used == False,
            PasswordResetToken.expires_at > datetime.now(timezone.utc)
        )
        result = await self.db.execute(query)
        return result.scalars().first()

    async def mark_as_used(self, token_id: str) -> None:
        db_token = await self.db.get(PasswordResetToken, token_id)
        if db_token:
            db_token.is_used = True
            await self.db.commit()


===============================
Ścieżka do pliku: ./src/db/repository/user_repository.py

Zawartość pliku:

from typing import Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy import or_, func
from src.db.models.user import User
from src.api.v1.schemas.user import UserCreate
from src.core.security import get_password_hash
import re

class UserRepository:
    def __init__(self, db_session: AsyncSession):
        self.db = db_session

    async def get_by_email(self, email: str) -> Optional[User]:
        # Email jest zawsze lowercase (wymuszone w schemas), ale dla bezpieczeństwa:
        email_lower = email.lower()
        result = await self.db.execute(select(User).filter(User.email == email_lower))
        return result.scalars().first()
    

    async def get_by_username(self, username: str) -> Optional[User]:
        """
        Wyszukuje użytkownika ignorując wielkość liter.
        Dla wejścia 'tom' znajdzie użytkownika 'Tom'.
        """
        username_lower = username.lower()
        # Porównujemy lower(db_column) == lower(input)
        result = await self.db.execute(
            select(User).filter(func.lower(User.username) == username_lower)
        )
        return result.scalars().first()
    
    async def get_by_id(self, user_id: str) -> Optional[User]:
        result = await self.db.execute(select(User).filter(User.id == user_id))
        return result.scalars().first()
    

    async def get_by_email_or_username(self, identifier: str) -> Optional[User]:
        """
        Logowanie: Sprawdza czy identyfikator pasuje do emaila lub username
        (w obu przypadkach case-insensitive).
        """
        identifier_lower = identifier.lower()

        # Szukamy po emailu LUB po username (ignorując wielkość liter w obu przypadkach)
        result = await self.db.execute(
            select(User).filter(
                or_(
                    User.email == identifier_lower,
                    func.lower(User.username) == identifier_lower
                )
            )
        )
        return result.scalars().first()
    

    async def create(self, user_data: UserCreate) -> User:
        hashed_password = get_password_hash(user_data.password)
        
        # WAŻNE: Zapisujemy user_data.username W ORYGINALE (np. "RafalDev").
        # Unikalność ("rafaldev" vs "RafalDev") jest pilnowana przez:
        # 1. get_by_username() użyte w routerze przed zapisem (Application Layer check)
        # 2. Index unique na func.lower(username) w bazie (Database Layer check)
        
        db_user = User(
            username=user_data.username, # Zachowujemy casing dla ładnego wyświetlania
            email=user_data.email.lower(),
            hashed_password=hashed_password,
        )
        self.db.add(db_user)
        await self.db.commit()
        await self.db.refresh(db_user)
        return db_user
    

    async def update(self, user: User) -> User:
        """
        Zapisuje zmiany dokonane na obiekcie użytkownika.
        """
        self.db.add(user) # Oznaczamy obiekt jako "do zapisania"
        await self.db.commit() # Fizyczny zapis w bazie
        await self.db.refresh(user) # Odświeżenie danych (np. updated_at)
        return user


    async def suggest_available_username(self, username: str) -> str:
        """
        Generuje unikalną nazwę użytkownika, dodając liczbę na końcu.
        Np. jeśli 'Tom' jest zajęty, szuka 'Tom1', 'Tom2'... i zwraca pierwszy wolny.
        """
        base_username = username
        
        # Pobieramy wszystkie loginy, które zaczynają się tak samo (ignorując wielkość liter)
        # Używamy LIKE 'username%', żeby znaleźć 'Tom', 'Tom1', 'Tom999'
        query = select(User.username).filter(
            func.lower(User.username).like(f"{base_username.lower()}%")
        )
        result = await self.db.execute(query)
        existing_usernames = result.scalars().all()

        # Jeśli nie ma żadnych konfliktów (teoretycznie funkcja wywoływana tylko gdy są), zwracamy oryginał
        if not existing_usernames:
            return base_username

        # Tworzymy zbiór małych liter dla szybkiego sprawdzania
        existing_set = {u.lower() for u in existing_usernames}

        # Jeśli podstawowa nazwa jest wolna (np. ktoś usunął konto w międzyczasie), zwracamy ją
        if base_username.lower() not in existing_set:
            return base_username

        # Szukamy pierwszej wolnej liczby
        counter = 1
        while True:
            new_username = f"{base_username}{counter}"
            if new_username.lower() not in existing_set:
                return new_username
            counter += 1


