===============================
Ścieżka do pliku: ./src/dependencies.py

Zawartość pliku:


from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.config import settings
from src.db.models.user import User as UserDb
from src.db.repository.user_repository import UserRepository
from src.db.session import get_db
from src.api.v1.schemas.token import TokenData

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")

async def get_current_user(
        db: AsyncSession = Depends(get_db), token: str = Depends(oauth2_scheme)
) -> UserDb:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id: str = payload.get("sub")
        token_type: str = payload.get("type")
        
        if user_id is None or token_type != "access":
            raise credentials_exception
        token_data = TokenData(user_id=user_id)
    except JWTError:
        raise credentials_exception
    
    repo = UserRepository(db)
    user = await repo.get_by_id(user_id=token_data.user_id)
    if user is None:
        raise credentials_exception
    return user
    

    


===============================
Ścieżka do pliku: ./src/main.py

Zawartość pliku:

from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import Response, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.exc import OperationalError

from src.api.v1.routers import auth
from src.api.v1.routers import test
from src.db.models.user import Base
from src.db.models.refresh_token import RefreshToken
from src.db.session import engine
from src.api.v1.routers.health import health_router

import yaml

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup logic: Create database tables
    async with engine.begin() as conn:
        # await conn.run_sync(Base.metadata.drop_all)  # Uncomment to reset DB if needed
        await conn.run_sync(Base.metadata.create_all)
    yield
    # Shutdown logic (optional): Add cleanup tasks here if needed
    # Example: await engine.dispose() to close the database connection
    pass

app = FastAPI(
    title="My Users Service", 
    description="API for User Management and Authentication", 
    version="1.0.0",
    lifespan=lifespan
    )


@app.exception_handler(OperationalError)
async def db_connection_handler(request: Request, exc: OperationalError):
    # Log dla Ciebie w konsoli
    print(f"LOG: Database OperationalError caught: {exc}")

    # Przypadek 1: Baza zablokowana (SQLite Lock)
    if "database is locked" in str(exc):
        return JSONResponse(
            status_code=503, 
            content={
                # Tutaj dodajemy jasną informację, że to wina bazy
                "detail": "Database error: Resource is locked. Service temporarily unavailable.",
                "error_code": "DB_LOCKED"
            }
        )
    
    # Przypadek 2: Inne błędy (np. zerwane połączenie, błąd składni SQL, brak serwera)
    return JSONResponse(
        status_code=500,
        content={
            # Tutaj też jasne info o bazie
            "detail": "Database error: Internal operation failed.",
            "error_code": "DB_ERROR"
        }
    )


# <--- 2. Konfiguracja Middleware
# W środowisku deweloperskim (Wasm lokalnie) najlepiej zezwolić na wszystko ("*")
# W produkcji powinieneś tu wpisać konkretny adres, z którego serwowany jest plik .wasm/.html
origins = [
    "*", 
    # "http://localhost:8000",
    # "http://127.0.0.1:8000",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,      # Zezwól na zapytania z tych źródeł
    allow_credentials=True,
    allow_methods=["*"],        # Zezwól na wszystkie metody (GET, POST, OPTIONS itd.)
    allow_headers=["*"],        # Zezwól na wszystkie nagłówki (w tym Content-Type)
)

app.include_router(auth.router)
app.include_router(test.router)
app.include_router(health_router, prefix="/health", tags=["Health & Operations"])


@app.get("/docs.yaml")
async def yaml_docs():
    try:
        openapi_schema = app.openapi()
        yaml_content = yaml.dump(openapi_schema, sort_keys=False)
        return Response(
            content=yaml_content,
            media_type="application/yaml",
            headers={"Content-Disposition": "attachment; filename=docs.yaml"}
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating YAML: {str(e)}")


@app.get("/", tags=['Health Check'])
async def root():
    return {"status": "ok"}


===============================
Ścieżka do pliku: ./src/core/config.py

Zawartość pliku:

import os
from pydantic_settings import BaseSettings
from dotenv import load_dotenv

load_dotenv()

class Settings(BaseSettings):
    VERSION: str = "1.0.0"
    CAPTCHA_SERVICE_URL: str = os.getenv("CAPTCHA_SERVICE_URL", "http://127.0.0.1:8001/api/v1") 
    # JWT Settings
    SECRET_KEY: str = os.getenv("SECRET_KEY", "Z9X8v5y7_kJqP3mW2nL4rT6uY8iO0pQ2xR5tV7wU9")
    ALGORITHM: str = os.getenv("ALGORITHM", "HS256")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", 30))
    REFRESH_TOKEN_EXPIRE_DAYS: int = int(os.getenv("REFRESH_TOKEN_EXPIRE_DAYS", 7))

    # Database Settings
    DATABASE_URL: str = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./users.db")                                        

settings = Settings()


===============================
Ścieżka do pliku: ./src/core/security.py

Zawartość pliku:

from datetime import datetime, timedelta
from typing import Optional

from jose import JWTError, jwt
from passlib.context import CryptContext

from .config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def verify_password(plain_password: str, hashed_password: str) ->bool:
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire, "type": "access"})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


def create_refresh_token(data: dict) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire, "type": "refresh"})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


===============================
Ścieżka do pliku: ./src/api/v1/routers/auth.py

Zawartość pliku:

import httpx
from fastapi import APIRouter, Depends, HTTPException, status, Response
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import datetime, timedelta
from uuid import uuid4

from src.db.session import get_db
from src.db.repository.user_repository import UserRepository
from src.core.security import verify_password, create_access_token, create_refresh_token
from src.api.v1.schemas import user as user_schema
from src.api.v1.schemas.user import UserRegister, UserCreate 
from src.api.v1.schemas import token as token_schema

from src.db.repository.refresh_token_repository import RefreshTokenRepository
from src.core.config import settings
from jose import JWTError, jwt

router = APIRouter(prefix="/api/v1/auth", tags=["Authentication"])


@router.post("/register", response_model=user_schema.UserPublic, status_code=status.HTTP_201_CREATED)
async def register_user(
    user_in: UserRegister, # <--- Używamy schematu zawierającego pola captcha
    db: AsyncSession = Depends(get_db)
):
    # --- 1. WERYFIKACJA CAPTCHA Z TIMEOUTEM ---
    captcha_url = f"{settings.CAPTCHA_SERVICE_URL}/captcha/verify"
    
    captcha_payload = {
        "id": str(user_in.captcha_id),
        "answer": user_in.captcha_answer
    }

    # Ustawienie timeout na 5 sekund
    # timeout=5.0 oznacza: max 5s na nawiązanie połączenia, max 5s na odczyt danych itd.
    async with httpx.AsyncClient(timeout=5.0) as client:
        try:
            response = await client.post(captcha_url, json=captcha_payload)
            response.raise_for_status() # Rzuci błąd jeśli Captcha Service zwróci 4xx lub 5xx
            
            verify_data = response.json()
            
            if not verify_data.get("is_valid"):
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST, 
                    detail="Invalid CAPTCHA answer"
                )

        except httpx.TimeoutException:
            # Obsługa przekroczenia czasu oczekiwania (5 sekund)
            print("Błąd: Serwis Captcha nie odpowiedział w ciągu 5 sekund.")
            raise HTTPException(
                status_code=status.HTTP_504_GATEWAY_TIMEOUT, 
                detail="Captcha verification timed out. Please try again later."
            )
            
        except httpx.RequestError as exc:
            # Obsługa braku połączenia (np. serwis leży, zły adres URL)
            print(f"Błąd połączenia z serwisem Captcha: {exc}")
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE, 
                detail="Captcha service unavailable. Please try again later."
            )
        
        except httpx.HTTPStatusError as exc:
            # Obsługa błędów HTTP (np. 500 z serwera Captcha)
            print(f"Serwis Captcha zwrócił błąd HTTP: {exc.response.status_code}")
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Error communicating with captcha service."
            )

    # --- 2. LOGIKA BIZNESOWA REJESTRACJI ---
    
    # Konwersja UserRegister -> UserCreate (usuwamy pola captcha)
    user_create_data = UserCreate(
        **user_in.model_dump(exclude={"captcha_id", "captcha_answer"})
    )

    repo = UserRepository(db)
    
    # Sprawdzenie czy email istnieje
    db_user = await repo.get_by_email(email=user_create_data.email)
    if db_user:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Email already registered")
    
    # Sprawdzenie czy username istnieje
    db_user = await repo.get_by_username(username=user_create_data.username)
    if db_user:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Username already taken")
    
    # Utworzenie użytkownika
    user = await repo.create(user_data=user_create_data)
    return user


@router.post("/login", response_model=token_schema.Token)
async def login_for_access_token(
    db: AsyncSession = Depends(get_db), 
    form_data: OAuth2PasswordRequestForm = Depends()):

    repo = UserRepository(db)
    user = await repo.get_by_email_or_username(identifier=form_data.username)
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token = create_access_token(data={"sub": str(user.id)})
    refresh_token = create_refresh_token(data={"sub": str(user.id)})

    # save RefreshToken
    refresh_token_repo = RefreshTokenRepository(db)
    expires_at = datetime.utcnow() + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    await refresh_token_repo.create(
        user_id=user.id,
        token=refresh_token,
        expires_at=expires_at
    )
    
    return {"access_token": access_token, "refresh_token": refresh_token, "token_type": "bearer"}


@router.post("/logout", status_code=status.HTTP_204_NO_CONTENT)
async def logout(
    token_request: token_schema.RefreshTokenRequest,
    db: AsyncSession = Depends(get_db)):

    refresh_token_repo = RefreshTokenRepository(db)

    # find token in database
    db_token = await refresh_token_repo.get_by_token(token=token_request.refresh_token)
    
    # if token exist, delete it
    if db_token:
        await refresh_token_repo.delete(token_id=db_token.id)

    return Response(status_code=status.HTTP_204_NO_CONTENT)


@router.post("/refresh", response_model=token_schema.Token)
async def refresh_access_token(
    token_request: token_schema.RefreshTokenRequest,
    db: AsyncSession = Depends(get_db)
):
    refresh_token_repo = RefreshTokenRepository(db)
    
    # 1. Znajdź token odświeżający w bazie danych
    db_refresh_token = await refresh_token_repo.get_by_token(token=token_request.refresh_token)

    # 2. Sprawdź, czy token istnieje i czy nie wygasł
    if not db_refresh_token or db_refresh_token.expires_at < datetime.utcnow():
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired refresh token",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 3. Jeśli token istnieje, ALE WYGASŁ, usuń go i odrzuć
    if db_refresh_token.expires_at < datetime.utcnow():
        await refresh_token_repo.delete(token_id=db_refresh_token.id) # <-- DODANA LINIA
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired refresh token", # Można zostawić ten sam komunikat
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 4. Zweryfikuj poprawność samego JWT (chociaż baza jest głównym źródłem prawdy)
    try:
        payload = jwt.decode(
            token_request.refresh_token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]
        )
        if payload.get("type") != "refresh":
             raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token type")
    except JWTError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Could not validate token")

    # 5. Stwórz nowy token dostępowy
    new_access_token = create_access_token(data={"sub": str(db_refresh_token.user_id)})
    
    # (Token Rotation): unieważnij stary i wydaj nowy refresh token
    await refresh_token_repo.delete(token_id=db_refresh_token.id)
    new_refresh_token = create_refresh_token(data={"sub": str(db_refresh_token.user_id)})
    expires_at = datetime.utcnow() + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    await refresh_token_repo.create(
        user_id=db_refresh_token.user_id,
        token=new_refresh_token,
        expires_at=expires_at
    )

    return {
        "access_token": new_access_token,
        "refresh_token": new_refresh_token,
        "token_type": "bearer"
    }


===============================
Ścieżka do pliku: ./src/api/v1/routers/test.py

Zawartość pliku:

from fastapi import APIRouter, Depends
from typing import Dict
from src.db.models.user import User as UserDb
from src.dependencies import get_current_user

router = APIRouter(prefix="/api/v1/data", tags=["Data"])

@router.get("/test-data", response_model=Dict[str, str])
async def get_test_data(current_user: UserDb = Depends(get_current_user)):
    return {"message": "This is protected test data", "user_id": str(current_user.id)}



===============================
Ścieżka do pliku: ./src/api/v1/routers/health.py

Zawartość pliku:

from fastapi import APIRouter, status
from src.api.v1.schemas.health import HealthCheckResponse
from src.core.config import settings

health_router = APIRouter()

@health_router.get(
    "/live",
    response_model=HealthCheckResponse,
    status_code=status.HTTP_200_OK,
    summary="Liveness Probe",
    description="Sprawdza czy aplikacja jest uruchomiona. Nie sprawdza zależności."
)
async def liveness_probe():
    """
    Szybki check dla Kubernetesa. Jeśli to nie działa, K8s restartuje poda.
    """
    return HealthCheckResponse(
        status="ok",
        version=settings.VERSION
    )


===============================
Ścieżka do pliku: ./src/api/v1/schemas/token.py

Zawartość pliku:

from pydantic import BaseModel
from typing import Optional

class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"


class TokenData(BaseModel):
    user_id: Optional[str] = None


class RefreshTokenRequest(BaseModel):
    refresh_token: str


===============================
Ścieżka do pliku: ./src/api/v1/schemas/user.py

Zawartość pliku:

from pydantic import BaseModel, EmailStr, field_validator, ConfigDict, Field
from typing import Optional
from uuid import UUID
from datetime import datetime
from src.db.models.user import AccountRole, AccountSubscription
import re  # <--- WAŻNE: Dodaj ten import

class UserBase(BaseModel):
    email: EmailStr
    username: str

    @field_validator("username")
    @classmethod
    def validate_username(cls, value: str) -> str:
        if not value or value.isspace():
            raise ValueError("The username cannot be empty or consist only of whitespace.")
        if value != value.strip():
            raise ValueError("The username cannot contain spaces at the beginning or end.")
        return value

class UserCreate(UserBase):
    # ZMIANA: Usuwamy 'min_length=6' stąd, żeby uniknąć błędu "String should have..."
    # Zostawiamy description dla dokumentacji
    password: str = Field(..., description="Password must be at least 6 characters long")

    @field_validator("password")
    @classmethod
    def validate_password_content(cls, value: str) -> str:
        # 1. ZMIANA: Dodajemy walidację długości TUTAJ, żeby mieć własny komunikat
        if len(value) < 6:
            raise ValueError("Password must be at least 6 characters long")

        # 2. Wymaganie: minimum jedna cyfra
        if not re.search(r"\d", value):
            raise ValueError("Password must contain at least one digit")
        
        # 3. Wymaganie: minimum jedna litera (duża lub mała)
        if not re.search(r"[a-zA-Z]", value):
            raise ValueError("Password must contain at least one letter")
            
        return value

class UserRegister(UserCreate):
    captcha_id: UUID
    captcha_answer: str
    
class UserPublic(UserBase):
    id: UUID
    account_role: AccountRole
    account_subscription: AccountSubscription
    subscription_expires_at: Optional[datetime] = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


===============================
Ścieżka do pliku: ./src/api/v1/schemas/health.py

Zawartość pliku:

from pydantic import BaseModel
from typing import Dict, Optional

class HealthCheckResponse(BaseModel):
    status: str
    version: str
    uptime: Optional[float] = None
    components: Optional[Dict[str, str]] = None

    class Config:
        json_schema_extra = {
            "example": {
                "status": "ok",
                "version": "1.0.0",
                "components": {
                    "database": "operational",
                    "redis": "down"
                }
            }
        }


===============================
Ścieżka do pliku: ./src/db/session.py

Zawartość pliku:

from typing import AsyncGenerator
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from src.core.config import settings

engine = create_async_engine(settings.DATABASE_URL, echo=True)
AsyncSessionLocal = sessionmaker(
    autocommit=False, autoflush=False, bind=engine, class_=AsyncSession
)

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    async with AsyncSessionLocal() as session:
        yield session


===============================
Ścieżka do pliku: ./src/db/models/refresh_token.py

Zawartość pliku:

# src/db/models/refresh_token.py
import uuid
from sqlalchemy import Column, String, DateTime, func, ForeignKey
from sqlalchemy.orm import relationship
from .user import Base

class RefreshToken(Base):
    __tablename__ = "refresh_tokens"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    user_id = Column(String, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    refresh_token = Column(String, unique=True, index=True, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    created_at = Column(DateTime, server_default=func.now(), nullable=False)

    user = relationship("User")


===============================
Ścieżka do pliku: ./src/db/models/user.py

Zawartość pliku:

import uuid
import enum
from sqlalchemy import Column, String, DateTime, func, Enum
from sqlalchemy.orm import declarative_base

Base = declarative_base()

class AccountSubscription(str, enum.Enum):
    FREE = "FREE"
    PRO = "PRO"

class AccountRole(str, enum.Enum):
    ADMIN = "ADMIN"
    MODERATOR = "MODERATOR"
    REGULAR = "REGULAR"

class User(Base):
    __tablename__ = "users"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    username = Column(String, unique=True, index=True, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    
    account_role = Column(Enum(AccountRole), default=AccountRole.REGULAR, nullable=False)

    account_subscription = Column(Enum(AccountSubscription), default=AccountSubscription.FREE, nullable=False)
    subscription_expires_at = Column(DateTime(timezone=True), nullable=True)

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)


===============================
Ścieżka do pliku: ./src/db/repository/refresh_token_repository.py

Zawartość pliku:

from typing import Optional
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload

from src.db.models.refresh_token import RefreshToken

class RefreshTokenRepository:
    def __init__(self, db_session: AsyncSession):
        self.db = db_session

    async def create(self, user_id: str, token: str, expires_at: datetime) -> RefreshToken:
        db_token = RefreshToken(
            user_id=user_id,
            refresh_token=token,
            expires_at=expires_at
        )
        self.db.add(db_token)
        await self.db.commit()
        await self.db.refresh(db_token)
        return db_token

    async def get_by_token(self, token: str) -> Optional[RefreshToken]:
        result = await self.db.execute(
            select(RefreshToken)
            .options(selectinload(RefreshToken.user)) # Opcjonalnie, aby załadować od razu dane usera
            .filter(RefreshToken.refresh_token == token)
        )
        return result.scalars().first()
    
    async def delete(self, token_id: str) -> None:
        db_token = await self.db.get(RefreshToken, token_id)
        if db_token:
            await self.db.delete(db_token)
            await self.db.commit()


===============================
Ścieżka do pliku: ./src/db/repository/user_repository.py

Zawartość pliku:

from typing import Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy import or_ 
from src.db.models.user import User
from src.api.v1.schemas.user import UserCreate
from src.core.security import get_password_hash

class UserRepository:
    def __init__(self, db_session: AsyncSession):
        self.db = db_session

    async def get_by_email(self, email: str) -> Optional[User]:
        result = await self.db.execute(select(User).filter(User.email == email))
        return result.scalars().first()
    
    async def get_by_username(self, username: str) -> Optional[User]:
        result = await self.db.execute(select(User).filter(User.username == username))
        return result.scalars().first()
    
    async def get_by_id(self, user_id: str) -> Optional[User]:
        result = await self.db.execute(select(User).filter(User.id == user_id))
        return result.scalars().first()
    
    async def get_by_email_or_username(self, identifier: str) -> Optional[User]:
        """
        Wyszukuje użytkownika sprawdzając czy podany identyfikator pasuje
        do adresu email LUB do nazwy użytkownika.
        """
        result = await self.db.execute(
            select(User).filter(
                or_(
                    User.email == identifier,
                    User.username == identifier
                )
            )
        )
        return result.scalars().first()
    
    async def create(self, user_data: UserCreate) -> User:
        hashed_password = get_password_hash(user_data.password)
        db_user = User(
            username=user_data.username,
            email=user_data.email,
            hashed_password=hashed_password,
            )
        self.db.add(db_user)
        await self.db.commit()
        await self.db.refresh(db_user)
        return db_user


