pytest.ini


[pytest]
asyncio_mode = auto
filterwarnings =
    ignore:.*crypt.*deprecated:DeprecationWarning


tests/test_main.py


import pytest
from src.db.models.user import User
from src.core.security import pwd_context
from sqlalchemy.future import select
from tests.conftest import TestingSessionLocal

@pytest.mark.asyncio
async def test_not_found(client):
    response = client.get("/invalid-endpoint")
    assert response.status_code == 404
    assert response.json() == {"detail": "Not Found"}

@pytest.mark.asyncio
async def test_get_root(client):
    response = client.get("/")
    assert response.status_code == 200
    assert response.headers["content-type"] == "application/json"
    assert response.json() == {"status": "ok"}

@pytest.fixture
def valid_register_data():
    return {
        "email": "user2@example.com",
        "username": "john2_doe",
        "password": "secure123"
    }

@pytest.mark.asyncio
async def test_post_register_user(client, valid_register_data):
    response = client.post("/api/v1/auth/register", json=valid_register_data)
    assert response.status_code == 201
    assert response.headers["content-type"] == "application/json"
    response_json = response.json()
    assert "id" in response_json
    assert response_json["username"] == valid_register_data["username"]
    assert response_json["email"] == valid_register_data["email"]


@pytest.mark.asyncio
@pytest.mark.parametrize("invalid_email", [
    "invalid-email",
    "user@",
    "@domain.com",
    "user@domain",
    "user.domain.com",
    "user@.com"
])
async def test_post_register_user_invalid_email(client, valid_register_data, invalid_email):
    invalid_data = valid_register_data.copy()
    invalid_data["email"] = invalid_email
    response = client.post("/api/v1/auth/register", json=invalid_data)
    assert response.status_code == 422

    response_json = response.json()
    assert "detail" in response_json
    assert response_json["detail"][0]["loc"] == ["body", "email"]

    errors = response_json["detail"]
    assert any(
        error["loc"] == ["body", "email"] and error["type"] == "value_error"
        for error in errors
    )
    assert any(
        error["loc"] == ["body", "email"] and "email address" in error["msg"].lower()
        for error in errors
    )


@pytest.mark.asyncio
@pytest.mark.parametrize("invalid_username, expected_error_msg", [
    ("", "Value error, The username cannot be empty or consist only of whitespace."),
    ("   ", "Value error, The username cannot be empty or consist only of whitespace."),
    ("  john", "Value error, The username cannot contain spaces at the beginning or end."),
    ("john  ", "Value error, The username cannot contain spaces at the beginning or end."),
])
async def test_post_register_user_invalid_username(client, valid_register_data, invalid_username, expected_error_msg):
    invalid_data = valid_register_data.copy()
    invalid_data["username"] = invalid_username
    response = client.post("/api/v1/auth/register", json=invalid_data)
    assert response.status_code == 422
    response_json = response.json()
    assert "detail" in response_json
    errors = response_json["detail"]
    assert any(
        error["loc"] == ["body", "username"] and error["msg"] == expected_error_msg
        for error in errors
    ), f"Expected error with loc=['body', 'username'] and msg='{expected_error_msg}', got {errors}"


async def test_post_register_user_saves_to_database(client, valid_register_data):
    response = client.post("/api/v1/auth/register", json=valid_register_data)
    assert response.status_code == 201
    response_json = response.json()
    assert response_json["username"] == valid_register_data["username"]
    assert response_json["email"] == valid_register_data["email"]
    assert "id" in response_json
    assert response_json["account_role"] == "REGULAR"
    assert response_json["account_subscription"] == "FREE"

    async with TestingSessionLocal() as session:
        result = await session.execute(
            select(User).filter(User.email == valid_register_data["email"])
        )
        db_user = result.scalars().first()

        assert db_user is not None
        assert db_user.username == valid_register_data["username"]
        assert db_user.email == valid_register_data["email"]
        assert db_user.account_role == "REGULAR"
        assert db_user.account_subscription == "FREE"
        assert db_user.created_at is not None
        assert pwd_context.verify(valid_register_data["password"], db_user.hashed_password)


@pytest.mark.asyncio
async def test_post_regitster_user_duplicate_username(client, valid_register_data):
    response = client.post("/api/v1/auth/register", json=valid_register_data)
    assert response.status_code == 201
    assert response.json()["username"] == valid_register_data["username"]

    duplicate_data = valid_register_data.copy()
    duplicate_data["email"] = "different@example.com"
    response = client.post("/api/v1/auth/register", json=duplicate_data)

    assert response.status_code == 409
    assert response.json() == {"detail":"Username already taken"}


@pytest.mark.asyncio
async def test_logout_user(client, valid_register_data):
    # 1. Zarejestruj i zaloguj użytkownika, aby uzyskać tokeny
    client.post("/api/v1/auth/register", json=valid_register_data)
    login_payload = {
        "username": valid_register_data["email"],
        "password": valid_register_data["password"]
    }
    login_response = client.post("/api/v1/auth/login", data=login_payload)
    assert login_response.status_code == 200
    tokens = login_response.json()
    access_token = tokens["access_token"]
    refresh_token = tokens["refresh_token"]

    # 2. Sprawdź, czy chroniony endpoint działa
    headers = {"Authorization": f"Bearer {access_token}"}
    protected_response = client.get("/api/v1/data/test-data", headers=headers)
    assert protected_response.status_code == 200

    # 3. Wyloguj użytkownika
    logout_response = client.post("/api/v1/auth/logout", json={"refresh_token": refresh_token})
    assert logout_response.status_code == 204

     # 4. Sprawdź, czy odświeżenie tokena teraz zawiedzie
    refresh_response = client.post("/api/v1/auth/refresh", json={"refresh_token": refresh_token})
    assert refresh_response.status_code == 401
    assert "Invalid or expired refresh token" in refresh_response.json()["detail"]
    





tests/conftest.py


# tests/conftest.py
import pytest
from fastapi.testclient import TestClient
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from src.main import app
from src.db.session import get_db
from src.db.models.user import Base

# Create an in-memory SQLite database for tests
TEST_DATABASE_URL = "sqlite+aiosqlite:///test.db"
test_engine = create_async_engine(TEST_DATABASE_URL, echo=True)
TestingSessionLocal = sessionmaker(
    autocommit=False, autoflush=False, bind=test_engine, class_=AsyncSession
)

# Override the get_db dependency to use the test database
async def override_get_db():
    async with TestingSessionLocal() as session:
        yield session

app.dependency_overrides[get_db] = override_get_db

# Create a test client fixture
@pytest.fixture
def client():
    return TestClient(app)

# Fixture to set up and tear down the database for each test
@pytest.fixture(autouse=True, scope="function")
async def setup_database():
    # Create tables before each test
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)  # Ensure clean state
        await conn.run_sync(Base.metadata.create_all)
    yield
    # Clean up after each test
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)


src/dependencies.py



from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.config import settings
from src.db.models.user import User as UserDb
from src.db.repository.user_repository import UserRepository
from src.db.session import get_db
from src.api.v1.schemas.token import TokenData

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")

async def get_current_user(
        db: AsyncSession = Depends(get_db), token: str = Depends(oauth2_scheme)
) -> UserDb:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id: str = payload.get("sub")
        token_type: str = payload.get("type")
        
        if user_id is None or token_type != "access":
            raise credentials_exception
        token_data = TokenData(user_id=user_id)
    except JWTError:
        raise credentials_exception
    
    repo = UserRepository(db)
    user = await repo.get_by_id(user_id=token_data.user_id)
    if user is None:
        raise credentials_exception
    return user
    

    


src/main.py


from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException
from fastapi.responses import Response
from src.api.v1.routers import auth
from src.api.v1.routers import test
from src.db.models.user import Base
from src.db.models.refresh_token import RefreshToken
from src.db.session import engine
import yaml

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup logic: Create database tables
    async with engine.begin() as conn:
        # await conn.run_sync(Base.metadata.drop_all)  # Uncomment to reset DB if needed
        await conn.run_sync(Base.metadata.create_all)
    yield
    # Shutdown logic (optional): Add cleanup tasks here if needed
    # Example: await engine.dispose() to close the database connection
    pass

app = FastAPI(
    title="My Users Service", 
    description="API for User Management and Authentication", 
    version="1.0.0",
    lifespan=lifespan
    )


app.include_router(auth.router)
app.include_router(test.router)


@app.get("/docs.yaml")
async def yaml_docs():
    try:
        openapi_schema = app.openapi()
        yaml_content = yaml.dump(openapi_schema, sort_keys=False)
        return Response(
            content=yaml_content,
            media_type="application/yaml",
            headers={"Content-Disposition": "attachment; filename=docs.yaml"}
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating YAML: {str(e)}")


@app.get("/", tags=['Health Check'])
async def root():
    return {"status": "ok"}


src/core/config.py


import os
from pydantic_settings import BaseSettings
from dotenv import load_dotenv

load_dotenv()

class Settings(BaseSettings):
    # JWT Settings
    SECRET_KEY: str = os.getenv("SECRET_KEY", "Z9X8v5y7_kJqP3mW2nL4rT6uY8iO0pQ2xR5tV7wU9")
    ALGORITHM: str = os.getenv("ALGORITHM", "HS256")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", 30))
    REFRESH_TOKEN_EXPIRE_DAYS: int = int(os.getenv("REFRESH_TOKEN_EXPIRE_DAYS", 7))

    # Database Settings
    DATABASE_URL: str = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./users.db")                                        

settings = Settings()


src/core/security.py


from datetime import datetime, timedelta
from typing import Optional

from jose import JWTError, jwt
from passlib.context import CryptContext

from .config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def verify_password(plain_password: str, hashed_password: str) ->bool:
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire, "type": "access"})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


def create_refresh_token(data: dict) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire, "type": "refresh"})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


src/api/v1/routers/auth.py


from fastapi import APIRouter, Depends, HTTPException, status, Response
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import datetime, timedelta
from uuid import uuid4

from src.db.session import get_db
from src.db.repository.user_repository import UserRepository
from src.core.security import verify_password, create_access_token, create_refresh_token
from src.api.v1.schemas import user as user_schema
from src.api.v1.schemas import token as token_schema

from src.db.repository.refresh_token_repository import RefreshTokenRepository
from src.core.config import settings
from jose import JWTError, jwt

router = APIRouter(prefix="/api/v1/auth", tags=["Authentication"])


@router.post("/register", response_model=user_schema.UserPublic, status_code=status.HTTP_201_CREATED)
async def register_user(user_in: user_schema.UserCreate,
                        db: AsyncSession = Depends(get_db)):
    # Check if user already exist
    repo = UserRepository(db)
    db_user = await repo.get_by_email(email=user_in.email)
    if db_user:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Email already registered")
    
    db_user = await repo.get_by_username(username=user_in.username)
    if db_user:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Username already taken")
    
    # Create user
    user = await repo.create(user_data=user_in)
    return user


@router.post("/login", response_model=token_schema.Token)
async def login_for_access_token(
    db: AsyncSession = Depends(get_db), 
    form_data: OAuth2PasswordRequestForm = Depends()):

    repo = UserRepository(db)
    user = await repo.get_by_email(email=form_data.username)
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token = create_access_token(data={"sub": str(user.id)})
    refresh_token = create_refresh_token(data={"sub": str(user.id)})

    # save RefreshToken
    refresh_token_repo = RefreshTokenRepository(db)
    expires_at = datetime.utcnow() + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    await refresh_token_repo.create(
        user_id=user.id,
        token=refresh_token,
        expires_at=expires_at
    )
    
    return {"access_token": access_token, "refresh_token": refresh_token, "token_type": "bearer"}


@router.post("/logout", status_code=status.HTTP_204_NO_CONTENT)
async def logout(
    token_request: token_schema.RefreshTokenRequest,
    db: AsyncSession = Depends(get_db)):

    refresh_token_repo = RefreshTokenRepository(db)

    # find token in database
    db_token = await refresh_token_repo.get_by_token(token=token_request.refresh_token)
    
    # if token exist, delete it
    if db_token:
        await refresh_token_repo.delete(token_id=db_token.id)

    return Response(status_code=status.HTTP_204_NO_CONTENT)


@router.post("/refresh", response_model=token_schema.Token)
async def refresh_access_token(
    token_request: token_schema.RefreshTokenRequest,
    db: AsyncSession = Depends(get_db)
):
    refresh_token_repo = RefreshTokenRepository(db)
    
    # 1. Znajdź token odświeżający w bazie danych
    db_refresh_token = await refresh_token_repo.get_by_token(token=token_request.refresh_token)

    # 2. Sprawdź, czy token istnieje i czy nie wygasł
    if not db_refresh_token or db_refresh_token.expires_at < datetime.utcnow():
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired refresh token",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 3. Jeśli token istnieje, ALE WYGASŁ, usuń go i odrzuć
    if db_refresh_token.expires_at < datetime.utcnow():
        await refresh_token_repo.delete(token_id=db_refresh_token.id) # <-- DODANA LINIA
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired refresh token", # Można zostawić ten sam komunikat
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 4. Zweryfikuj poprawność samego JWT (chociaż baza jest głównym źródłem prawdy)
    try:
        payload = jwt.decode(
            token_request.refresh_token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]
        )
        if payload.get("type") != "refresh":
             raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token type")
    except JWTError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Could not validate token")

    # 5. Stwórz nowy token dostępowy
    new_access_token = create_access_token(data={"sub": str(db_refresh_token.user_id)})
    
    # (Token Rotation): unieważnij stary i wydaj nowy refresh token
    await refresh_token_repo.delete(token_id=db_refresh_token.id)
    new_refresh_token = create_refresh_token(data={"sub": str(db_refresh_token.user_id)})
    expires_at = datetime.utcnow() + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    await refresh_token_repo.create(
        user_id=db_refresh_token.user_id,
        token=new_refresh_token,
        expires_at=expires_at
    )

    return {
        "access_token": new_access_token,
        "refresh_token": new_refresh_token,
        "token_type": "bearer"
    }


src/api/v1/routers/test.py


from fastapi import APIRouter, Depends
from typing import Dict
from src.db.models.user import User as UserDb
from src.dependencies import get_current_user

router = APIRouter(prefix="/api/v1/data", tags=["Data"])

@router.get("/test-data", response_model=Dict[str, str])
async def get_test_data(current_user: UserDb = Depends(get_current_user)):
    return {"message": "This is protected test data", "user_id": str(current_user.id)}



src/api/v1/schemas/token.py


from pydantic import BaseModel
from typing import Optional

class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"


class TokenData(BaseModel):
    user_id: Optional[str] = None


class RefreshTokenRequest(BaseModel):
    refresh_token: str


src/api/v1/schemas/user.py


from pydantic import BaseModel, EmailStr, field_validator, ConfigDict
from typing import Optional
from uuid import UUID
from datetime import datetime
from src.db.models.user import AccountRole, AccountSubscription

class UserBase(BaseModel):
    email: EmailStr
    username: str

    @field_validator("username")
    @classmethod
    def validate_username(cls, value: str) -> str:
        if not value or value.isspace():
            raise ValueError("The username cannot be empty or consist only of whitespace.")
        if value != value.strip():
            raise ValueError("The username cannot contain spaces at the beginning or end.")
        return value

class UserCreate(UserBase):
    password: str

class UserPublic(UserBase):
    id: UUID
    account_role: AccountRole
    account_subscription: AccountSubscription
    subscription_expires_at: Optional[datetime] = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


src/db/session.py


from typing import AsyncGenerator
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from src.core.config import settings

engine = create_async_engine(settings.DATABASE_URL, echo=True)
AsyncSessionLocal = sessionmaker(
    autocommit=False, autoflush=False, bind=engine, class_=AsyncSession
)

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    async with AsyncSessionLocal() as session:
        yield session


src/db/models/refresh_token.py


# src/db/models/refresh_token.py
import uuid
from sqlalchemy import Column, String, DateTime, func, ForeignKey
from sqlalchemy.orm import relationship
from .user import Base

class RefreshToken(Base):
    __tablename__ = "refresh_tokens"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    user_id = Column(String, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    refresh_token = Column(String, unique=True, index=True, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    created_at = Column(DateTime, server_default=func.now(), nullable=False)

    user = relationship("User")


src/db/models/user.py


import uuid
import enum
from sqlalchemy import Column, String, DateTime, func, Enum
from sqlalchemy.orm import declarative_base

Base = declarative_base()

class AccountSubscription(str, enum.Enum):
    FREE = "FREE"
    PRO = "PRO"

class AccountRole(str, enum.Enum):
    ADMIN = "ADMIN"
    MODERATOR = "MODERATOR"
    REGULAR = "REGULAR"

class User(Base):
    __tablename__ = "users"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    username = Column(String, unique=True, index=True, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    
    account_role = Column(Enum(AccountRole), default=AccountRole.REGULAR, nullable=False)

    account_subscription = Column(Enum(AccountSubscription), default=AccountSubscription.FREE, nullable=False)
    subscription_expires_at = Column(DateTime, nullable=True)

    created_at = Column(DateTime, server_default=func.now(), nullable=False)
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now(), nullable=False)


src/db/repository/refresh_token_repository.py


from typing import Optional
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload

from src.db.models.refresh_token import RefreshToken

class RefreshTokenRepository:
    def __init__(self, db_session: AsyncSession):
        self.db = db_session

    async def create(self, user_id: str, token: str, expires_at: datetime) -> RefreshToken:
        db_token = RefreshToken(
            user_id=user_id,
            refresh_token=token,
            expires_at=expires_at
        )
        self.db.add(db_token)
        await self.db.commit()
        await self.db.refresh(db_token)
        return db_token

    async def get_by_token(self, token: str) -> Optional[RefreshToken]:
        result = await self.db.execute(
            select(RefreshToken)
            .options(selectinload(RefreshToken.user)) # Opcjonalnie, aby załadować od razu dane usera
            .filter(RefreshToken.refresh_token == token)
        )
        return result.scalars().first()
    
    async def delete(self, token_id: str) -> None:
        db_token = await self.db.get(RefreshToken, token_id)
        if db_token:
            await self.db.delete(db_token)
            await self.db.commit()


src/db/repository/user_repository.py


from typing import Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from src.db.models.user import User
from src.api.v1.schemas.user import UserCreate
from src.core.security import get_password_hash

class UserRepository:
    def __init__(self, db_session: AsyncSession):
        self.db = db_session

    async def get_by_email(self, email: str) -> Optional[User]:
        result = await self.db.execute(select(User).filter(User.email == email))
        return result.scalars().first()
    
    async def get_by_username(self, username: str) -> Optional[User]:
        result = await self.db.execute(select(User).filter(User.username == username))
        return result.scalars().first()
    
    async def get_by_id(self, user_id: str) -> Optional[User]:
        result = await self.db.execute(select(User).filter(User.id == user_id))
        return result.scalars().first()
    
    async def create(self, user_data: UserCreate) -> User:
        hashed_password = get_password_hash(user_data.password)
        db_user = User(
            username=user_data.username,
            email=user_data.email,
            hashed_password=hashed_password,
            )
        self.db.add(db_user)
        await self.db.commit()
        await self.db.refresh(db_user)
        return db_user


