===============================
Ścieżka do pliku: ./lib/app.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:maia_flutter_client/features/auth/presentation/register_page.dart';
import 'core/navigation_provider.dart';
import 'core/widgets/main_drawer.dart';
import 'features/home/home_page.dart';
import 'features/home/home_app_bar.dart';
import 'features/dictionary/dictionary_page.dart';
import 'features/words/words_page.dart';
import 'features/sentences/sentences_page.dart';
import 'features/sentences/sentences_app_bar.dart';
import 'features/test/test_page.dart';
import 'features/test/test_app_bar.dart';
import 'core/app_sizes.dart'; // Import stałych
import 'features/health/services_health_page.dart';
import 'features/captcha/captcha_page.dart';

class MainShell extends ConsumerWidget {
  const MainShell({super.key});

  static const List<Widget> _pages = [
    HomePage(),
    DictionaryPage(),
    WordsPage(),
    SentencesPage(),
    RegisterPage(),
    TestPage(),
    ServicesHealthPage(),
    CaptchaPage(),
  ];

  static final List<PreferredSizeWidget> _appBars = [
    const HomeAppBar(),
    AppBar(title: const Text("Dictionary"), elevation: 2,),
    AppBar(title: const Text("Words"), elevation: 2,),
    const SentencesAppBar(),
    AppBar(title: const Text("Register page"), elevation: 2,),
    const TestAppBar(),
    AppBar(title: const Text("Health Check"), elevation: 2,),
    AppBar(title: const Text("Captcha Demo"), elevation: 2,),
  ];

  // static const List<String> _titles = [
  //   'Ogłoszenia parafialne',
  //   'Dictionary',
  //   'Words',
  //   'Sentences',
  //   'Test',
  //   'Health Check',
  // ];

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedIndex = ref.watch(navigationIndexProvider);

    return Container(
      //szare tło aplikacji
      // Zamieniamy surfaceVariant na surfaceContainerHighest
      color: const Color(0xFFE0E0E0),
      // color: Theme.of(
      //   context,
      // ).colorScheme.surfaceContainer,
      //color: const Color(0xFFE0E0E0),
      // color: Theme.of(
      //   context,
      // ).colorScheme.surfaceContainerHighest.withOpacity(0.5),
      child: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: AppSizes.maxMobileWidth),
          child: Container(
            // Ten kontener dodaje cień i ogranicza Scaffold
            decoration: BoxDecoration(
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.05),
                  blurRadius: 10,
                ),
              ],
            ),
            child: ClipRect(
              //ClipRect jest potrzebny bo inaczej boczny Drawer rysuje sie poza oknem aplikacji w widoku np na tablecie, dlatego trzeba przyciac Drawer do glownego słupka aplikacji
              child: Scaffold(
                //backgroundColor: Theme.of(context).colorScheme.surface,
                backgroundColor: const Color(0xFFFFFFFF),
                appBar: _appBars[selectedIndex],
                // appBar: AppBar(
                //   title: Text(_titles[selectedIndex]),
                //   elevation: 2,
                // ),
                drawer: const MainDrawer(),
                body: _pages[selectedIndex],
              ),
            ),
          ),
        ),
      ),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/main.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'app.dart';

void main() {
  // ProviderScope przechowuje stan wszystkich providerów
  runApp(const ProviderScope(child: MyApp()));
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'English Learning App',
      theme: ThemeData(
        //colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      home: const MainShell(),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/features/dictionary/dictionary_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import '../../core/widgets/main_drawer.dart';

class DictionaryPage extends StatelessWidget{
  const DictionaryPage({super.key});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/home/home_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import '../../core/widgets/main_drawer.dart';

class HomePage extends StatelessWidget {
  const HomePage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(child: Text('Strona Główna - Nauka Angielskiego')),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/home/home_app_bar.dart

Zawartość pliku:

import 'package:flutter/material.dart';

class HomeAppBar extends StatelessWidget implements PreferredSizeWidget {
  const HomeAppBar({super.key});

  @override
  Widget build(BuildContext context) {
    return AppBar(
      title: const Text("Ogłoszenia parafialne"),
      elevation: 2,
      // Nie musisz dodawać leading/hamburgera - Flutter doda go sam!
      actions: [
        IconButton(
          icon: const Icon(Icons.notifications),
          onPressed: () {},
        ),
      ],
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}


===============================
Ścieżka do pliku: ./lib/features/test/test_app_bar.dart

Zawartość pliku:

import 'package:flutter/material.dart';

class TestAppBar extends StatelessWidget implements PreferredSizeWidget {
  const TestAppBar({super.key});

  @override
  Widget build(BuildContext context) {
    return AppBar(
      title: const Text("Test Page"),
      elevation: 2,
      backgroundColor: Colors.deepPurple.shade50, // Możesz stylować każdy inaczej
      actions: [
        IconButton(icon: const Icon(Icons.refresh), onPressed: () {}),
        IconButton(icon: const Icon(Icons.more_vert), onPressed: () {}),
      ],
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}


===============================
Ścieżka do pliku: ./lib/features/test/test_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:maia_flutter_client/features/test/backend/backend_provider.dart';
import 'package:flutter_speed_dial/flutter_speed_dial.dart';
import '../../core/widgets/main_drawer.dart';

class TestPage extends ConsumerWidget {
  const TestPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final brickName = ref.watch(
      testBackendProvider.select((testBackend) => testBackend.brickName),
    );
    final bricksCount = ref.watch(
      testBackendProvider.select((testBackend) => testBackend.bricksCount),
    );
    final brickStatus = ref.watch(
      testBackendProvider.select((testBackend) => testBackend.brickStatus),
    );

    return Scaffold(
      body: Column(
        children: [
          Text('Sentences page: $brickName'),
          Text('Bricks count: $bricksCount'),
          Icon(
            brickStatus ? Icons.check_circle : Icons.error,
            color: brickStatus ? Colors.green : Colors.red,
            size: 24,
          ),
        ],
      ),
      floatingActionButton: SpeedDial(
        animatedIcon: AnimatedIcons.menu_close,

        renderOverlay: false,
        //overlayColor: Colors.black,
        //overlayOpacity: 0.3,

        closeManually: false,
        children: [
          SpeedDialChild(
            child: Icon(Icons.refresh),
            label: 'Odśwież',
            onTap: (){
              _showShackBar(context, 'Odświeżono');
            }
          ),
          SpeedDialChild(
            child: Icon(Icons.add),
            label: 'Dodaj zwrot',
          ),
        ],
      ),
    );
  }

  void _showShackBar(BuildContext context, String message){
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(message), duration: const Duration(milliseconds: 500),)
    );
  }
}



===============================
Ścieżka do pliku: ./lib/features/test/backend/backend_provider.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'test_backend.dart';

// 3. Zmień "Provider" na "ChangeNotifierProvider"
final testBackendProvider = ChangeNotifierProvider<TestBackend>((ref){
  return TestBackend();
});


===============================
Ścieżka do pliku: ./lib/features/test/backend/test_backend.dart

Zawartość pliku:

import 'dart:async';
import 'package:flutter/material.dart'; // Potrzebne do ChangeNotifier

// 1. Dodaj "with ChangeNotifier"
class TestBackend with ChangeNotifier {
  final String brickName = 'Brick M0001';
  bool brickStatus = false;
  int bricksCount = 0;
  Timer? _timer;
  Timer? _statusTimer;

  TestBackend(){
    _startTimer();
    _startStatusTimer();
  }

  void _startStatusTimer(){
    _statusTimer = Timer.periodic(const Duration(milliseconds: 1000), (timer) {
      brickStatus = !brickStatus;

      notifyListeners();
    });
  }

  void _startTimer() {
    _timer = Timer.periodic(const Duration(milliseconds: 100), (timer) {
      bricksCount++;
      
      // 2. TO JEST KLUCZ! To mówi do UI: "Hej, zmieniłem się, przerysujcie się!"
      notifyListeners(); 
    });
  }
}


===============================
Ścieżka do pliku: ./lib/features/auth/presentation/register_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../captcha/presentation/widgets/captcha_box.dart';
import '../../captcha/presentation/captcha_controller.dart';
import 'auth_controller.dart';

class RegisterPage extends ConsumerStatefulWidget {
  const RegisterPage({super.key});

  @override
  ConsumerState<RegisterPage> createState() => _RegisterPageState();
}

class _RegisterPageState extends ConsumerState<RegisterPage> {
  final _formKey = GlobalKey<FormState>();
  final _emailCtrl = TextEditingController();
  final _userCtrl = TextEditingController();
  final _passCtrl = TextEditingController();
  // Kontroler do captchy przekazujemy do Twojego widgetu
  final _captchaInputCtrl = TextEditingController();

  @override
  void dispose() {
    _emailCtrl.dispose();
    _userCtrl.dispose();
    _passCtrl.dispose();
    _captchaInputCtrl.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;

    // 1. Pobieramy ID captchy z Twojego istniejącego kontrolera captchy
    final captchaState = ref.read(captchaControllerProvider);
    if (captchaState.captcha == null) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Błąd Captchy')));
      return;
    }

    // 2. Wywołujemy rejestrację
    final success = await ref.read(authControllerProvider.notifier).register(
      email: _emailCtrl.text,
      username: _userCtrl.text,
      password: _passCtrl.text,
      captchaId: captchaState.captcha!.id, // UUID z serwera
      captchaAnswer: _captchaInputCtrl.text, // Tekst wpisany przez usera
    );

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Konto założone! Zaloguj się.')));
      Navigator.pop(context); // Wróć do logowania
    }
  }

  @override
  Widget build(BuildContext context) {
    final authState = ref.watch(authControllerProvider);
    
    return Scaffold(
      appBar: AppBar(title: const Text("Rejestracja")),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24),
        child: Form(
          key: _formKey,
          child: Column(
            children: [
              TextFormField(
                controller: _emailCtrl,
                decoration: const InputDecoration(labelText: "Email"),
                validator: (v) => v!.contains('@') ? null : 'Błędny email',
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _userCtrl,
                decoration: const InputDecoration(labelText: "Username"),
                validator: (v) => v!.length < 3 ? 'Za krótkie' : null,
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _passCtrl,
                decoration: const InputDecoration(labelText: "Hasło"),
                obscureText: true,
                validator: (v) => v!.length < 6 ? 'Za krótkie hasło' : null,
              ),
              const SizedBox(height: 24),
              
              // --- TWOJA CAPTCHA ---
              // Reużywamy Twój widget! To jest siła modułowości.
              CaptchaBox(
                answerController: _captchaInputCtrl,
              ),
              // ---------------------

              const SizedBox(height: 24),
              if (authState.error != null)
                 Text(authState.error!, style: const TextStyle(color: Colors.red)),

              SizedBox(width: double.infinity, child: FilledButton(
                onPressed: authState.isLoading ? null : _submit,
                child: authState.isLoading ? const CircularProgressIndicator() : const Text("ZAREJESTRUJ SIĘ"),
              )),
            ],
          ),
        ),
      ),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/auth/presentation/auth_controller.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:maia_flutter_client/core/network/api_error_handler.dart';
import '../data/auth_repository.dart';
import '../data/token_storage.dart';
import '../data/models/auth_token.dart';

// Stan autentykacji
class AuthState {
  final bool isAuthenticated;
  final bool isLoading;
  final String? error;

  const AuthState({
    this.isAuthenticated = false, 
    this.isLoading = true, // Domyślnie true, bo przy starcie sprawdzamy storage
    this.error
  });
  
  AuthState copyWith({bool? isAuthenticated, bool? isLoading, String? error}) {
    return AuthState(
      isAuthenticated: isAuthenticated ?? this.isAuthenticated,
      isLoading: isLoading ?? this.isLoading,
      error: error,
    );
  }
}

class AuthController extends StateNotifier<AuthState> {
  final AuthRepository _repository;
  final TokenStorage _storage;

  AuthController(this._repository, this._storage) : super(const AuthState()) {
    checkAuthStatus();
  }

  // Sprawdza przy starcie apki, czy mamy token
  Future<void> checkAuthStatus() async {
    final token = await _storage.getToken();
    if (token != null) {
      // Opcjonalnie: Tutaj można strzelić do /api/v1/users/me żeby sprawdzić czy token jest nadal ważny
      state = const AuthState(isAuthenticated: true, isLoading: false);
    } else {
      state = const AuthState(isAuthenticated: false, isLoading: false);
    }
  }

  Future<bool> login(String username, String password) async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      final token = await _repository.login(username: username, password: password);
      await _storage.saveToken(token);
      state = const AuthState(isAuthenticated: true, isLoading: false);
      return true;
    } catch (e) {
      state = state.copyWith(isLoading: false, error: "Błąd logowania. Sprawdź dane.");
      return false;
    }
  }

  Future<bool> register({
    required String email,
    required String username,
    required String password,
    required String captchaId,
    required String captchaAnswer,
  }) async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      await _repository.register(
        email: email,
        username: username,
        password: password,
        captchaId: captchaId,
        captchaAnswer: captchaAnswer,
      );
      state = state.copyWith(isLoading: false);
      return true; // Sukces rejestracji
    } catch (e) {
      state = state.copyWith(isLoading: false, error: "Błąd rejestracji. ${ApiErrorHandler.getErrorMessage(e)}");
      return false;
    }
  }

  Future<void> logout() async {
    final token = await _storage.getToken();
    if (token != null) {
       try {
         await _repository.logout(token.refreshToken);
       } catch (_) {
         // Ignorujemy błędy sieciowe przy wylogowaniu
       }
    }
    await _storage.clearToken();
    state = const AuthState(isAuthenticated: false, isLoading: false);
  }
}

// Globalny provider stanu autentykacji
final authControllerProvider = StateNotifierProvider<AuthController, AuthState>((ref) {
  return AuthController(
    ref.watch(authRepositoryProvider),
    ref.watch(tokenStorageProvider),
  );
});


===============================
Ścieżka do pliku: ./lib/features/auth/data/auth_repository.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/network/dio_provider.dart';
import 'models/auth_token.dart';

final authRepositoryProvider = Provider((ref) {
  final dio = ref.watch(dioProvider); // Używamy Twojego głównego Dio
  return AuthRepository(dio);
});

class AuthRepository {
  final Dio _dio;

  AuthRepository(this._dio);

  // Logowanie: x-www-form-urlencoded
  Future<AuthToken> login({required String username, required String password}) async {
    try {
      final response = await _dio.post(
        '/api/v1/auth/login',
        data: {
          'username': username,
          'password': password,
          'grant_type': 'password', // Wymagane przez OAuth2PasswordBearer
        },
        options: Options(
          contentType: Headers.formUrlEncodedContentType, // WAŻNE!
        ),
      );
      return AuthToken.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }

  // Rejestracja: application/json
  Future<void> register({
    required String email,
    required String username,
    required String password,
    required String captchaId,
    required String captchaAnswer,
  }) async {
    try {
      await _dio.post(
        '/api/v1/auth/register',
        data: {
          'email': email,
          'username': username,
          'password': password,
          'captcha_id': captchaId,
          'captcha_answer': captchaAnswer,
        },
      );
    } catch (e) {
      rethrow;
    }
  }

  // Wylogowanie
  Future<void> logout(String refreshToken) async {
      // API wymaga wysłania refresh tokena przy wylogowaniu
      await _dio.post('/api/v1/auth/logout', data: {'refresh_token': refreshToken});
  }
}


===============================
Ścieżka do pliku: ./lib/features/auth/data/token_storage.dart

Zawartość pliku:

import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'models/auth_token.dart';

final tokenStorageProvider = Provider((ref) => TokenStorage());

class TokenStorage {
  // POPRAWKA: Usuwamy parametr encryptedSharedPreferences.
  // Dodajemy resetOnError: true -> to "Best Practice" w developmentzie.
  // Jeśli klucze szyfrowania ulegną uszkodzeniu (np. przy reinstalacji apki w devie),
  // magazyn zostanie zresetowany zamiast crashować aplikację.
  final _storage = const FlutterSecureStorage(
    aOptions: AndroidOptions(
      resetOnError: true, 
    ),
  );

  static const _keyAccess = 'access_token';
  static const _keyRefresh = 'refresh_token';

  Future<void> saveToken(AuthToken token) async {
    await _storage.write(key: _keyAccess, value: token.accessToken);
    await _storage.write(key: _keyRefresh, value: token.refreshToken);
  }

  Future<AuthToken?> getToken() async {
    // Odczyt może rzucić wyjątek jeśli klucze systemowe się zmienią, 
    // dlatego warto otoczyć to try-catch w produkcyjnym kodzie, 
    // ale resetOnError w opcjach wyżej załatwia większość problemów.
    final access = await _storage.read(key: _keyAccess);
    final refresh = await _storage.read(key: _keyRefresh);
    
    if (access != null && refresh != null) {
      return AuthToken(accessToken: access, refreshToken: refresh);
    }
    return null;
  }

  Future<void> clearToken() async {
    await _storage.delete(key: _keyAccess);
    await _storage.delete(key: _keyRefresh);
  }
}


===============================
Ścieżka do pliku: ./lib/features/auth/data/models/auth_token.dart

Zawartość pliku:

class AuthToken {
  final String accessToken;
  final String refreshToken;

  AuthToken({required this.accessToken, required this.refreshToken});

  factory AuthToken.fromJson(Map<String, dynamic> json) {
    return AuthToken(
      accessToken: json['access_token'] as String,
      refreshToken: json['refresh_token'] as String,
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/auth/data/models/user_model.dart

Zawartość pliku:

class User {
  final String id;
  final String username;
  final String email;
  final String role;

  User({required this.id, required this.username, required this.email, required this.role});

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'],
      username: json['username'],
      email: json['email'],
      role: json['account_role'],
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/captcha/captcha_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/widgets/main_drawer.dart';
import 'presentation/captcha_controller.dart';
import 'presentation/widgets/captcha_box.dart';

class CaptchaPage extends ConsumerStatefulWidget {
  const CaptchaPage({super.key});

  @override
  ConsumerState<CaptchaPage> createState() => _CaptchaPageState();
}

class _CaptchaPageState extends ConsumerState<CaptchaPage> {
  final _captchaInputController = TextEditingController();

  @override
  void dispose() {
    _captchaInputController.dispose();
    super.dispose();
  }

  Future<void> _verify() async {
    // Ukrywamy klawiaturę
    FocusScope.of(context).unfocus();
    
    final answer = _captchaInputController.text;
    if (answer.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Wpisz kod!")),
      );
      return;
    }

    final success = await ref
        .read(captchaControllerProvider.notifier)
        .verifyCaptcha(answer);

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text("Captcha zweryfikowana pomyślnie!"),
          backgroundColor: Colors.green,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    // Obserwujemy stan, aby wiedzieć np. czy trwa ładowanie
    final captchaState = ref.watch(captchaControllerProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text("Captcha Test"),
        elevation: 2,
      ),
      drawer: const MainDrawer(), // Dodajemy boczny pasek
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              "Demonstracja modułu Captcha",
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            const Text(
              "Poniższy komponent jest niezależny i gotowy do użycia na ekranach logowania/rejestracji.",
              style: TextStyle(color: Colors.grey),
            ),
            const SizedBox(height: 32),

            // --- REUŻYWALNY WIDGET CAPTCHA ---
            CaptchaBox(
              answerController: _captchaInputController,
              onRefresh: () {
                // Opcjonalny callback, np. logowanie zdarzenia
                debugPrint("Użytkownik odświeżył captchę");
              },
            ),
            // ---------------------------------

            const SizedBox(height: 24),

            // Przycisk "Verify" - specyficzny dla tej strony testowej
            SizedBox(
              width: double.infinity,
              child: FilledButton.icon(
                onPressed: captchaState.isLoading ? null : _verify,
                icon: const Icon(Icons.check_circle_outline),
                label: captchaState.isLoading
                    ? const SizedBox(
                        width: 20, 
                        height: 20, 
                        child: CircularProgressIndicator(color: Colors.white, strokeWidth: 2)
                      )
                    : const Text("ZWERYFIKUJ CAPTCHĘ"),
                style: FilledButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/captcha/presentation/captcha_controller.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/captcha_repository.dart';
import '../data/models/captcha_model.dart';
import '../../../../core/network/api_error_handler.dart';

// Stan dla naszego kontrolera
class CaptchaState {
  final CaptchaModel? captcha; // Obecny obrazek i ID
  final bool isLoading;
  final String? errorMessage;
  final bool? isVerified; // null = nie sprawdzano, true = ok, false = źle

  const CaptchaState({
    this.captcha,
    this.isLoading = false,
    this.errorMessage,
    this.isVerified,
  });

  CaptchaState copyWith({
    CaptchaModel? captcha,
    bool? isLoading,
    String? errorMessage,
    bool? isVerified,
  }) {
    return CaptchaState(
      captcha: captcha ?? this.captcha,
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage, // Jeśli null to czyścimy błąd
      isVerified: isVerified ?? this.isVerified,
    );
  }
}

class CaptchaController extends StateNotifier<CaptchaState> {
  final CaptchaRepository _repository;

  CaptchaController(this._repository) : super(const CaptchaState()) {
    // Automatycznie pobierz captchę przy starcie
    fetchCaptcha();
  }

  Future<void> fetchCaptcha() async {
    state = state.copyWith(isLoading: true, errorMessage: null, isVerified: null);
    try {
      final captcha = await _repository.generateCaptcha();
      state = state.copyWith(
        isLoading: false,
        captcha: captcha,
        errorMessage: null,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: ApiErrorHandler.getErrorMessage(e),
      );
    }
  }

  Future<bool> verifyCaptcha(String answer) async {
    if (state.captcha == null) return false;

    state = state.copyWith(isLoading: true, errorMessage: null);

    try {
      final isValid = await _repository.verifyCaptcha(
        CaptchaVerifyRequest(id: state.captcha!.id, answer: answer),
      );

      state = state.copyWith(
        isLoading: false,
        isVerified: isValid,
      );
      
      // Jeśli walidacja nie przeszła, można automatycznie odświeżyć captchę, 
      // bo zazwyczaj token jest jednorazowy.
      if (!isValid) {
         // Opcjonalnie: await fetchCaptcha(); 
         // Wiele systemów wymaga nowej captchy po błędnej próbie.
      }
      
      return isValid;
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: ApiErrorHandler.getErrorMessage(e),
        isVerified: false,
      );
      return false;
    }
  }
  
  // Metoda pomocnicza do resetowania stanu weryfikacji (np. gdy użytkownik zaczyna pisać)
  void resetVerificationStatus() {
    if (state.isVerified != null) {
      state = state.copyWith(isVerified: null);
    }
  }
}

// Używamy .autoDispose, aby stan się czyścił po wyjściu z ekranu
final captchaControllerProvider = 
    StateNotifierProvider.autoDispose<CaptchaController, CaptchaState>((ref) {
  final repo = ref.watch(captchaRepositoryProvider);
  return CaptchaController(repo);
});


===============================
Ścieżka do pliku: ./lib/features/captcha/presentation/widgets/captcha_box.dart

Zawartość pliku:

import 'dart:convert'; // Do base64Decode
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../captcha_controller.dart';

class CaptchaBox extends ConsumerStatefulWidget {
  final TextEditingController answerController;
  final VoidCallback? onRefresh;

  const CaptchaBox({
    super.key, 
    required this.answerController,
    this.onRefresh,
  });

  @override
  ConsumerState<CaptchaBox> createState() => _CaptchaBoxState();
}

class _CaptchaBoxState extends ConsumerState<CaptchaBox> {
  
  @override
  void initState() {
    super.initState();
    widget.answerController.addListener(() {
      ref.read(captchaControllerProvider.notifier).resetVerificationStatus();
    });
  }

  // --- NOWA METODA POMOCNICZA ---
  // Usuwa nagłówek "data:image/png;base64," jeśli istnieje
  String _cleanBase64(String base64String) {
    if (base64String.contains(',')) {
      return base64String.split(',').last;
    }
    return base64String;
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(captchaControllerProvider);
    final controller = ref.read(captchaControllerProvider.notifier);

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // 1. Obrazek Captcha
            Container(
              height: 80,
              decoration: BoxDecoration(
                color: Colors.grey.shade200,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.grey.shade300),
              ),
              child: state.isLoading && state.captcha == null
                  ? const Center(child: CircularProgressIndicator())
                  : state.captcha != null
                      ? ClipRRect(
                          borderRadius: BorderRadius.circular(8),
                          child: Image.memory(
                            // --- TUTAJ POPRAWKA ---
                            // Używamy metody pomocniczej _cleanBase64
                            base64Decode(_cleanBase64(state.captcha!.image)), 
                            fit: BoxFit.contain, // Zmienione na contain, żeby nie ucinało tekstu captchy
                            errorBuilder: (context, error, stackTrace) {
                              debugPrint('Błąd wyświetlania obrazka: $error');
                              return const Center(child: Icon(Icons.broken_image));
                            },
                          ),
                        )
                      : const Center(child: Text("Brak Captchy")),
            ),

            const SizedBox(height: 12),

            // 2. Wiersz: Pole tekstowe + Przycisk odświeżania
            Row(
              children: [
                Expanded(
                  child: TextFormField(
                    controller: widget.answerController,
                    decoration: InputDecoration(
                      labelText: 'Wpisz kod z obrazka',
                      border: const OutlineInputBorder(),
                      contentPadding: const EdgeInsets.symmetric(horizontal: 12),
                      enabledBorder: state.isVerified == false
                          ? const OutlineInputBorder(borderSide: BorderSide(color: Colors.red))
                          : null,
                      focusedBorder: state.isVerified == false
                          ? const OutlineInputBorder(borderSide: BorderSide(color: Colors.red, width: 2))
                          : null,
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                IconButton.filledTonal(
                  onPressed: state.isLoading 
                    ? null 
                    : () {
                        controller.fetchCaptcha();
                        widget.answerController.clear();
                        if(widget.onRefresh != null) widget.onRefresh!();
                      },
                  icon: state.isLoading
                      ? const SizedBox(
                          width: 20, 
                          height: 20, 
                          child: CircularProgressIndicator(strokeWidth: 2)
                        )
                      : const Icon(Icons.refresh),
                  tooltip: "Nowy kod",
                ),
              ],
            ),
            
            // 3. Informacja o błędzie
            if (state.errorMessage != null)
              Padding(
                padding: const EdgeInsets.only(top: 8.0),
                child: Text(
                  state.errorMessage!,
                  style: const TextStyle(color: Colors.red, fontSize: 12),
                ),
              ),
              
            if (state.isVerified == false)
              const Padding(
                padding: EdgeInsets.only(top: 8.0),
                child: Text(
                  "Niepoprawny kod. Spróbuj ponownie.",
                  style: TextStyle(color: Colors.red, fontSize: 12, fontWeight: FontWeight.bold),
                ),
              ),
              
             if (state.isVerified == true)
              const Padding(
                padding: EdgeInsets.only(top: 8.0),
                child: Text(
                  "Kod poprawny!",
                  style: TextStyle(color: Colors.green, fontSize: 12, fontWeight: FontWeight.bold),
                ),
              ),
          ],
        ),
      ),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/captcha/data/captcha_dio_provider.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Provider dedykowany dla mikroserwisu Captcha (port 8001)
final captchaDioProvider = Provider<Dio>((ref) {
  final dio = Dio(BaseOptions(
    // Dostosuj adres IP do swojego środowiska (podobnie jak w dio_provider.dart)
    // Jeśli używasz emulatora: http://10.0.2.2:8001
    // Jeśli fizyczne urządzenie/web: Twój adres LAN lub domena
    //baseUrl: 'http://127.0.0.1:8001', 
    baseUrl: 'https://dev-captcha.rafal-kruszyna.org',
    connectTimeout: const Duration(seconds: 5),
    receiveTimeout: const Duration(seconds: 5),
  ));
  return dio;
});


===============================
Ścieżka do pliku: ./lib/features/captcha/data/captcha_repository.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import './captcha_dio_provider.dart';
import 'models/captcha_model.dart';

// Provider repozytorium
final captchaRepositoryProvider = Provider<CaptchaRepository>((ref) {
  final dio = ref.watch(captchaDioProvider);
  return CaptchaRepository(dio);
});

class CaptchaRepository {
  final Dio _dio;

  CaptchaRepository(this._dio);

  Future<CaptchaModel> generateCaptcha() async {
    try {
      final response = await _dio.get('/api/v1/captcha');
      return CaptchaModel.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }

  Future<bool> verifyCaptcha(CaptchaVerifyRequest request) async {
    try {
      final response = await _dio.post(
        '/api/v1/captcha/verify',
        data: request.toJson(),
      );
      final result = CaptchaVerifyResponse.fromJson(response.data);
      return result.isValid;
    } catch (e) {
      // Jeśli serwer zwróci 422 (błąd walidacji), to technicznie nie jest poprawna captcha
      // Możesz tu obsłużyć to inaczej, ale na razie uznajmy to za false lub rzućmy błąd.
      rethrow; 
    }
  }
}


===============================
Ścieżka do pliku: ./lib/features/captcha/data/models/captcha_model.dart

Zawartość pliku:

class CaptchaModel {
  final String id; // UUID
  final String image; // Base64 string

  CaptchaModel({required this.id, required this.image});

  factory CaptchaModel.fromJson(Map<String, dynamic> json) {
    return CaptchaModel(
      id: json['id'] as String,
      image: json['image'] as String,
    );
  }
}

class CaptchaVerifyRequest {
  final String id;
  final String answer;

  CaptchaVerifyRequest({required this.id, required this.answer});

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'answer': answer,
    };
  }
}

class CaptchaVerifyResponse {
  final bool isValid;

  CaptchaVerifyResponse({required this.isValid});

  factory CaptchaVerifyResponse.fromJson(Map<String, dynamic> json) {
    return CaptchaVerifyResponse(
      isValid: json['is_valid'] as bool,
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/health/services_health_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'widgets/server_monitor_tile.dart';
import '../../core/widgets/main_drawer.dart';

class ServicesHealthPage extends StatelessWidget {
  const ServicesHealthPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      //backgroundColor: const Color(0xFFFFFFFF),

      body: SingleChildScrollView(
        // Odpowiednik ScrollablePage
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // --- DEV SERVERS ---
            _buildSectionHeader("Dev servers"),
            const ServerMonitorTile(
              serviceName: "captcha-microservice",
              //serverUrl: "http://127.0.0.1:8001",
              serverUrl: "https://dev-captcha.rafal-kruszyna.org",
            ),
            const ServerMonitorTile(
              serviceName: "users-microservice",
              serverUrl: "http://127.0.0.1:8002",
            ),
            const ServerMonitorTile(
              serviceName: "sentences-microservice",
              //serverUrl: "http://10.139.19.47:8003",
              serverUrl: "https://dev-sentences.rafal-kruszyna.org",
            ),

            const SizedBox(height: 24),

            // --- PRODUCTION ---
            _buildSectionHeader("Production"),
            const ServerMonitorTile(
              serviceName: "captcha-microservice",
              serverUrl:
                  "https://maia-captcha.rafal-kruszyna.org", // port 443 jest domyślny dla https
            ),
            const ServerMonitorTile(
              serviceName: "users-microservice",
              serverUrl: "https://maia-users.rafal-kruszyna.org",
            ),
            const ServerMonitorTile(
              serviceName: "sentences-microservice",
              serverUrl: "https://maia-sentences.rafal-kruszyna.org",
            ),

            const SizedBox(height: 24),

            // --- PRODUCTION LOCAL ---
            _buildSectionHeader("Production local"),
            const ServerMonitorTile(
              serviceName: "captcha-microservice",
              serverUrl: "http://192.168.0.102:8001",
            ),
            const ServerMonitorTile(
              serviceName: "users-microservice",
              serverUrl: "http://192.168.0.102:8002",
            ),
            const ServerMonitorTile(
              serviceName: "sentences-microservice",
              serverUrl: "http://192.168.0.102:8003",
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: const TextStyle(
          fontSize: 18, // pointSize 15 w QML to mniej więcej 18-20 w Flutter
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/features/health/server_health_provider.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import './services/health_check_service.dart';

final healthCheckServiceProvider = Provider((ref) => HealthCheckService());

// StreamProvider automatycznie obsługuje stan Loading/Error/Data
// .family pozwala przekazać URL
final serverHealthProvider = StreamProvider.autoDispose.family<bool, String>((ref, url) async* {
  final service = ref.watch(healthCheckServiceProvider);

  // 1. Sprawdź natychmiast przy starcie
  yield await service.checkHost(url);

  // 2. Uruchom pętlę (Timer) - co 5 sekund (jak w C++ interval)
  // Stream.periodic działa jak QTimer
  final stream = Stream.periodic(const Duration(seconds: 5), (_) {
    return service.checkHost(url);
  });

  // 3. Emituj wyniki z pętli
  await for (final isAlive in stream) {
    yield await isAlive; // await tutaj, bo checkHost zwraca Future
  }
});


===============================
Ścieżka do pliku: ./lib/features/health/services/health_check_service.dart

Zawartość pliku:

import 'package:dio/dio.dart';

class HealthCheckService {
  final Dio _dio;

  HealthCheckService()
      : _dio = Dio(BaseOptions(
          connectTimeout: const Duration(seconds: 3),
          receiveTimeout: const Duration(seconds: 3),
          contentType: 'application/json',
          validateStatus: (status) => status == 200, // Tylko 200 nas interesuje
        ));

  /// Sprawdza konkretny endpoint wymagany przez C++ logic
  Future<bool> checkHost(String baseUrl) async {
    // Usuń slash na końcu jeśli jest
    final cleanUrl = baseUrl.endsWith('/')
        ? baseUrl.substring(0, baseUrl.length - 1)
        : baseUrl;
    
    // Konkretny endpoint z Twojego kodu C++
    final targetUrl = '$cleanUrl/health/live';

    try {
      // Cache breaker, żeby nie pobierać starego wyniku
      final response = await _dio.get(
        targetUrl, 
        queryParameters: {'t': DateTime.now().millisecondsSinceEpoch},
      );

      if (response.statusCode == 200 && response.data is Map) {
        // Sprawdzenie logiki biznesowej: {"status": "ok"}
        return response.data['status'] == 'ok';
      }
      return false;
    } catch (e) {
      return false;
    }
  }
}


===============================
Ścieżka do pliku: ./lib/features/health/widgets/server_monitor_tile.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../server_health_provider.dart';

class ServerMonitorTile extends ConsumerWidget {
  final String serverUrl;
  final String serviceName;

  const ServerMonitorTile({
    super.key,
    required this.serverUrl,
    required this.serviceName,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Obserwujemy StreamProvidera
    final AsyncValue<bool> healthState = ref.watch(serverHealthProvider(serverUrl));

    return Card(
      margin: const EdgeInsets.symmetric(vertical: 4),
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Row(
          children: [
            // Ikona statusu z obsługą ładowania
            _buildStatusIndicator(healthState),
            
            const SizedBox(width: 16),
            
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    serviceName,
                    style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
                  ),
                  Text(
                    serverUrl,
                    style: TextStyle(color: Colors.grey[600], fontSize: 12),
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatusIndicator(AsyncValue<bool> state) {
    return state.when(
      // Gdy mamy dane (true/false)
      data: (isAlive) {
        return Container(
          width: 24,
          height: 24,
          decoration: BoxDecoration(
            color: isAlive ? Colors.green : Colors.red,
            shape: BoxShape.circle,
          ),
          child: Icon(
            isAlive ? Icons.check : Icons.close,
            color: Colors.white,
            size: 16,
          ),
        );
      },
      // Gdy się ładuje (pierwsze zapytanie)
      loading: () => const SizedBox(
        width: 24,
        height: 24,
        child: CircularProgressIndicator(strokeWidth: 2),
      ),
      // Gdy wystąpi błąd w samym Streamie (rzadkie przy try-catch w serwisie)
      error: (_, __) => const Icon(Icons.error_outline, color: Colors.grey),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/sentences/sentences_app_bar.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import './presentation/sentences_provider.dart';

class SentencesAppBar extends ConsumerWidget implements PreferredSizeWidget {
  const SentencesAppBar({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Obserwujemy stan, aby np. pokazać inny spinner na przycisku odświeżania,
    // jeśli trwa ładowanie (opcjonalny bajer, tutaj prosta wersja).
    final state = ref.watch(sentencesProvider);
    final sentencesNotifier = ref.read(sentencesProvider.notifier);

    return AppBar(
      title: const Text("Sentences"),
      elevation: 2,
      actions: [
        // Przycisk Odśwież
        IconButton(
          icon: state.isLoading 
              ? const SizedBox(
                  width: 20, 
                  height: 20, 
                  child: CircularProgressIndicator(strokeWidth: 2, color: Colors.black54,)
                )
              : const Icon(Icons.refresh),
          tooltip: "Odśwież listę",
          onPressed: state.isLoading 
              ? null // Zablokuj, jeśli już ładuje
              : () {
                  // Tu wywołujemy logikę "Backendu"
                  sentencesNotifier.refreshCurrentPage();
                },
        ),
        // Opcjonalnie inne przyciski, np. sortowanie
        // IconButton(icon: Icon(Icons.filter_list), onPressed: () {}),
      ],
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}


===============================
Ścieżka do pliku: ./lib/features/sentences/sentences_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'presentation/sentences_provider.dart';
import 'presentation/add_sentence_dialog.dart';
import 'presentation/widgets/sentence_tile.dart';
import '../../core/widgets/main_drawer.dart';

class SentencesPage extends ConsumerWidget {
  const SentencesPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final sentencesState = ref.watch(sentencesProvider);
    final notifier = ref.read(sentencesProvider.notifier);

    return Scaffold(
      //backgroundColor: Colors.transparent,
      //backgroundColor: Colors.red,
      backgroundColor: const Color(0xFFFFFFFF),

      floatingActionButton: FloatingActionButton(
        onPressed: () {
          showDialog(
            context: context,
            builder: (context) => const AddSentenceDialog(),
          );
        },
        child: const Icon(Icons.add),
      ),

      bottomNavigationBar: SafeArea(
        child: Container(
          padding: const EdgeInsets.all(8),
          decoration: BoxDecoration(
            color: Theme.of(
              context,
            ).colorScheme.surfaceContainerHighest.withOpacity(0.3),
            border: Border(
              top: BorderSide(color: Colors.grey.withOpacity(0.2)),
            ),
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              ElevatedButton.icon(
                onPressed:
                    sentencesState.currentPage > 1 && !sentencesState.isLoading
                    ? () => notifier.previousPage()
                    : null,
                icon: const Icon(Icons.arrow_back),
                label: const Text("Poprzednia"),
              ),

              Text(
                "Strona ${sentencesState.currentPage}",
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),

              ElevatedButton.icon(
                onPressed:
                    !sentencesState.isLastPage && !sentencesState.isLoading
                    ? () => notifier.nextPage()
                    : null,
                label: const Text("Następna"),
                icon: const Icon(Icons.arrow_forward),
              ),
            ],
          ),
        ),
      ),

      body: Column(
        children: [
          if (sentencesState.errorMessage != null)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              color: Colors.red.shade100,
              width: double.infinity,
              child: Row(
                children: [
                  Expanded(
                    child: Text(
                      'Błąd: ${sentencesState.errorMessage}',
                      style: TextStyle(color: Colors.red.shade900),
                    ),
                  ),
                  // Przycisk "Ponów" bezpośrednio przy błędzie
                  TextButton.icon(
                    onPressed: () {
                      notifier.refreshCurrentPage();
                    },
                    icon: Icon(Icons.refresh, color: Colors.red.shade900),
                    label: Text(
                      "Ponów",
                      style: TextStyle(color: Colors.red.shade900),
                    ),
                  ),
                ],
              ),
            ),

          // Container(
          //   padding: const EdgeInsets.all(8),
          //   color: Colors.red.shade100,
          //   width: double.infinity,
          //   child: Text(
          //     'Błąd: ${sentencesState.errorMessage}',
          //     style: const TextStyle(color: Colors.red),
          //   ),
          // ),
          Expanded(
            child: sentencesState.isLoading && sentencesState.sentences.isEmpty
                ? const Center(child: CircularProgressIndicator())
                : sentencesState.sentences.isEmpty
                ? const Center(child: Text("Brak zdań do wyświetlenia."))
                : Stack(
                    children: [
                      ListView.separated(
                        itemCount: sentencesState.sentences.length,
                        padding: const EdgeInsets.all(8),
                        separatorBuilder: (context, index) {
                          return Divider(
                            height: 16,
                            thickness: 0.5,
                            color: Colors.grey.shade400,
                            indent: 8,
                            endIndent: 8,
                          );
                        },
                        itemBuilder: (context, index) {
                          final item = sentencesState.sentences[index];
                          // --- UŻYCIE NOWEGO WIDGETU ---
                          return SentenceTile(sentence: item);
                        },
                      ),
                      if (sentencesState.isLoading)
                        const Positioned(
                          top: 0,
                          left: 0,
                          right: 0,
                          child: LinearProgressIndicator(minHeight: 4),
                        ),
                    ],
                  ),
          ),
        ],
      ),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/features/sentences/presentation/delete_sentence_controller.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/sentences_repository.dart';
import 'sentences_provider.dart';

// Używamy prostego Providera, a nie StateNotifier, bo ten kontroler
// nie przechowuje stanu (stateless logic), tylko wykonuje akcję.
final deleteSentenceControllerProvider = Provider((ref) {
  return DeleteSentenceController(ref);
});

class DeleteSentenceController {
  final Ref _ref;

  DeleteSentenceController(this._ref);

  Future<void> deleteSentence({
    required BuildContext context,
    required int sentenceId,
  }) async {
    // 1. "Fire and forget" logic from UI perspective (dialog już zamknięty)
    
    final repo = _ref.read(sentencesRepositoryProvider);
    final notifier = _ref.read(sentencesProvider.notifier);
    final scaffoldMessenger = ScaffoldMessenger.of(context);

    try {
      // Wywołanie API (asynchronicznie)
      await repo.deleteSentence(sentenceId);
      if (!context.mounted) return;
      // Jeśli API zwróci 200 OK, usuwamy element z listy w UI
      notifier.removeSentenceLocally(sentenceId);

      // Feedback dla użytkownika (Snackbar)
      scaffoldMessenger.showSnackBar(
        const SnackBar(
          content: Text('Usunięto zdanie.'),
          backgroundColor: Colors.green,
          duration: Duration(seconds: 2),
        ),
      );
    } catch (e) {
      // Obsługa błędu
      scaffoldMessenger.showSnackBar(
        SnackBar(
          content: Text('Błąd usuwania: ${e.toString()}'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }
}


===============================
Ścieżka do pliku: ./lib/features/sentences/presentation/add_sentence_controller.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/sentence_create_model.dart';
import '../data/sentences_repository.dart';
import 'sentences_provider.dart'; // Potrzebne, żeby odświeżyć listę po sukcesie

// Controller zarządza stanem operacji dodawania.
// AsyncValue<void> oznacza, że operacja nie zwraca wartości, ale śledzimy jej status.
class AddSentenceController extends StateNotifier<AsyncValue<void>> {
  final SentencesRepository _repository;
  final Ref _ref; // Ref pozwala nam wchodzić w interakcję z innymi providerami

  AddSentenceController(this._repository, this._ref) 
      : super(const AsyncValue.data(null)); // Stan początkowy: idle (success null)

  Future<bool> addSentence({
    required String sentence,
    required String language,
    required String translation,
  }) async {
    // 1. Ustawiamy stan na ładowanie (UI zablokuje przycisk i pokaże spinner)
    state = const AsyncValue.loading();

    try {
      final dto = SentenceCreate(
        sentence: sentence,
        language: language,
        translation: translation,
      );

      await _repository.createSentence(dto);

      // --- ZMIANA ---
      // Zamiast zabijać providera (invalidate), prosimy go o odświeżenie danych.
      // Dzięki temu zachowujemy numer strony.
      await _ref.read(sentencesProvider.notifier).refreshCurrentPage();
      
      // Jeśli wolałbyś skakać do ostatniej strony (bo tam dodał się element),
      // odkomentuj metodę w providerze i użyj tutaj:
      // await _ref.read(sentencesProvider.notifier).goToLastPage();

      state = const AsyncValue.data(null);
      return true;
    } catch (e, stack) {
      // 4. Błąd
      state = AsyncValue.error(e, stack);
      return false;
    }
  }
}

// Rejestracja providera
final addSentenceControllerProvider = 
    StateNotifierProvider<AddSentenceController, AsyncValue<void>>((ref) {
  final repo = ref.watch(sentencesRepositoryProvider);
  return AddSentenceController(repo, ref);
});


===============================
Ścieżka do pliku: ./lib/features/sentences/presentation/edit_sentence_controller.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/sentence_update_model.dart';
import '../data/sentences_repository.dart';
import 'sentences_provider.dart';

// Używamy StateNotifier do zarządzania stanem asynchronicznym (loading/error/data)
// AsyncValue<void> informuje UI czy trwa zapisywanie.
class EditSentenceController extends StateNotifier<AsyncValue<void>> {
  final SentencesRepository _repository;
  final Ref _ref;

  EditSentenceController(this._repository, this._ref) 
      : super(const AsyncValue.data(null));

  Future<bool> editSentence({
    required int id,
    required String sentence,
    required String language,
    required String translation,
  }) async {
    state = const AsyncValue.loading(); // Pokaż spinner

    try {
      final dto = SentenceUpdate(
        sentence: sentence,
        language: language,
        translation: translation,
      );

      // 1. Wywołanie API
      final updatedSentence = await _repository.updateSentence(id: id, data: dto);

      // 2. Aktualizacja lokalnego stanu listy (nie musimy odświeżać całej strony!)
      _ref.read(sentencesProvider.notifier).updateSentenceLocally(updatedSentence);

      state = const AsyncValue.data(null); // Sukces
      return true;
    } catch (e, stack) {
      state = AsyncValue.error(e, stack); // Błąd
      return false;
    }
  }
}

final editSentenceControllerProvider = 
    StateNotifierProvider<EditSentenceController, AsyncValue<void>>((ref) {
  final repo = ref.watch(sentencesRepositoryProvider);
  return EditSentenceController(repo, ref);
});


===============================
Ścieżka do pliku: ./lib/features/sentences/presentation/edit_sentence_dialog.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/sentence_model.dart';
import 'edit_sentence_controller.dart';
import '../../../core/app_sizes.dart';

class EditSentenceDialog extends ConsumerStatefulWidget {
  final Sentence sentence; // Przyjmujemy obiekt do edycji

  const EditSentenceDialog({super.key, required this.sentence});

  @override
  ConsumerState<EditSentenceDialog> createState() => _EditSentenceDialogState();
}

class _EditSentenceDialogState extends ConsumerState<EditSentenceDialog> {
  final _formKey = GlobalKey<FormState>();
  
  // Kontrolery
  late TextEditingController _sentenceController;
  late TextEditingController _translationController;
  late TextEditingController _languageController;

  @override
  void initState() {
    super.initState();
    // Inicjalizujemy kontrolery wartościami z obiektu przekazanego w konstruktorze
    _sentenceController = TextEditingController(text: widget.sentence.sentence);
    _translationController = TextEditingController(text: widget.sentence.translation);
    _languageController = TextEditingController(text: widget.sentence.language);
  }

  @override
  void dispose() {
    _sentenceController.dispose();
    _translationController.dispose();
    _languageController.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;

    // Pobieramy notifiera kontrolera
    final controller = ref.read(editSentenceControllerProvider.notifier);

    final success = await controller.editSentence(
      id: widget.sentence.id,
      sentence: _sentenceController.text,
      translation: _translationController.text,
      language: _languageController.text,
    );

    // Sprawdzamy mounted zanim użyjemy contextu po await (C++ safety rule!)
    if (success && mounted) {
      Navigator.of(context).pop(); // Zamykamy dialog
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Zaktualizowano zdanie'),
          behavior: SnackBarBehavior.floating, // Wygląda lepiej
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final asyncState = ref.watch(editSentenceControllerProvider);
    final isLoading = asyncState.isLoading;

    return Dialog(
      // Dialog zamiast AlertDialog, żeby mieć większą kontrolę nad layoutem
      insetPadding: const EdgeInsets.all(16),
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: AppSizes.maxMobileWidth*0.9), // Max szerokość na tabletach
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisSize: MainAxisSize.min, // Dialog zajmie tyle ile trzeba
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Text(
                  "Edytuj zdanie #${widget.sentence.id}",
                  style: Theme.of(context).textTheme.headlineSmall,
                ),
                const SizedBox(height: 24),
                
                // Obsługa błędu
                if (asyncState.hasError)
                  Container(
                    padding: const EdgeInsets.all(8),
                    margin: const EdgeInsets.only(bottom: 16),
                    decoration: BoxDecoration(
                      color: Colors.red.shade50,
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(color: Colors.red.shade200),
                    ),
                    child: Text(
                      'Błąd: ${asyncState.error}',
                      style: TextStyle(color: Colors.red.shade800),
                    ),
                  ),

                // Lista pól w Flexible/ScrollView na wypadek małego ekranu/klawiatury
                Flexible(
                  child: SingleChildScrollView(
                    child: Column(
                      children: [
                        TextFormField(
                          controller: _sentenceController,
                          decoration: const InputDecoration(
                            labelText: 'Oryginał',
                            border: OutlineInputBorder(),
                            alignLabelWithHint: true, // Ważne przy multiline
                          ),
                          enabled: !isLoading,
                          minLines: 3, // Domyślnie wysokie na 3 linie
                          maxLines: null, // Rozszerza się w nieskończoność
                          keyboardType: TextInputType.multiline,
                          //validator: (v) => v!.isEmpty ? 'Pole wymagane' : null,
                        ),
                        const SizedBox(height: 16),
                        
                        TextFormField(
                          controller: _translationController,
                          decoration: const InputDecoration(
                            labelText: 'Tłumaczenie',
                            border: OutlineInputBorder(),
                            alignLabelWithHint: true,
                          ),
                          enabled: !isLoading,
                          minLines: 2,
                          maxLines: null,
                          keyboardType: TextInputType.multiline,
                          //validator: (v) => v!.isEmpty ? 'Pole wymagane' : null,
                        ),
                        const SizedBox(height: 16),
                        
                        // --- ZMIANA: Zwykły Label informacyjny ---
                        // Zamiast pola tekstowego pokazujemy po prostu informację
                        Padding(
                          padding: const EdgeInsets.only(left: 4.0), // Lekkie wcięcie, żeby zrównać z labelami inputów
                          child: Row(
                            children: [
                              const Icon(Icons.language, color: Colors.grey, size: 20),
                              const SizedBox(width: 8),
                              Text(
                                'Język: ',
                                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                                  color: Colors.grey[700],
                                ),
                              ),
                              Container(
                                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                                decoration: BoxDecoration(
                                  color: Theme.of(context).brightness == Brightness.light 
                                      ? Colors.grey.shade200 
                                      : Colors.grey.shade700,
                                  borderRadius: BorderRadius.circular(4),
                                ),
                                child: Text(
                                  widget.sentence.language.toUpperCase(),
                                  style: const TextStyle(fontWeight: FontWeight.bold),
                                ),
                              ),
                            ],
                          ),
                        ),

                        /* 
                        // --- Oryginalna wersja edycyjna (zakomentowana) ---
                        TextFormField(
                          controller: _languageController,
                          decoration: const InputDecoration(
                            labelText: 'Język',
                            border: OutlineInputBorder(),
                            helperText: 'Kod języka, np. en, de, es', //ISO 639-1 
                          ),
                          enabled: !isLoading,
                          //validator: (v) => v!.isEmpty ? 'Pole wymagane' : null,
                        ),
                        */
                      ],
                    ),
                  ),
                ),
                
                const SizedBox(height: 24),
                
                // Przyciski akcji
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    TextButton(
                      onPressed: isLoading ? null : () => Navigator.of(context).pop(),
                      child: const Text('Anuluj'),
                    ),
                    const SizedBox(width: 8),
                    FilledButton( // FilledButton to nowy standard Material 3 (zamiast ElevatedButton)
                      onPressed: isLoading ? null : _submit,
                      child: isLoading
                          ? const SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Text('Zapisz zmiany'),
                    ),
                  ],
                )
              ],
            ),
          ),
        ),
      ),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/sentences/presentation/sentences_provider.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/sentence_model.dart';
import '../data/sentences_repository.dart';
import '../../../core/network/api_error_handler.dart';

class SentencesState {
  final List<Sentence> sentences;
  final bool isLoading;
  final String? errorMessage;
  final int currentPage;
  final int totalPages;

  const SentencesState({
    this.sentences = const [],
    this.isLoading = false,
    this.errorMessage,
    this.currentPage = 1,
    this.totalPages = 1,
  });

  bool get isLastPage => currentPage >= totalPages;

  SentencesState copyWith({
    List<Sentence>? sentences,
    bool? isLoading,
    String? errorMessage,
    int? currentPage,
    int? totalPages,
  }) {
    return SentencesState(
      sentences: sentences ?? this.sentences,
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage,
      currentPage: currentPage ?? this.currentPage,
      totalPages: totalPages ?? this.totalPages,
    );
  }
}

class SentencesNotifier extends StateNotifier<SentencesState> {
  final SentencesRepository _repository;
  static const int _perPage = 10;

  SentencesNotifier(this._repository) : super(const SentencesState()) {
    loadSentences(page: 1);
  }

  Future<void> loadSentences({required int page}) async {
    if (state.isLoading) return;

    // Resetujemy błąd przy nowej próbie
    state = state.copyWith(isLoading: true, errorMessage: null);

    try {
      final response = await _repository.getSentences(
        page: page,
        perPage: _perPage,
      );

      state = state.copyWith(
        isLoading: false,
        sentences: response.sentences,
        totalPages: response.totalPages,
        currentPage: page,
        errorMessage: null, // Sukces = brak błędu
      );
    } catch (e) {
      // TU JEST ZMIANA: Używamy naszego parsera błędów
      final friendlyMessage = ApiErrorHandler.getErrorMessage(e);

      state = state.copyWith(isLoading: false, errorMessage: friendlyMessage);
    }
  }

  // --- NOWA METODA ---
  // Odświeża aktualną stronę bez resetowania stanu do zera
  Future<void> refreshCurrentPage() async {
    // Ładujemy ponownie tę samą stronę, na której jesteśmy
    await loadSentences(page: state.currentPage);
  }

  /* 
  // Opcjonalnie: Jeśli wolałbyś iść na ostatnią stronę po dodaniu:
  Future<void> goToLastPage() async {
     // Najpierw pobierzmy info (może doszła nowa strona?)
     // To uproszczenie, w idealnym świecie API po dodaniu zwraca ID nowej strony
     await loadSentences(page: state.totalPages);
  }
  */

  void nextPage() {
    if (!state.isLastPage) {
      loadSentences(page: state.currentPage + 1);
    }
  }

  void previousPage() {
    if (state.currentPage > 1) {
      loadSentences(page: state.currentPage - 1);
    }
  }

  // Usuwa element z lokalnego stanu (UI odświeży się natychmiast)
  void removeSentenceLocally(int sentenceId) {
    // std::remove_if w C++ style
    final updatedList = state.sentences
        .where((s) => s.id != sentenceId)
        .toList();

    state = state.copyWith(
      sentences: updatedList,
      // Opcjonalnie: można tu obsłużyć zmniejszenie licznika stron itp.
    );
  }

  void updateSentenceLocally(Sentence updatedSentence) {
    // Tworzymy nową listę, mapując starą
    final newSentences = state.sentences.map((s) {
      return s.id == updatedSentence.id ? updatedSentence : s;
    }).toList();

    // Emitujemy nowy stan
    state = state.copyWith(sentences: newSentences);
  }
}

final sentencesProvider =
    StateNotifierProvider<SentencesNotifier, SentencesState>((ref) {
      final repository = ref.watch(sentencesRepositoryProvider);
      return SentencesNotifier(repository);
    });



===============================
Ścieżka do pliku: ./lib/features/sentences/presentation/add_sentence_dialog.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'add_sentence_controller.dart';

class AddSentenceDialog extends ConsumerStatefulWidget {
  const AddSentenceDialog({super.key});

  @override
  ConsumerState<AddSentenceDialog> createState() => _AddSentenceDialogState();
}

class _AddSentenceDialogState extends ConsumerState<AddSentenceDialog> {
  final _formKey = GlobalKey<FormState>();
  
  final _sentenceController = TextEditingController();
  final _translationController = TextEditingController();
  final _languageController = TextEditingController(text: 'EN');

  @override
  void dispose() {
    _sentenceController.dispose();
    _translationController.dispose();
    _languageController.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    // Przed wysłaniem warto upewnić się, że formularz jest poprawny
    if (_formKey.currentState!.validate()) {
      final success = await ref.read(addSentenceControllerProvider.notifier).addSentence(
            sentence: _sentenceController.text, // Może być pusty string
            language: _languageController.text,
            translation: _translationController.text, // Może być pusty string
          );

      if (success && mounted) {
        Navigator.of(context).pop();
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Dodano nowe zdanie!')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final asyncState = ref.watch(addSentenceControllerProvider);
    final isLoading = asyncState.isLoading;

    return AlertDialog(
      title: const Text('Dodaj nowe zdanie'),
      content: SingleChildScrollView(
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (asyncState.hasError)
                Padding(
                  padding: const EdgeInsets.only(bottom: 10),
                  child: Text(
                    'Błąd: ${asyncState.error}',
                    style: const TextStyle(color: Colors.red, fontSize: 12),
                  ),
                ),
                
              TextFormField(
                controller: _sentenceController,
                decoration: const InputDecoration(labelText: 'Zdanie (np. Witaj Świecie)'),
                enabled: !isLoading,
                // ZMIANA TUTAJ:
                validator: (value) {
                  // Sprawdzamy, czy aktualne pole jest puste ORAZ czy drugie pole jest puste
                  if ((value == null || value.isEmpty) && _translationController.text.isEmpty) {
                    return 'Wypełnij zdanie LUB tłumaczenie';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 10),
              TextFormField(
                controller: _translationController,
                decoration: const InputDecoration(labelText: 'Tłumaczenie (np. Hello World)'),
                enabled: !isLoading,
                // ZMIANA TUTAJ:
                validator: (value) {
                  // To samo sprawdzenie w drugą stronę
                  if ((value == null || value.isEmpty) && _sentenceController.text.isEmpty) {
                    return 'Wypełnij zdanie LUB tłumaczenie';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 10),
              TextFormField(
                controller: _languageController,
                decoration: const InputDecoration(labelText: 'Język (np. EN)'),
                enabled: !isLoading,
                validator: (value) {
                  if (value == null || value.isEmpty) return 'Pole wymagane';
                  return null;
                },
              ),
            ],
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: isLoading ? null : () => Navigator.of(context).pop(),
          child: const Text('Anuluj'),
        ),
        ElevatedButton(
          onPressed: isLoading ? null : _submit,
          child: isLoading 
              ? const SizedBox(
                  width: 20, 
                  height: 20, 
                  child: CircularProgressIndicator(strokeWidth: 2)
                ) 
              : const Text('Zapisz'),
        ),
      ],
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/sentences/presentation/widgets/sentence_tile.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/sentence_model.dart';
import '../delete_sentence_controller.dart';
import '../edit_sentence_dialog.dart';

class SentenceTile extends ConsumerWidget {
  final Sentence sentence;

  const SentenceTile({super.key, required this.sentence});

  void _showDeleteConfirmation(BuildContext context, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text("Potwierdzenie"),
        content: const Text("Usunąć to zdanie?"),
        actions: [
          // Przycisk "Nie"
          TextButton(
            onPressed: () {
              Navigator.of(ctx).pop(); // Zamknij dialog
            },
            child: const Text("Nie"),
          ),
          // Przycisk "Tak" - Czerwony
          TextButton(
            onPressed: () {
              // 1. Najpierw zamykamy dialog
              Navigator.of(ctx).pop();

              // 2. Delegujemy operację do kontrolera
              ref
                  .read(deleteSentenceControllerProvider)
                  .deleteSentence(context: context, sentenceId: sentence.id);
            },
            style: TextButton.styleFrom(
              foregroundColor: Colors.red, // Czerwony tekst
            ),
            child: const Text("Tak"),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 4),
      elevation: 2,
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: Colors.teal,
          foregroundColor: Colors.white,
          child: Text(sentence.id.toString()),
        ),
        title: Text(
          sentence.sentence,
          style: const TextStyle(fontWeight: FontWeight.bold),
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const SizedBox(height: 4),
            Text(
              sentence.translation,
              style: const TextStyle(
                fontStyle: FontStyle.italic,
                color: Colors.black87,
              ),
            ),
            const SizedBox(height: 4),
            Row(
              children: [
                Icon(Icons.language, size: 14, color: Colors.grey[600]),
                const SizedBox(width: 4),
                Text(
                  sentence.language,
                  style: TextStyle(color: Colors.grey[600], fontSize: 12),
                ),
              ],
            ),
          ],
        ),
        isThreeLine: true,

        // --- SEKCJA TRAILING (POPRAWIONA) ---
        // Używamy FittedBox, aby uniknąć błędu "Bottom overflowed"
        trailing: FittedBox(
          fit: BoxFit.scaleDown, // Skaluje w dół, jeśli brakuje miejsca
          alignment: Alignment.centerRight,
          child: Column(
            mainAxisSize: MainAxisSize.min, // Zajmuje tylko tyle miejsca ile trzeba
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // 1. Ikona USUWANIA (Czerwona)
              IconButton(
                icon: const Icon(Icons.delete_outline, color: Colors.red),
                onPressed: () => _showDeleteConfirmation(context, ref),
                tooltip: 'Usuń zdanie',
                // Ustawienia kompaktowe:
                padding: EdgeInsets.zero,
                constraints: const BoxConstraints(),
                iconSize: 32, // Lekko mniejsza ikona dla bezpieczeństwa
              ),
              
              const SizedBox(height: 8), // Mniejszy odstęp (było 12, teraz 8)

              // 2. Ikona EDYCJI (Niebieska)
              IconButton(
                icon: const Icon(Icons.edit, color: Colors.blue),
                onPressed: () {
                   // TODO: Tu logika edycji
                   print("Kliknięto edycję id: ${sentence.id}");
                   showDialog(
                     context: context,
                     builder: (context) => EditSentenceDialog(sentence: sentence),
                   );
                },
                tooltip: 'Edytuj zdanie',
                padding: EdgeInsets.zero,
                constraints: const BoxConstraints(),
                iconSize: 32,
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/sentences/data/sentence_create_model.dart

Zawartość pliku:

class SentenceCreate {
  final String sentence;
  final String language;
  final String translation;

  const SentenceCreate({
    required this.sentence,
    required this.language,
    required this.translation,
  });

  // Metoda toJson konwertuje obiekt na Mapę, którą Dio zamieni na JSON.
  // W C++ to byłaby metoda serializująca do QJsonObject.
  Map<String, dynamic> toJson() {
    return {
      'sentence': sentence,
      'language': language,
      'translation': translation,
    };
  }
}


===============================
Ścieżka do pliku: ./lib/features/sentences/data/sentence_model.dart

Zawartość pliku:

import 'package:equatable/equatable.dart';

// Equatable pozwala porównywać obiekty po wartościach pól, a nie referencji w pamięci.
// To jak przeładowanie operatora == w C++.
class Sentence extends Equatable {
  final int id;
  final String sentence;
  final String language;
  final String translation;
  // created_at przychodzi jako string, w prawdziwym projekcie parsujemy to na DateTime
  final String createdAt; 

  const Sentence({
    required this.id,
    required this.sentence,
    required this.language,
    required this.translation,
    required this.createdAt,
  });

  // Factory constructor - w C++ to byłaby statyczna metoda "createFromJson"
  factory Sentence.fromJson(Map<String, dynamic> json) {
    return Sentence(
      id: json['id'] as int,
      sentence: json['sentence'] as String,
      language: json['language'] as String,
      translation: json['translation'] as String,
      createdAt: json['created_at'] as String,
    );
  }

  @override
  List<Object?> get props => [id, sentence, language, translation, createdAt];
}


===============================
Ścieżka do pliku: ./lib/features/sentences/data/sentences_repository.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/network/dio_provider.dart';
import 'sentence_model.dart';
import 'sentence_create_model.dart';
import 'sentence_update_model.dart';

// Prosta klasa (jak struct w C++) do przekazania danych z API do Providera
class SentencesResponse {
  final List<Sentence> sentences;
  final int totalPages;

  SentencesResponse(this.sentences, this.totalPages);
}

final sentencesRepositoryProvider = Provider<SentencesRepository>((ref) {
  final dio = ref.watch(dioProvider);
  return SentencesRepository(dio);
});

class SentencesRepository {
  final Dio _dio;

  SentencesRepository(this._dio);

  // Zmieniamy typ zwracany na naszą strukturę SentencesResponse
  Future<SentencesResponse> getSentences({required int page, int perPage = 10}) async {
    try {
      final response = await _dio.get(
        '/api/sentences/',
        queryParameters: {
          'page': page,
          'per_page': perPage,
        },
      );

      // 1. Odbieramy główny obiekt JSON (Map<String, dynamic>)
      final Map<String, dynamic> json = response.data;

      // 2. Wyciągamy listę z klucza "data"
      final List<dynamic> rawList = json['data'];
      
      // 3. Wyciągamy liczbę stron z klucza "total_pages"
      final int totalPages = json['total_pages'] ?? 1; // domyślnie 1 jakby api nie dało

      // 4. Mapujemy listę
      final sentences = rawList.map((e) => Sentence.fromJson(e)).toList();

      // Zwracamy komplet danych
      return SentencesResponse(sentences, totalPages);

    } catch (e) {
      rethrow;
    }
  }

  Future<void> createSentence(SentenceCreate data) async {
    try {
      // Dio automatycznie zserializuje Mapę zwróconą przez data.toJson()
      await _dio.post(
        '/api/sentences/',
        data: data.toJson(),
      );
    } catch (e) {
      rethrow;
    }
  }

  Future<void> deleteSentence(int id) async {
    try {
      // Endpoint: DELETE /api/sentences/{sentence_id}
      await _dio.delete('/api/sentences/$id');
    } catch (e) {
      rethrow;
    }
  }

  Future<Sentence> updateSentence({
    required int id,
    required SentenceUpdate data,
  }) async {
    try {
      final response = await _dio.put(
        '/api/sentences/$id',
        data: data.toJson(),
      );
      
      // API zwraca zaktualizowany obiekt Sentence (według dokumnetacji)
      // Od razu go parsujemy i zwracamy wyżej.
      return Sentence.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }

}


===============================
Ścieżka do pliku: ./lib/features/sentences/data/sentence_update_model.dart

Zawartość pliku:

class SentenceUpdate {
  // W API te pola są 'anyOf string/null', więc tutaj String?
  final String? sentence;
  final String? language;
  final String? translation;

  const SentenceUpdate({
    this.sentence,
    this.language,
    this.translation,
  });

  Map<String, dynamic> toJson() {
    // Serializujemy tylko te pola, które nie są nullem (chociaż w edycji wyślemy wszystkie)
    return {
      if (sentence != null) 'sentence': sentence,
      if (language != null) 'language': language,
      if (translation != null) 'translation': translation,
    };
  }
}


===============================
Ścieżka do pliku: ./lib/features/words/words_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import '../../core/widgets/main_drawer.dart';

class WordsPage extends StatelessWidget {
  const WordsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return  Scaffold(
      body: Center(child: Text('Nauka slowek - niebawem')),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/core/app_sizes.dart

Zawartość pliku:

class AppSizes{
  static const double maxMobileWidth = 550.0;
}


===============================
Ścieżka do pliku: ./lib/core/navigation_provider.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';

final navigationIndexProvider = StateProvider<int>((ref) => 0);


===============================
Ścieżka do pliku: ./lib/core/widgets/main_drawer.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../navigation_provider.dart';

class MainDrawer extends ConsumerWidget {
  const MainDrawer({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Odczytujemy stan, żeby wiedzieć, który element podświetlić
    final selectedIndex = ref.watch(navigationIndexProvider);

    return Drawer(
      child: ListView(
        padding: EdgeInsets.zero,
        children: [
          const DrawerHeader(
            decoration: BoxDecoration(color: Colors.deepPurple),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                Text(
                  'English Learner',
                  style: TextStyle(color: Colors.white, fontSize: 24, fontWeight: FontWeight.bold),
                ),
                Text(
                  'Twój postęp: 45%',
                  style: TextStyle(color: Colors.white70, fontSize: 14),
                ),
              ],
            ),
          ),
          _DrawerTile(
            title: 'Ogłoszenia parafialne',
            icon: Icons.home,
            index: 0,
            isSelected: selectedIndex == 0,
          ),
          _DrawerTile(
            title: 'Slownik',
            icon: Icons.menu_book,
            index: 1,
            isSelected: selectedIndex == 1,
          ),
          _DrawerTile(
            title: 'Slowka',
            icon: Icons.school,
            index: 2,
            isSelected: selectedIndex == 2,
          ),
          _DrawerTile(
            title: 'Zwroty',
            icon: Icons.chat,
            index: 3,
            isSelected: selectedIndex == 3,
          ),
          _DrawerTile(
            title: 'Rejestracja',
            icon: Icons.chat,
            index: 4,
            isSelected: selectedIndex == 4,
          ),
          _DrawerTile(
            title: 'Test',
            icon: Icons.quiz,
            index: 5,
            isSelected: selectedIndex == 5,
          ),
          _DrawerTile(
            title: 'Health Check',
            icon: Icons.dns,
            index: 6,
            isSelected: selectedIndex == 6
          ),
          _DrawerTile(
            title: 'Captcha Test', 
            icon: Icons.security, 
            index: 7,
            isSelected: selectedIndex == 7
          ),
        ],
      ),
    );
  }
}

// Prywatny pomocniczy widget tylko dla tego pliku (Clean Code)
class _DrawerTile extends ConsumerWidget {
  final String title;
  final IconData icon;
  final int index;
  final bool isSelected;

  const _DrawerTile({
    required this.title,
    required this.icon,
    required this.index,
    required this.isSelected,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ListTile(
      leading: Icon(icon, color: isSelected ? Colors.deepPurple : null),
      title: Text(title),
      selected: isSelected,
      onTap: () {
        // 1. Zmień stan indeksu
        ref.read(navigationIndexProvider.notifier).state = index;
        // 2. Zamknij drawer (ekran boczny)
        Navigator.pop(context);
      },
    );
  }
}


===============================
Ścieżka do pliku: ./lib/core/network/dio_provider.dart

Zawartość pliku:

// lib/core/network/dio_provider.dart

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../features/auth/data/token_storage.dart'; // Import storage

final dioProvider = Provider<Dio>((ref) {
  final dio = Dio(BaseOptions(
    baseUrl: 'https://dev-sentences.rafal-kruszyna.org', // lub gateway URL
    connectTimeout: const Duration(seconds: 5),
    receiveTimeout: const Duration(seconds: 5),
  ));

  // Dodajemy interceptor
  final storage = ref.watch(tokenStorageProvider);
  
  dio.interceptors.add(InterceptorsWrapper(
    onRequest: (options, handler) async {
      // Przed każdym zapytaniem pobierz token z bezpiecznego magazynu
      final token = await storage.getToken();
      
      // Jeśli mamy token, dodaj nagłówek
      if (token != null) {
        options.headers['Authorization'] = 'Bearer ${token.accessToken}';
      }
      
      return handler.next(options);
    },
    onError: (DioException error, handler) async {
      // Obsługa 401 (Token wygasł)
      if (error.response?.statusCode == 401) {
        // TU w przyszłości dodasz logikę "Refresh Token"
        // Na razie proste wylogowanie w UI jeśli token wygasł
      }
      return handler.next(error);
    }
  ));

  return dio;
});


===============================
Ścieżka do pliku: ./lib/core/network/api_error_handler.dart

Zawartość pliku:

import 'package:dio/dio.dart';

class ApiErrorHandler {
  // Metoda statyczna, działająca jak fabryka komunikatów
  static String getErrorMessage(Object error) {
    if (error is DioException) {
      switch (error.type) {
        case DioExceptionType.connectionTimeout:
        case DioExceptionType.sendTimeout:
        case DioExceptionType.receiveTimeout:
          return "Upłynął limit czasu połączenia. Sprawdź internet.";
        
        case DioExceptionType.badResponse:
          final statusCode = error.response?.statusCode;
          if (statusCode == 404) return "Nie znaleziono zasobu na serwerze (404).";
          if (statusCode == 500) return "Błąd wewnętrzny serwera (500).";
          return "Błąd serwera: $statusCode";

        case DioExceptionType.connectionError:
          return "Brak połączenia z serwerem. Upewnij się, że masz internet lub serwer jest dostępny.";

        case DioExceptionType.cancel:
          return "Żądanie zostało anulowane.";

        default:
          return "Wystąpił nieznany błąd sieciowy.";
      }
    } else {
      // Błędy nietypowe (np. błąd parsowania JSON, błąd w kodzie Dart)
      return "Wystąpił niespodziewany błąd: ${error.toString()}"; // W wersji PRO tutaj logujemy do Sentry/Crashlytics
    }
  }
}


