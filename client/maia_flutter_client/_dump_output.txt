===============================
Ścieżka do pliku: ./lib/app.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:maia_flutter_client/features/auth/presentation/forgot_password_page.dart';
import 'package:maia_flutter_client/features/auth/presentation/login_page.dart';
import 'package:maia_flutter_client/features/auth/presentation/register_page.dart';
import 'package:maia_flutter_client/features/auth/presentation/widgets/user_avatar_button.dart';
import 'core/navigation_provider.dart';
import 'core/widgets/main_drawer.dart';
import 'features/home/home_page.dart';
import 'features/home/home_app_bar.dart';
import 'features/dictionary/dictionary_page.dart';
import 'features/words/words_page.dart';
import 'features/sentences/sentences_page.dart';
import 'features/sentences/sentences_app_bar.dart';
import 'features/test/test_page.dart';
import 'features/test/test_app_bar.dart';
import 'core/app_sizes.dart'; // Import stałych
import 'features/health/services_health_page.dart';
import 'features/settings/presentation/settings_page.dart';
import 'features/captcha/captcha_page.dart';

class MainShell extends ConsumerWidget {
  const MainShell({super.key});

  static const List<Widget> _pages = [
    HomePage(),
    DictionaryPage(),
    WordsPage(),
    SentencesPage(),
    RegisterPage(),
    LoginPage(),
    //Dev Tools Pages
    TestPage(),
    ServicesHealthPage(),
    CaptchaPage(),
    //Pages not shown in the Drawer
    ForgotPasswordPage(),
    SettingsPage(),
  ];

  static final List<PreferredSizeWidget> _appBars = [
    const HomeAppBar(),
    AppBar(
      title: const Text("Dictionary"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    AppBar(
      title: const Text("Words"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    const SentencesAppBar(),
    AppBar(
      title: const Text("Rejestracja"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    AppBar(
      title: const Text("Logowanie"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    const TestAppBar(),
    AppBar(
      title: const Text("Health Check"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    AppBar(
      title: const Text("Captcha Demo"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    AppBar(
      title: const Text("Reset hasła"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    AppBar(
      title: const Text("Ustawienia"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
  ];

  // static const List<String> _titles = [
  //   'Ogłoszenia parafialne',
  //   'Dictionary',
  //   'Words',
  //   'Sentences',
  //   'Test',
  //   'Health Check',
  // ];

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedIndex = ref.watch(navigationIndexProvider);

    return Container(
      //szare tło aplikacji
      // Zamieniamy surfaceVariant na surfaceContainerHighest
      color: const Color(0xFFE0E0E0),
      // color: Theme.of(
      //   context,
      // ).colorScheme.surfaceContainer,
      //color: const Color(0xFFE0E0E0),
      // color: Theme.of(
      //   context,
      // ).colorScheme.surfaceContainerHighest.withOpacity(0.5),
      child: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: AppSizes.maxMobileWidth),
          child: Container(
            // Ten kontener dodaje cień i ogranicza Scaffold
            decoration: BoxDecoration(
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withValues(alpha: 0.05),
                  blurRadius: 10,
                ),
              ],
            ),
            child: ClipRect(
              //ClipRect jest potrzebny bo inaczej boczny Drawer rysuje sie poza oknem aplikacji w widoku np na tablecie, dlatego trzeba przyciac Drawer do glownego słupka aplikacji
              child: Scaffold(
                //backgroundColor: Theme.of(context).colorScheme.surface,
                backgroundColor: const Color(0xFFFFFFFF),
                appBar: _appBars[selectedIndex],
                // appBar: AppBar(
                //   title: Text(_titles[selectedIndex]),
                //   elevation: 2,
                // ),
                drawer: const MainDrawer(),
                //body: _pages[selectedIndex],
                body: IndexedStack(index: selectedIndex, children: _pages),
              ),
            ),
          ),
        ),
      ),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/main.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'app.dart';

void main() {
  // ProviderScope przechowuje stan wszystkich providerów
  runApp(const ProviderScope(child: MyApp()));
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'English Learning App',
      theme: ThemeData(
        //colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      home: const MainShell(),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/features/sentences/sentences_app_bar.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:maia_flutter_client/features/auth/presentation/widgets/user_avatar_button.dart';
import './presentation/sentences_provider.dart';

class SentencesAppBar extends ConsumerWidget implements PreferredSizeWidget {
  const SentencesAppBar({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Obserwujemy stan, aby np. pokazać inny spinner na przycisku odświeżania,
    // jeśli trwa ładowanie (opcjonalny bajer, tutaj prosta wersja).
    final state = ref.watch(sentencesProvider);
    final sentencesNotifier = ref.read(sentencesProvider.notifier);

    return AppBar(
      title: const Text("Sentences"),
      elevation: 2,
      actions: [
        // Przycisk Odśwież
        IconButton(
          icon: state.isLoading 
              ? const SizedBox(
                  width: 20, 
                  height: 20, 
                  child: CircularProgressIndicator(strokeWidth: 2, color: Colors.black54,)
                )
              : const Icon(Icons.refresh),
          tooltip: "Odśwież listę",
          onPressed: state.isLoading 
              ? null // Zablokuj, jeśli już ładuje
              : () {
                  // Tu wywołujemy logikę "Backendu"
                  sentencesNotifier.refreshCurrentPage();
                },
        ),
        // Opcjonalnie inne przyciski, np. sortowanie
        // IconButton(icon: Icon(Icons.filter_list), onPressed: () {}),
        const UserAvatarButton(),
      ],
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}


===============================
Ścieżka do pliku: ./lib/features/sentences/sentences_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'presentation/sentences_provider.dart';
import 'presentation/add_sentence_dialog.dart';
import 'presentation/widgets/sentence_tile.dart';

class SentencesPage extends ConsumerWidget {
  const SentencesPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final sentencesState = ref.watch(sentencesProvider);
    final notifier = ref.read(sentencesProvider.notifier);

    return Scaffold(
      //backgroundColor: Colors.transparent,
      //backgroundColor: Colors.red,
      backgroundColor: const Color(0xFFFFFFFF),

      floatingActionButton: FloatingActionButton(
        onPressed: () {
          showDialog(
            context: context,
            builder: (context) => const AddSentenceDialog(),
          );
        },
        child: const Icon(Icons.add),
      ),

      bottomNavigationBar: SafeArea(
        child: Container(
          padding: const EdgeInsets.all(8),
          decoration: BoxDecoration(
            color: Theme.of(
              context,
            ).colorScheme.surfaceContainerHighest.withValues(alpha: 0.3),
            border: Border(
              top: BorderSide(color: Colors.grey.withValues(alpha: 0.2)),
            ),
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              ElevatedButton.icon(
                onPressed:
                    sentencesState.currentPage > 1 && !sentencesState.isLoading
                    ? () => notifier.previousPage()
                    : null,
                icon: const Icon(Icons.arrow_back),
                label: const Text("Poprzednia"),
              ),

              Text(
                "Strona ${sentencesState.currentPage}",
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),

              ElevatedButton.icon(
                onPressed:
                    !sentencesState.isLastPage && !sentencesState.isLoading
                    ? () => notifier.nextPage()
                    : null,
                label: const Text("Następna"),
                icon: const Icon(Icons.arrow_forward),
              ),
            ],
          ),
        ),
      ),

      body: Column(
        children: [
          if (sentencesState.errorMessage != null)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              color: Colors.red.shade100,
              width: double.infinity,
              child: Row(
                children: [
                  Expanded(
                    child: Text(
                      'Błąd: ${sentencesState.errorMessage}',
                      style: TextStyle(color: Colors.red.shade900),
                    ),
                  ),
                  // Przycisk "Ponów" bezpośrednio przy błędzie
                  TextButton.icon(
                    onPressed: () {
                      notifier.refreshCurrentPage();
                    },
                    icon: Icon(Icons.refresh, color: Colors.red.shade900),
                    label: Text(
                      "Ponów",
                      style: TextStyle(color: Colors.red.shade900),
                    ),
                  ),
                ],
              ),
            ),

          // Container(
          //   padding: const EdgeInsets.all(8),
          //   color: Colors.red.shade100,
          //   width: double.infinity,
          //   child: Text(
          //     'Błąd: ${sentencesState.errorMessage}',
          //     style: const TextStyle(color: Colors.red),
          //   ),
          // ),
          Expanded(
            child: sentencesState.isLoading && sentencesState.sentences.isEmpty
                ? const Center(child: CircularProgressIndicator())
                : sentencesState.sentences.isEmpty
                ? const Center(child: Text("Brak zdań do wyświetlenia."))
                : Stack(
                    children: [
                      ListView.separated(
                        itemCount: sentencesState.sentences.length,
                        padding: const EdgeInsets.all(8),
                        separatorBuilder: (context, index) {
                          return Divider(
                            height: 16,
                            thickness: 0.5,
                            color: Colors.grey.shade400,
                            indent: 8,
                            endIndent: 8,
                          );
                        },
                        itemBuilder: (context, index) {
                          final item = sentencesState.sentences[index];
                          // --- UŻYCIE NOWEGO WIDGETU ---
                          return SentenceTile(sentence: item);
                        },
                      ),
                      if (sentencesState.isLoading)
                        const Positioned(
                          top: 0,
                          left: 0,
                          right: 0,
                          child: LinearProgressIndicator(minHeight: 4),
                        ),
                    ],
                  ),
          ),
        ],
      ),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/features/sentences/presentation/delete_sentence_controller.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/sentences_repository.dart';
import 'sentences_provider.dart';

// Używamy prostego Providera, a nie StateNotifier, bo ten kontroler
// nie przechowuje stanu (stateless logic), tylko wykonuje akcję.
final deleteSentenceControllerProvider = Provider((ref) {
  return DeleteSentenceController(ref);
});

class DeleteSentenceController {
  final Ref _ref;

  DeleteSentenceController(this._ref);

  Future<void> deleteSentence({
    required BuildContext context,
    required int sentenceId,
  }) async {
    // 1. "Fire and forget" logic from UI perspective (dialog już zamknięty)
    
    final repo = _ref.read(sentencesRepositoryProvider);
    final notifier = _ref.read(sentencesProvider.notifier);
    final scaffoldMessenger = ScaffoldMessenger.of(context);

    try {
      // Wywołanie API (asynchronicznie)
      await repo.deleteSentence(sentenceId);
      if (!context.mounted) return;
      // Jeśli API zwróci 200 OK, usuwamy element z listy w UI
      notifier.removeSentenceLocally(sentenceId);

      // Feedback dla użytkownika (Snackbar)
      scaffoldMessenger.showSnackBar(
        const SnackBar(
          content: Text('Usunięto zdanie.'),
          backgroundColor: Colors.green,
          duration: Duration(seconds: 2),
        ),
      );
    } catch (e) {
      // Obsługa błędu
      scaffoldMessenger.showSnackBar(
        SnackBar(
          content: Text('Błąd usuwania: ${e.toString()}'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }
}


===============================
Ścieżka do pliku: ./lib/features/sentences/presentation/add_sentence_controller.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/sentence_create_model.dart';
import '../data/sentences_repository.dart';
import 'sentences_provider.dart'; // Potrzebne, żeby odświeżyć listę po sukcesie

// Controller zarządza stanem operacji dodawania.
// AsyncValue<void> oznacza, że operacja nie zwraca wartości, ale śledzimy jej status.
class AddSentenceController extends StateNotifier<AsyncValue<void>> {
  final SentencesRepository _repository;
  final Ref _ref; // Ref pozwala nam wchodzić w interakcję z innymi providerami

  AddSentenceController(this._repository, this._ref) 
      : super(const AsyncValue.data(null)); // Stan początkowy: idle (success null)

  Future<bool> addSentence({
    required String sentence,
    required String language,
    required String translation,
  }) async {
    // 1. Ustawiamy stan na ładowanie (UI zablokuje przycisk i pokaże spinner)
    state = const AsyncValue.loading();

    try {
      final dto = SentenceCreate(
        sentence: sentence,
        language: language,
        translation: translation,
      );

      await _repository.createSentence(dto);

      // --- ZMIANA ---
      // Zamiast zabijać providera (invalidate), prosimy go o odświeżenie danych.
      // Dzięki temu zachowujemy numer strony.
      await _ref.read(sentencesProvider.notifier).refreshCurrentPage();
      
      // Jeśli wolałbyś skakać do ostatniej strony (bo tam dodał się element),
      // odkomentuj metodę w providerze i użyj tutaj:
      // await _ref.read(sentencesProvider.notifier).goToLastPage();

      state = const AsyncValue.data(null);
      return true;
    } catch (e, stack) {
      // 4. Błąd
      state = AsyncValue.error(e, stack);
      return false;
    }
  }
}

// Rejestracja providera
final addSentenceControllerProvider = 
    StateNotifierProvider<AddSentenceController, AsyncValue<void>>((ref) {
  final repo = ref.watch(sentencesRepositoryProvider);
  return AddSentenceController(repo, ref);
});


===============================
Ścieżka do pliku: ./lib/features/sentences/presentation/edit_sentence_controller.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/sentence_update_model.dart';
import '../data/sentences_repository.dart';
import 'sentences_provider.dart';

// Używamy StateNotifier do zarządzania stanem asynchronicznym (loading/error/data)
// AsyncValue<void> informuje UI czy trwa zapisywanie.
class EditSentenceController extends StateNotifier<AsyncValue<void>> {
  final SentencesRepository _repository;
  final Ref _ref;

  EditSentenceController(this._repository, this._ref) 
      : super(const AsyncValue.data(null));

  Future<bool> editSentence({
    required int id,
    required String sentence,
    required String language,
    required String translation,
  }) async {
    state = const AsyncValue.loading(); // Pokaż spinner

    try {
      final dto = SentenceUpdate(
        sentence: sentence,
        language: language,
        translation: translation,
      );

      // 1. Wywołanie API
      final updatedSentence = await _repository.updateSentence(id: id, data: dto);

      // 2. Aktualizacja lokalnego stanu listy (nie musimy odświeżać całej strony!)
      _ref.read(sentencesProvider.notifier).updateSentenceLocally(updatedSentence);

      state = const AsyncValue.data(null); // Sukces
      return true;
    } catch (e, stack) {
      state = AsyncValue.error(e, stack); // Błąd
      return false;
    }
  }
}

final editSentenceControllerProvider = 
    StateNotifierProvider<EditSentenceController, AsyncValue<void>>((ref) {
  final repo = ref.watch(sentencesRepositoryProvider);
  return EditSentenceController(repo, ref);
});


===============================
Ścieżka do pliku: ./lib/features/sentences/presentation/edit_sentence_dialog.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/sentence_model.dart';
import 'edit_sentence_controller.dart';
import '../../../core/app_sizes.dart';

class EditSentenceDialog extends ConsumerStatefulWidget {
  final Sentence sentence; // Przyjmujemy obiekt do edycji

  const EditSentenceDialog({super.key, required this.sentence});

  @override
  ConsumerState<EditSentenceDialog> createState() => _EditSentenceDialogState();
}

class _EditSentenceDialogState extends ConsumerState<EditSentenceDialog> {
  final _formKey = GlobalKey<FormState>();
  
  // Kontrolery
  late TextEditingController _sentenceController;
  late TextEditingController _translationController;
  late TextEditingController _languageController;

  @override
  void initState() {
    super.initState();
    // Inicjalizujemy kontrolery wartościami z obiektu przekazanego w konstruktorze
    _sentenceController = TextEditingController(text: widget.sentence.sentence);
    _translationController = TextEditingController(text: widget.sentence.translation);
    _languageController = TextEditingController(text: widget.sentence.language);
  }

  @override
  void dispose() {
    _sentenceController.dispose();
    _translationController.dispose();
    _languageController.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;

    // Pobieramy notifiera kontrolera
    final controller = ref.read(editSentenceControllerProvider.notifier);

    final success = await controller.editSentence(
      id: widget.sentence.id,
      sentence: _sentenceController.text,
      translation: _translationController.text,
      language: _languageController.text,
    );

    // Sprawdzamy mounted zanim użyjemy contextu po await (C++ safety rule!)
    if (success && mounted) {
      Navigator.of(context).pop(); // Zamykamy dialog
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Zaktualizowano zdanie'),
          behavior: SnackBarBehavior.floating, // Wygląda lepiej
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final asyncState = ref.watch(editSentenceControllerProvider);
    final isLoading = asyncState.isLoading;

    return Dialog(
      // Dialog zamiast AlertDialog, żeby mieć większą kontrolę nad layoutem
      insetPadding: const EdgeInsets.all(16),
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: AppSizes.maxMobileWidth*0.9), // Max szerokość na tabletach
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisSize: MainAxisSize.min, // Dialog zajmie tyle ile trzeba
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Text(
                  "Edytuj zdanie #${widget.sentence.id}",
                  style: Theme.of(context).textTheme.headlineSmall,
                ),
                const SizedBox(height: 24),
                
                // Obsługa błędu
                if (asyncState.hasError)
                  Container(
                    padding: const EdgeInsets.all(8),
                    margin: const EdgeInsets.only(bottom: 16),
                    decoration: BoxDecoration(
                      color: Colors.red.shade50,
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(color: Colors.red.shade200),
                    ),
                    child: Text(
                      'Błąd: ${asyncState.error}',
                      style: TextStyle(color: Colors.red.shade800),
                    ),
                  ),

                // Lista pól w Flexible/ScrollView na wypadek małego ekranu/klawiatury
                Flexible(
                  child: SingleChildScrollView(
                    child: Column(
                      children: [
                        TextFormField(
                          controller: _sentenceController,
                          decoration: const InputDecoration(
                            labelText: 'Oryginał',
                            border: OutlineInputBorder(),
                            alignLabelWithHint: true, // Ważne przy multiline
                          ),
                          enabled: !isLoading,
                          minLines: 3, // Domyślnie wysokie na 3 linie
                          maxLines: null, // Rozszerza się w nieskończoność
                          keyboardType: TextInputType.multiline,
                          //validator: (v) => v!.isEmpty ? 'Pole wymagane' : null,
                        ),
                        const SizedBox(height: 16),
                        
                        TextFormField(
                          controller: _translationController,
                          decoration: const InputDecoration(
                            labelText: 'Tłumaczenie',
                            border: OutlineInputBorder(),
                            alignLabelWithHint: true,
                          ),
                          enabled: !isLoading,
                          minLines: 2,
                          maxLines: null,
                          keyboardType: TextInputType.multiline,
                          //validator: (v) => v!.isEmpty ? 'Pole wymagane' : null,
                        ),
                        const SizedBox(height: 16),
                        
                        // --- ZMIANA: Zwykły Label informacyjny ---
                        // Zamiast pola tekstowego pokazujemy po prostu informację
                        Padding(
                          padding: const EdgeInsets.only(left: 4.0), // Lekkie wcięcie, żeby zrównać z labelami inputów
                          child: Row(
                            children: [
                              const Icon(Icons.language, color: Colors.grey, size: 20),
                              const SizedBox(width: 8),
                              Text(
                                'Język: ',
                                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                                  color: Colors.grey[700],
                                ),
                              ),
                              Container(
                                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                                decoration: BoxDecoration(
                                  color: Theme.of(context).brightness == Brightness.light 
                                      ? Colors.grey.shade200 
                                      : Colors.grey.shade700,
                                  borderRadius: BorderRadius.circular(4),
                                ),
                                child: Text(
                                  widget.sentence.language.toUpperCase(),
                                  style: const TextStyle(fontWeight: FontWeight.bold),
                                ),
                              ),
                            ],
                          ),
                        ),

                        /* 
                        // --- Oryginalna wersja edycyjna (zakomentowana) ---
                        TextFormField(
                          controller: _languageController,
                          decoration: const InputDecoration(
                            labelText: 'Język',
                            border: OutlineInputBorder(),
                            helperText: 'Kod języka, np. en, de, es', //ISO 639-1 
                          ),
                          enabled: !isLoading,
                          //validator: (v) => v!.isEmpty ? 'Pole wymagane' : null,
                        ),
                        */
                      ],
                    ),
                  ),
                ),
                
                const SizedBox(height: 24),
                
                // Przyciski akcji
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    TextButton(
                      onPressed: isLoading ? null : () => Navigator.of(context).pop(),
                      child: const Text('Anuluj'),
                    ),
                    const SizedBox(width: 8),
                    FilledButton( // FilledButton to nowy standard Material 3 (zamiast ElevatedButton)
                      onPressed: isLoading ? null : _submit,
                      child: isLoading
                          ? const SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Text('Zapisz zmiany'),
                    ),
                  ],
                )
              ],
            ),
          ),
        ),
      ),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/sentences/presentation/sentences_provider.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/sentence_model.dart';
import '../data/sentences_repository.dart';
import '../../../core/network/api_error_handler.dart';

class SentencesState {
  final List<Sentence> sentences;
  final bool isLoading;
  final String? errorMessage;
  final int currentPage;
  final int totalPages;

  const SentencesState({
    this.sentences = const [],
    this.isLoading = false,
    this.errorMessage,
    this.currentPage = 1,
    this.totalPages = 1,
  });

  bool get isLastPage => currentPage >= totalPages;

  SentencesState copyWith({
    List<Sentence>? sentences,
    bool? isLoading,
    String? errorMessage,
    int? currentPage,
    int? totalPages,
  }) {
    return SentencesState(
      sentences: sentences ?? this.sentences,
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage,
      currentPage: currentPage ?? this.currentPage,
      totalPages: totalPages ?? this.totalPages,
    );
  }
}

class SentencesNotifier extends StateNotifier<SentencesState> {
  final SentencesRepository _repository;
  static const int _perPage = 10;

  SentencesNotifier(this._repository) : super(const SentencesState()) {
    loadSentences(page: 1);
  }

  Future<void> loadSentences({required int page}) async {
    if (state.isLoading) return;

    // Resetujemy błąd przy nowej próbie
    state = state.copyWith(isLoading: true, errorMessage: null);

    try {
      final response = await _repository.getSentences(
        page: page,
        perPage: _perPage,
      );

      state = state.copyWith(
        isLoading: false,
        sentences: response.sentences,
        totalPages: response.totalPages,
        currentPage: page,
        errorMessage: null, // Sukces = brak błędu
      );
    } catch (e) {
      // TU JEST ZMIANA: Używamy naszego parsera błędów
      final friendlyMessage = ApiErrorHandler.getErrorMessage(e);

      state = state.copyWith(isLoading: false, errorMessage: friendlyMessage);
    }
  }

  // --- NOWA METODA ---
  // Odświeża aktualną stronę bez resetowania stanu do zera
  Future<void> refreshCurrentPage() async {
    // Ładujemy ponownie tę samą stronę, na której jesteśmy
    await loadSentences(page: state.currentPage);
  }

  /* 
  // Opcjonalnie: Jeśli wolałbyś iść na ostatnią stronę po dodaniu:
  Future<void> goToLastPage() async {
     // Najpierw pobierzmy info (może doszła nowa strona?)
     // To uproszczenie, w idealnym świecie API po dodaniu zwraca ID nowej strony
     await loadSentences(page: state.totalPages);
  }
  */

  void nextPage() {
    if (!state.isLastPage) {
      loadSentences(page: state.currentPage + 1);
    }
  }

  void previousPage() {
    if (state.currentPage > 1) {
      loadSentences(page: state.currentPage - 1);
    }
  }

  // Usuwa element z lokalnego stanu (UI odświeży się natychmiast)
  void removeSentenceLocally(int sentenceId) {
    // std::remove_if w C++ style
    final updatedList = state.sentences
        .where((s) => s.id != sentenceId)
        .toList();

    state = state.copyWith(
      sentences: updatedList,
      // Opcjonalnie: można tu obsłużyć zmniejszenie licznika stron itp.
    );
  }

  void updateSentenceLocally(Sentence updatedSentence) {
    // Tworzymy nową listę, mapując starą
    final newSentences = state.sentences.map((s) {
      return s.id == updatedSentence.id ? updatedSentence : s;
    }).toList();

    // Emitujemy nowy stan
    state = state.copyWith(sentences: newSentences);
  }
}

final sentencesProvider =
    StateNotifierProvider<SentencesNotifier, SentencesState>((ref) {
      final repository = ref.watch(sentencesRepositoryProvider);
      return SentencesNotifier(repository);
    });



===============================
Ścieżka do pliku: ./lib/features/sentences/presentation/add_sentence_dialog.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'add_sentence_controller.dart';

class AddSentenceDialog extends ConsumerStatefulWidget {
  const AddSentenceDialog({super.key});

  @override
  ConsumerState<AddSentenceDialog> createState() => _AddSentenceDialogState();
}

class _AddSentenceDialogState extends ConsumerState<AddSentenceDialog> {
  final _formKey = GlobalKey<FormState>();
  
  final _sentenceController = TextEditingController();
  final _translationController = TextEditingController();

  @override
  void dispose() {
    _sentenceController.dispose();
    _translationController.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    // Przed wysłaniem warto upewnić się, że formularz jest poprawny
    if (_formKey.currentState!.validate()) {
      final success = await ref.read(addSentenceControllerProvider.notifier).addSentence(
            sentence: _sentenceController.text, // Może być pusty string
            language: 'en',
            translation: _translationController.text, // Może być pusty string
          );

      if (success && mounted) {
        Navigator.of(context).pop();
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Dodano nowe zdanie!')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final asyncState = ref.watch(addSentenceControllerProvider);
    final isLoading = asyncState.isLoading;

    return AlertDialog(
      title: const Text('Dodaj nowe zdanie'),
      content: SingleChildScrollView(
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (asyncState.hasError)
                Padding(
                  padding: const EdgeInsets.only(bottom: 10),
                  child: Text(
                    'Błąd: ${asyncState.error}',
                    style: const TextStyle(color: Colors.red, fontSize: 12),
                  ),
                ),
                
              TextFormField(
                controller: _sentenceController,
                decoration: const InputDecoration(labelText: 'Zdanie (np. Witaj Świecie)'),
                enabled: !isLoading,
                // ZMIANA TUTAJ:
                validator: (value) {
                  // Sprawdzamy, czy aktualne pole jest puste ORAZ czy drugie pole jest puste
                  if ((value == null || value.isEmpty) && _translationController.text.isEmpty) {
                    return 'Wypełnij zdanie LUB tłumaczenie';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 10),
              TextFormField(
                controller: _translationController,
                decoration: const InputDecoration(labelText: 'Tłumaczenie (np. Hello World)'),
                enabled: !isLoading,
                // ZMIANA TUTAJ:
                validator: (value) {
                  // To samo sprawdzenie w drugą stronę
                  if ((value == null || value.isEmpty) && _sentenceController.text.isEmpty) {
                    return 'Wypełnij zdanie LUB tłumaczenie';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              // --- ZMIANA: Skopiowany wygląd z EditSentenceDialog ---
              // Zastąpiono TextFormField statycznym, ładnym wskaźnikiem języka
              Padding(
                padding: const EdgeInsets.only(left: 4.0),
                child: Row(
                  children: [
                    const Icon(Icons.language, color: Colors.grey, size: 20),
                    const SizedBox(width: 8),
                    Text(
                      'Język: ',
                      style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Colors.grey[700],
                      ),
                    ),
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                      decoration: BoxDecoration(
                        color: Theme.of(context).brightness == Brightness.light 
                            ? Colors.grey.shade200 
                            : Colors.grey.shade700,
                        borderRadius: BorderRadius.circular(4),
                      ),
                      child: const Text(
                        'EN', // ZMIANA: Ustawione na sztywno
                        style: TextStyle(fontWeight: FontWeight.bold),
                      ),
                    ),
                  ],
                ),
              ),
              // --- KONIEC ZMIANY ---
            ],
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: isLoading ? null : () => Navigator.of(context).pop(),
          child: const Text('Anuluj'),
        ),
        ElevatedButton(
          onPressed: isLoading ? null : _submit,
          child: isLoading 
              ? const SizedBox(
                  width: 20, 
                  height: 20, 
                  child: CircularProgressIndicator(strokeWidth: 2)
                ) 
              : const Text('Zapisz'),
        ),
      ],
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/sentences/presentation/widgets/sentence_tile.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/sentence_model.dart';
import '../delete_sentence_controller.dart';
import '../edit_sentence_dialog.dart';

class SentenceTile extends ConsumerWidget {
  final Sentence sentence;

  const SentenceTile({super.key, required this.sentence});

  void _showDeleteConfirmation(BuildContext context, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text("Potwierdzenie"),
        content: const Text("Usunąć to zdanie?"),
        actions: [
          // Przycisk "Nie"
          TextButton(
            onPressed: () {
              Navigator.of(ctx).pop(); // Zamknij dialog
            },
            child: const Text("Nie"),
          ),
          // Przycisk "Tak" - Czerwony
          TextButton(
            onPressed: () {
              // 1. Najpierw zamykamy dialog
              Navigator.of(ctx).pop();

              // 2. Delegujemy operację do kontrolera
              ref
                  .read(deleteSentenceControllerProvider)
                  .deleteSentence(context: context, sentenceId: sentence.id);
            },
            style: TextButton.styleFrom(
              foregroundColor: Colors.red, // Czerwony tekst
            ),
            child: const Text("Tak"),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 4),
      elevation: 2,
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: Colors.teal,
          foregroundColor: Colors.white,
          child: Text(sentence.id.toString()),
        ),
        title: Text(
          sentence.sentence,
          style: const TextStyle(fontWeight: FontWeight.bold),
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const SizedBox(height: 4),
            Text(
              sentence.translation,
              style: const TextStyle(
                fontStyle: FontStyle.italic,
                color: Colors.black87,
              ),
            ),
            const SizedBox(height: 4),
            Row(
              children: [
                Icon(Icons.language, size: 14, color: Colors.grey[600]),
                const SizedBox(width: 4),
                Text(
                  sentence.language,
                  style: TextStyle(color: Colors.grey[600], fontSize: 12),
                ),
              ],
            ),
          ],
        ),
        isThreeLine: true,

        // --- SEKCJA TRAILING (POPRAWIONA) ---
        // Używamy FittedBox, aby uniknąć błędu "Bottom overflowed"
        trailing: FittedBox(
          fit: BoxFit.scaleDown, // Skaluje w dół, jeśli brakuje miejsca
          alignment: Alignment.centerRight,
          child: Column(
            mainAxisSize: MainAxisSize.min, // Zajmuje tylko tyle miejsca ile trzeba
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // 1. Ikona USUWANIA (Czerwona)
              IconButton(
                icon: const Icon(Icons.delete_outline, color: Colors.red),
                onPressed: () => _showDeleteConfirmation(context, ref),
                tooltip: 'Usuń zdanie',
                // Ustawienia kompaktowe:
                padding: EdgeInsets.zero,
                constraints: const BoxConstraints(),
                iconSize: 32, // Lekko mniejsza ikona dla bezpieczeństwa
              ),
              
              const SizedBox(height: 8), // Mniejszy odstęp (było 12, teraz 8)

              // 2. Ikona EDYCJI (Niebieska)
              IconButton(
                icon: const Icon(Icons.edit, color: Colors.blue),
                onPressed: () {
                   // TODO: Tu logika edycji
                   debugPrint("Kliknięto edycję id: ${sentence.id}");
                   showDialog(
                     context: context,
                     builder: (context) => EditSentenceDialog(sentence: sentence),
                   );
                },
                tooltip: 'Edytuj zdanie',
                padding: EdgeInsets.zero,
                constraints: const BoxConstraints(),
                iconSize: 32,
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/sentences/data/sentence_create_model.dart

Zawartość pliku:

class SentenceCreate {
  final String sentence;
  final String language;
  final String translation;

  const SentenceCreate({
    required this.sentence,
    required this.language,
    required this.translation,
  });

  // Metoda toJson konwertuje obiekt na Mapę, którą Dio zamieni na JSON.
  // W C++ to byłaby metoda serializująca do QJsonObject.
  Map<String, dynamic> toJson() {
    return {
      'sentence': sentence,
      'language': language,
      'translation': translation,
    };
  }
}


===============================
Ścieżka do pliku: ./lib/features/sentences/data/sentence_model.dart

Zawartość pliku:

import 'package:equatable/equatable.dart';

// Equatable pozwala porównywać obiekty po wartościach pól, a nie referencji w pamięci.
// To jak przeładowanie operatora == w C++.
class Sentence extends Equatable {
  final int id;
  final String sentence;
  final String language;
  final String translation;
  // created_at przychodzi jako string, w prawdziwym projekcie parsujemy to na DateTime
  final String createdAt; 

  const Sentence({
    required this.id,
    required this.sentence,
    required this.language,
    required this.translation,
    required this.createdAt,
  });

  // Factory constructor - w C++ to byłaby statyczna metoda "createFromJson"
  factory Sentence.fromJson(Map<String, dynamic> json) {
    return Sentence(
      id: json['id'] as int,
      sentence: json['sentence'] as String,
      language: json['language'] as String,
      translation: json['translation'] as String,
      createdAt: json['created_at'] as String,
    );
  }

  @override
  List<Object?> get props => [id, sentence, language, translation, createdAt];
}


===============================
Ścieżka do pliku: ./lib/features/sentences/data/sentences_repository.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/network/dio_provider.dart';
import 'sentence_model.dart';
import 'sentence_create_model.dart';
import 'sentence_update_model.dart';

// Prosta klasa (jak struct w C++) do przekazania danych z API do Providera
class SentencesResponse {
  final List<Sentence> sentences;
  final int totalPages;

  SentencesResponse(this.sentences, this.totalPages);
}

final sentencesRepositoryProvider = Provider<SentencesRepository>((ref) {
  final dio = ref.watch(dioProvider);
  return SentencesRepository(dio);
});

class SentencesRepository {
  final Dio _dio;

  SentencesRepository(this._dio);

  // Zmieniamy typ zwracany na naszą strukturę SentencesResponse
  Future<SentencesResponse> getSentences({required int page, int perPage = 10}) async {
    try {
      final response = await _dio.get(
        '/api/sentences/',
        queryParameters: {
          'page': page,
          'per_page': perPage,
        },
      );

      // 1. Odbieramy główny obiekt JSON (Map<String, dynamic>)
      final Map<String, dynamic> json = response.data;

      // 2. Wyciągamy listę z klucza "data"
      final List<dynamic> rawList = json['data'];
      
      // 3. Wyciągamy liczbę stron z klucza "total_pages"
      final int totalPages = json['total_pages'] ?? 1; // domyślnie 1 jakby api nie dało

      // 4. Mapujemy listę
      final sentences = rawList.map((e) => Sentence.fromJson(e)).toList();

      // Zwracamy komplet danych
      return SentencesResponse(sentences, totalPages);

    } catch (e) {
      rethrow;
    }
  }

  Future<void> createSentence(SentenceCreate data) async {
    try {
      // Dio automatycznie zserializuje Mapę zwróconą przez data.toJson()
      await _dio.post(
        '/api/sentences/',
        data: data.toJson(),
      );
    } catch (e) {
      rethrow;
    }
  }

  Future<void> deleteSentence(int id) async {
    try {
      // Endpoint: DELETE /api/sentences/{sentence_id}
      await _dio.delete('/api/sentences/$id');
    } catch (e) {
      rethrow;
    }
  }

  Future<Sentence> updateSentence({
    required int id,
    required SentenceUpdate data,
  }) async {
    try {
      final response = await _dio.put(
        '/api/sentences/$id',
        data: data.toJson(),
      );
      
      // API zwraca zaktualizowany obiekt Sentence (według dokumnetacji)
      // Od razu go parsujemy i zwracamy wyżej.
      return Sentence.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }

}


===============================
Ścieżka do pliku: ./lib/features/sentences/data/sentence_update_model.dart

Zawartość pliku:

class SentenceUpdate {
  // W API te pola są 'anyOf string/null', więc tutaj String?
  final String? sentence;
  final String? language;
  final String? translation;

  const SentenceUpdate({
    this.sentence,
    this.language,
    this.translation,
  });

  Map<String, dynamic> toJson() {
    // Serializujemy tylko te pola, które nie są nullem (chociaż w edycji wyślemy wszystkie)
    return {
      if (sentence != null) 'sentence': sentence,
      if (language != null) 'language': language,
      if (translation != null) 'translation': translation,
    };
  }
}


===============================
Ścieżka do pliku: ./lib/core/app_sizes.dart

Zawartość pliku:

class AppSizes{
  static const double maxMobileWidth = 550.0;
}


===============================
Ścieżka do pliku: ./lib/core/navigation_provider.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';

final navigationIndexProvider = StateProvider<int>((ref) => 0);


===============================
Ścieżka do pliku: ./lib/core/config/api_config.dart

Zawartość pliku:

class ApiConfig {
  // Unikamy instancjonowania tej klasy
  ApiConfig._();

  // Adresy bazowe dla środowiska DEV
  // W przyszłości można tu dodać logikę do przełączania na PROD
  static const String authBaseUrl = 'https://dev-auth.rafal-kruszyna.org';
  static const String sentencesBaseUrl = 'https://dev-sentences.rafal-kruszyna.org';
  static const String captchaBaseUrl = 'https://dev-captcha.rafal-kruszyna.org';
  
  // Timeouty
  static const Duration connectTimeout = Duration(seconds: 10);
  static const Duration receiveTimeout = Duration(seconds: 10);
}


===============================
Ścieżka do pliku: ./lib/core/widgets/main_drawer.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import "../../features/auth/presentation/controllers/auth_controller.dart";
import '../navigation_provider.dart';

class MainDrawer extends ConsumerWidget {
  const MainDrawer({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedIndex = ref.watch(navigationIndexProvider);
    // Obserwujemy stan autentykacji
    final authState = ref.watch(authControllerProvider);
    final isLoggedIn = authState.isAuthenticated;

    return Drawer(
      child: ListView(
        padding: EdgeInsets.zero,
        children: [
          DrawerHeader(
            decoration: BoxDecoration(color: Colors.deepPurple),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                Text(
                  'English Learner',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  isLoggedIn ? 'Witaj, użytkowniku!' : 'Tryb Gościa',
                  style: const TextStyle(color: Colors.white70, fontSize: 14),
                ),
                Text(
                  'Twój postęp: 45%',
                  style: TextStyle(color: Colors.white70, fontSize: 14),
                ),
              ],
            ),
          ),
          _DrawerTile(
            title: 'Ogłoszenia parafialne',
            icon: Icons.home,
            index: 0,
            isSelected: selectedIndex == 0,
          ),
          _DrawerTile(
            title: 'Slownik',
            icon: Icons.menu_book,
            index: 1,
            isSelected: selectedIndex == 1,
          ),
          _DrawerTile(
            title: 'Slowka',
            icon: Icons.school,
            index: 2,
            isSelected: selectedIndex == 2,
          ),
          _DrawerTile(
            title: 'Zwroty',
            icon: Icons.chat,
            index: 3,
            isSelected: selectedIndex == 3,
          ),
          _DrawerTile(
            title: 'Rejestracja',
            icon: Icons.chat,
            index: 4,
            isSelected: selectedIndex == 4,
          ),
          _DrawerTile(
            title: 'Logowanie',
            icon: Icons.login,
            index: 5,
            isSelected: selectedIndex == 5,
          ),
          const Divider(),
          const Padding(
            padding: EdgeInsets.only(left: 16, top: 8, bottom: 8),
            child: Text(
              "DEV TOOLS",
              style: TextStyle(color: Colors.grey, fontSize: 12),
            ),
          ),
          _DrawerTile(
            title: 'Test',
            icon: Icons.quiz,
            index: 6,
            isSelected: selectedIndex == 6,
          ),
          _DrawerTile(
            title: 'Health Check',
            icon: Icons.dns,
            index: 7,
            isSelected: selectedIndex == 7,
          ),
          _DrawerTile(
            title: 'Captcha Test',
            icon: Icons.security,
            index: 8,
            isSelected: selectedIndex == 8,
          ),
        ],
      ),
    );
  }
}

// _DrawerTile pozostaje bez zmian jak w Twoim pliku
class _DrawerTile extends ConsumerWidget {
  final String title;
  final IconData icon;
  final int index;
  final bool isSelected;

  const _DrawerTile({
    required this.title,
    required this.icon,
    required this.index,
    required this.isSelected,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ListTile(
      leading: Icon(icon, color: isSelected ? Colors.deepPurple : null),
      title: Text(
        title,
        style: TextStyle(
          color: isSelected ? Colors.deepPurple : null,
          fontWeight: isSelected ? FontWeight.bold : null,
        ),
      ),
      selected: isSelected,
      selectedTileColor: Colors.deepPurple.withValues(alpha: 0.1),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      onTap: () {
        ref.read(navigationIndexProvider.notifier).state = index;
        Navigator.pop(context);
      },
    );
  }
}



===============================
Ścieżka do pliku: ./lib/core/network/auth_interceptor_provider.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../features/auth/data/token_storage.dart';

// Provider zwracający skonfigurowany Interceptor
final authInterceptorProvider = Provider<Interceptor>((ref) {
  final storage = ref.watch(tokenStorageProvider);
  return AuthInterceptor(storage);
});

class AuthInterceptor extends Interceptor {
  final TokenStorage _storage;

  AuthInterceptor(this._storage);

  @override
  Future<void> onRequest(RequestOptions options, RequestInterceptorHandler handler) async {
    // Pobierz token
    final token = await _storage.getToken();

    // Dodaj nagłówek jeśli token istnieje
    if (token != null) {
      options.headers['Authorization'] = 'Bearer ${token.accessToken}';
    }

    return handler.next(options);
  }

  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    // Tu w przyszłości dodasz logikę odświeżania tokena (Refresh Token)
    // jeśli err.response?.statusCode == 401
    return handler.next(err);
  }
}


===============================
Ścieżka do pliku: ./lib/core/network/dio_provider.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/api_config.dart'; // Import configu
import 'auth_interceptor_provider.dart'; // Import interceptora

final dioProvider = Provider<Dio>((ref) {
  final dio = Dio(BaseOptions(
    baseUrl: ApiConfig.sentencesBaseUrl, // Adres mikroserwisu zdań
    connectTimeout: ApiConfig.connectTimeout,
    receiveTimeout: ApiConfig.receiveTimeout,
  ));

  // Używamy tego samego interceptora co w authDioProvider (DRY!)
  final authInterceptor = ref.watch(authInterceptorProvider);
  dio.interceptors.add(authInterceptor);

  return dio;
});


===============================
Ścieżka do pliku: ./lib/core/network/api_error_handler.dart

Zawartość pliku:

import 'package:dio/dio.dart';

class ApiErrorHandler {
  static String getErrorMessage(Object error) {
    if (error is DioException) {
      switch (error.type) {
        case DioExceptionType.connectionTimeout:
        case DioExceptionType.sendTimeout:
        case DioExceptionType.receiveTimeout:
          return "Upłynął limit czasu połączenia. Sprawdź internet.";

        case DioExceptionType.badResponse:
          return _handleBadResponse(error.response);

        case DioExceptionType.connectionError:
          return "Brak połączenia z serwerem. Sprawdź internet.";

        case DioExceptionType.cancel:
          return "Żądanie zostało anulowane.";

        default:
          return "Wystąpił nieznany błąd sieciowy.";
      }
    } else {
      return "Wystąpił niespodziewany błąd: ${error.toString()}";
    }
  }

  static String _handleBadResponse(Response? response) {
    if (response == null) return "Nieznany błąd serwera.";

    final dynamic data = response.data;
    final int? statusCode = response.statusCode;

    // KROK 1: Sprawdź, czy serwer przysłał konkretny komunikat błędu.
    if (data is Map) {
      // Obsługa błędu 422 (FastAPI Validation Error)
      if (statusCode == 422 && data['detail'] is List) {
        final list = data['detail'] as List;
        if (list.isNotEmpty && list.first is Map) {
          final firstMsg = list.first['msg'];

          // --- POPRAWKA TUTAJ ---
          // Musimy przetłumaczyć wiadomość wyciągniętą z listy!
          final translatedMsg = _translateMessage(firstMsg.toString());

          return "Błąd walidacji: $translatedMsg";
        }
      }

      // Standardowa obsługa (400, 401, 409...) - detail to String
      if (data['detail'] != null && data['detail'] is String) {
        return _translateMessage(data['detail']);
      }
    }

    // KROK 2: Fallback (Estymacja po kodzie)
    switch (statusCode) {
      case 400:
        return "Nieprawidłowe żądanie (400).";
      case 401:
        return "Błąd autentykacji. Zaloguj się ponownie.";
      case 403:
        return "Brak dostępu do zasobu.";
      case 404:
        return "Nie znaleziono zasobu (404).";
      case 409:
        return "Konflikt danych (409).";
      case 429:
        return "Zbyt wiele zapytań. Zwolnij chwilę.";
      case 500:
      case 502:
        return "Błąd serwera ($statusCode). Spróbuj później.";
      case 503:
        return "Serwer jest niedostępny (Trwają prace techniczne lub przeciążenie).";
      default:
        return "Wystąpił błąd ($statusCode).";
    }
  }

  static String _translateMessage(String msg) {
    // Prosty słownik tłumaczeń najczęstszych błędów z backendu

    // --- NOWE TŁUMACZENIA DLA USERNAME (Auth Service) ---
    if (msg.contains("Username must be at least 3 characters long")) {
      return "Nazwa użytkownika musi mieć co najmniej 3 znaki.";
    }
    if (msg.contains("Username cannot be longer than 30 characters")) {
      return "Nazwa użytkownika nie może mieć więcej niż 30 znaków.";
    }
    if (msg.contains("Username can only contain letters, numbers")) {
      return "Nazwa użytkownika może zawierać tylko litery, cyfry, podkreślenia (_) i myślniki (-).";
    }
    if (msg.contains("This username is reserved")) {
      return "Ta nazwa użytkownika jest zastrzeżona i nie może zostać użyta.";
    }
    if (msg.contains("Username cannot contain '@' symbol")) {
      return "Nazwa użytkownika nie może zawierać znaku '@'.";
    }
    if (msg.contains("consecutive underscores or hyphens")) {
      return "Nazwa użytkownika nie może zawierać podwójnych podkreśleń lub myślników.";
    }
    // ----------------------------------------------------

    if (msg.contains("User with this email already exists")) {
      return "Użytkownik o tym adresie email już istnieje.";
    }
    if (msg.contains("User with this username already exists")) {
      return "Ta nazwa użytkownika jest już zajęta.";
    }
    if (msg.contains("Username already taken")) {
      return "Ta nazwa użytkownika jest już zajęta.";
    }
    if (msg.contains("Incorrect email or password")) {
      return "Niepoprawny email lub hasło.";
    }
    if (msg.contains("Inactive user")) {
      return "Konto jest nieaktywne.";
    }
    if (msg.contains("Invalid captcha")) {
      return "Niepoprawny kod Captcha.";
    }
    if (msg.contains("Invalid CAPTCHA answer")) {
      return "Niepoprawny kod Captcha.";
    }
    if (msg.contains("Email already registered")) {
      return "Ten adres email jest już zarejestrowany.";
    }
    if (msg.contains("value is not a valid email address")) {
      return "Niepoprawny format adresu email.";
    }
    if (msg.contains("Password must be at least 6 characters long")) {
      return "Hasło musi mieć co najmniej 6 znaków.";
    }
    if (msg.contains("Password must contain at least one digit")) {
      return "Hasło musi zawierać co najmniej jedną cyfrę.";
    }
    if (msg.contains("Password must contain at least one letter")) {
      return "Hasło musi zawierać co najmniej jedną literę.";
    }
    if (msg.contains("String should have at least 6 characters")) {
      return "Wartość jest za krótka (wymagane min. 6 znaków).";
    }
    //auth service error
    if(msg.contains("Database error: Resource is locked. Service temporarily unavailable.")){
      return "Serwis jest chwilowo zajęty (baza danych zablokowana). Spróbuj ponownie za chwilę.";
    }
    //auth service error
    if(msg.contains("Database error: Internal operation failed.")){
      return "Wystąpił wewnętrzny błąd bazy danych. Spróbuj ponownie.";
    }

    // Jeśli nie mamy tłumaczenia, zwracamy oryginał (np. "Password is too short")
    return msg;
  }
}


