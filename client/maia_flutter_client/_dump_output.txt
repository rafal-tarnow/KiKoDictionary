===============================
Ścieżka do pliku: ./lib/app.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:maia_flutter_client/features/auth/presentation/forgot_password_page.dart';
import 'package:maia_flutter_client/features/auth/presentation/login_page.dart';
import 'package:maia_flutter_client/features/auth/presentation/register_page.dart';
import 'package:maia_flutter_client/features/auth/presentation/widgets/user_avatar_button.dart';
import 'core/navigation_provider.dart';
import 'core/widgets/main_drawer.dart';
import 'features/home/home_page.dart';
import 'features/home/home_app_bar.dart';
import 'features/dictionary/dictionary_page.dart';
import 'features/words/words_page.dart';
import 'features/sentences/sentences_page.dart';
import 'features/sentences/sentences_app_bar.dart';
import 'features/test/test_page.dart';
import 'features/test/test_app_bar.dart';
import 'core/app_sizes.dart'; // Import stałych
import 'features/health/services_health_page.dart';
import 'features/settings/presentation/settings_page.dart';
import 'features/captcha/captcha_page.dart';

class MainShell extends ConsumerWidget {
  const MainShell({super.key});

  static const List<Widget> _pages = [
    HomePage(),
    DictionaryPage(),
    WordsPage(),
    SentencesPage(),
    RegisterPage(),
    LoginPage(),
    //Dev Tools Pages
    TestPage(),
    ServicesHealthPage(),
    CaptchaPage(),
    //Pages not shown in the Drawer
    ForgotPasswordPage(),
    SettingsPage(),
  ];

  static final List<PreferredSizeWidget> _appBars = [
    const HomeAppBar(),
    AppBar(
      title: const Text("Dictionary"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    AppBar(
      title: const Text("Words"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    const SentencesAppBar(),
    AppBar(
      title: const Text("Rejestracja"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    AppBar(
      title: const Text("Logowanie"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    const TestAppBar(),
    AppBar(
      title: const Text("Health Check"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    AppBar(
      title: const Text("Captcha Demo"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    AppBar(
      title: const Text("Reset hasła"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    AppBar(
      title: const Text("Ustawienia"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
  ];

  // static const List<String> _titles = [
  //   'Ogłoszenia parafialne',
  //   'Dictionary',
  //   'Words',
  //   'Sentences',
  //   'Test',
  //   'Health Check',
  // ];

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedIndex = ref.watch(navigationIndexProvider);

    return Container(
      //szare tło aplikacji
      // Zamieniamy surfaceVariant na surfaceContainerHighest
      color: const Color(0xFFE0E0E0),
      // color: Theme.of(
      //   context,
      // ).colorScheme.surfaceContainer,
      //color: const Color(0xFFE0E0E0),
      // color: Theme.of(
      //   context,
      // ).colorScheme.surfaceContainerHighest.withOpacity(0.5),
      child: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: AppSizes.maxMobileWidth),
          child: Container(
            // Ten kontener dodaje cień i ogranicza Scaffold
            decoration: BoxDecoration(
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withValues(alpha: 0.05),
                  blurRadius: 10,
                ),
              ],
            ),
            child: ClipRect(
              //ClipRect jest potrzebny bo inaczej boczny Drawer rysuje sie poza oknem aplikacji w widoku np na tablecie, dlatego trzeba przyciac Drawer do glownego słupka aplikacji
              child: Scaffold(
                //backgroundColor: Theme.of(context).colorScheme.surface,
                backgroundColor: const Color(0xFFFFFFFF),
                appBar: _appBars[selectedIndex],
                // appBar: AppBar(
                //   title: Text(_titles[selectedIndex]),
                //   elevation: 2,
                // ),
                drawer: const MainDrawer(),
                //body: _pages[selectedIndex],
                body: IndexedStack(index: selectedIndex, children: _pages),
              ),
            ),
          ),
        ),
      ),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/main.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'app.dart';

void main() {
  // ProviderScope przechowuje stan wszystkich providerów
  runApp(const ProviderScope(child: MyApp()));
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'English Learning App',
      theme: ThemeData(
        //colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      home: const MainShell(),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/features/auth/presentation/login_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // Do AutofillHints
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:maia_flutter_client/core/navigation_provider.dart';
import 'controllers/login_controller.dart';

class LoginPage extends ConsumerStatefulWidget {
  const LoginPage({super.key});

  @override
  ConsumerState<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends ConsumerState<LoginPage> {
  final _formKey = GlobalKey<FormState>();

  // W UI nazywamy to _emailCtrl, żeby wiedzieć co wpisuje user,
  // ale do controllera przekażemy to jako "username" (zgodnie ze standardem OAuth2).
  final _emailCtrl = TextEditingController();
  final _passCtrl = TextEditingController();

  // Lokalny stan widoku (dla ukrywania hasła)
  bool _isPasswordVisible = false;

  @override
  void dispose() {
    _emailCtrl.dispose();
    _passCtrl.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    // 1. Walidacja formularza
    if (!_formKey.currentState!.validate()) return;

    // Ukryj klawiaturę (UX)
    FocusScope.of(context).unfocus();

    // Zapisz stan autofill (dla password managerów)
    TextInput.finishAutofillContext();

    // 2. Wywołanie logiki biznesowej
    // Używamy read, bo wykonujemy akcję jednorazową
    final success = await ref
        .read(loginControllerProvider.notifier)
        .login(_emailCtrl.text.trim(), _passCtrl.text);

    // 3. Obsługa wyniku (tylko nawigacja/sukces, błędy są w stanie authState)
    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Zalogowano pomyślnie!'),
          backgroundColor: Colors.green,
          behavior: SnackBarBehavior.floating,
        ),
      );

      // Przekierowanie na stronę główną (Index 0)
      ref.read(navigationIndexProvider.notifier).state = 0;
    }
  }

  @override
  Widget build(BuildContext context) {
    // ZMIANA: Obserwujemy tylko stan logowania (nie globalny auth)
    final loginState = ref.watch(loginControllerProvider);

    return Scaffold(
      // AppBar opcjonalny, zależy czy strona jest w Drawerze czy osobno
      // Tutaj zakładam, że będzie w MainShell, więc AppBar dostarczy shell.
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 400),
            child: Form(
              key: _formKey,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  // --- Nagłówek ---
                  const Icon(
                    Icons.lock_person_outlined,
                    size: 80,
                    color: Colors.deepPurple,
                  ),
                  const SizedBox(height: 24),
                  Text(
                    "Witaj ponownie!",
                    style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: Colors.black87,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    "Zaloguj się, aby kontynuować naukę.",
                    style: Theme.of(
                      context,
                    ).textTheme.bodyMedium?.copyWith(color: Colors.grey[600]),
                    textAlign: TextAlign.center,
                  ),

                  const SizedBox(height: 32),

                  // --- Email Field ---
                  TextFormField(
                    controller: _emailCtrl,
                    // Logika UI wymusza email
                    keyboardType: TextInputType.emailAddress,
                    autofillHints: const [AutofillHints.email],
                    decoration: const InputDecoration(
                      labelText: "Adres email",
                      prefixIcon: Icon(Icons.email_outlined),
                      border: OutlineInputBorder(),
                      hintText: "np. tom@example.com",
                    ),
                    textInputAction: TextInputAction.next, // Przycisk "Dalej"
                    enabled: !loginState.isLoading,
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Wpisz adres email';
                      }
                      // Walidacja formatu
                      if (!value.contains('@') || !value.contains('.')) {
                        return 'Niepoprawny format email';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // --- Password Field ---
                  TextFormField(
                    controller: _passCtrl,
                    obscureText: !_isPasswordVisible,
                    decoration: InputDecoration(
                      labelText: "Hasło",
                      prefixIcon: const Icon(Icons.lock_outline),
                      border: const OutlineInputBorder(),
                      suffixIcon: IconButton(
                        icon: Icon(
                          _isPasswordVisible
                              ? Icons.visibility
                              : Icons.visibility_off,
                        ),
                        onPressed: () {
                          setState(() {
                            _isPasswordVisible = !_isPasswordVisible;
                          });
                        },
                      ),
                    ),
                    textInputAction: TextInputAction.done, // Przycisk "Gotowe"
                    onFieldSubmitted: (_) => _submit(), // Enter zatwierdza
                    enabled: !loginState.isLoading,
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Wpisz hasło';
                      }
                      return null;
                    },
                  ),

                  // ================= NOWY FRAGMENT START =================
                  // Mały odstęp od pola hasła
                  const SizedBox(height: 8),

                  // Link "Zapomniałeś hasła?" wyrównany do prawej
                  Align(
                    alignment: Alignment.centerRight,
                    child: TextButton(
                      onPressed: loginState.isLoading
                          ? null
                          : () {
                              ref.read(navigationIndexProvider.notifier).state = 9; // Index nowej strony
                            },
                      style: TextButton.styleFrom(
                        // Zmniejszamy minimalny rozmiar i padding, żeby tekst
                        // ładnie licował się z prawą krawędzią pola tekstowego
                        padding: const EdgeInsets.symmetric(
                          horizontal: 8,
                          vertical: 4,
                        ),
                        minimumSize: Size.zero,
                        tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        foregroundColor:
                            Colors.deepPurple, // Spójność z motywem
                      ),
                      child: const Text(
                        "Zapomniałeś hasła?",
                        style: TextStyle(fontWeight: FontWeight.w600),
                      ),
                    ),
                  ),
                  // ================= NOWY FRAGMENT END =================
                  const SizedBox(height: 24),

                  // --- Error Message Display ---
                  // Wyświetlamy błąd globalny z Controllera (np. 401 Unauthorized)
                  if (loginState.error != null)
                    Padding(
                      padding: const EdgeInsets.only(bottom: 16.0),
                      child: Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.red.shade50,
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.red.shade200),
                        ),
                        child: Row(
                          children: [
                            const Icon(Icons.error_outline, color: Colors.red),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Text(
                                loginState.error!,
                                style: TextStyle(color: Colors.red.shade900),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),

                  // --- Submit Button ---
                  FilledButton(
                    onPressed: loginState.isLoading ? null : _submit,
                    style: FilledButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      textStyle: const TextStyle(fontSize: 16),
                    ),
                    child: loginState.isLoading
                        ? const SizedBox(
                            width: 24,
                            height: 24,
                            child: CircularProgressIndicator(
                              color: Colors.white,
                              strokeWidth: 2,
                            ),
                          )
                        : const Text("ZALOGUJ SIĘ"),
                  ),

                  const SizedBox(height: 16),

                  // --- Link do rejestracji ---
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Text("Nie masz konta?"),
                      TextButton(
                        onPressed: loginState.isLoading
                            ? null
                            : () {
                                // Nawigacja do rejestracji (Index 4 w AppShell)
                                ref
                                        .read(navigationIndexProvider.notifier)
                                        .state =
                                    4;
                              },
                        child: const Text("Zarejestruj się"),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/features/auth/presentation/forgot_password_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:maia_flutter_client/core/navigation_provider.dart';
import 'controllers/forgot_password_controller.dart';

class ForgotPasswordPage extends ConsumerStatefulWidget {
  const ForgotPasswordPage({super.key});

  @override
  ConsumerState<ForgotPasswordPage> createState() => _ForgotPasswordPageState();
}

class _ForgotPasswordPageState extends ConsumerState<ForgotPasswordPage> {
  final _formKey = GlobalKey<FormState>();
  final _emailCtrl = TextEditingController();

  // Indeks strony logowania w MainShell (według app.dart jest to 5)
  static const int _loginPageIndex = 5;

  @override
  void dispose() {
    _emailCtrl.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;

    // Ukrywamy klawiaturę
    FocusScope.of(context).unfocus();

    // Wywołujemy logikę z kontrolera
    final success = await ref
        .read(forgotPasswordControllerProvider.notifier)
        .sendResetLink(_emailCtrl.text.trim());

    if (success && mounted) {
      // Opcjonalnie: czyścimy pole po sukcesie
      _emailCtrl.clear();
      
      // SnackBar jako dodatkowe potwierdzenie
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Link został wysłany! Sprawdź skrzynkę e-mail.'),
          backgroundColor: Colors.green,
          behavior: SnackBarBehavior.floating,
        ),
      );
      // Opcjonalnie: Powrót do logowania po sukcesie
      // ref.read(navigationIndexProvider.notifier).state = _loginPageIndex;
    }
  }

  void _navigateToLogin() {
    ref.read(navigationIndexProvider.notifier).state = _loginPageIndex;
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(forgotPasswordControllerProvider);

    return Scaffold(
      // AppBar jest opcjonalny, jeśli strona jest w MainShell, 
      // ale dla ForgotPassword często chcemy "czysty" ekran bez menu.
      // Tutaj zostawiam body, bo MainShell dostarcza AppBar.
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 400),
            child: Form(
              key: _formKey,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  // --- 1. Linia powrotu ---
                  Align(
                    alignment: Alignment.centerLeft,
                    child: TextButton.icon(
                      onPressed: state.isLoading ? null : _navigateToLogin,
                      icon: const Icon(Icons.arrow_back, size: 20),
                      label: const Text("Powrót do logowania"),
                      style: TextButton.styleFrom(
                        padding: EdgeInsets.zero, // Zmniejsza padding, by wyrównać do lewej
                        tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        foregroundColor: Colors.grey[700],
                      ),
                    ),
                  ),
                  
                  const SizedBox(height: 32),

                  // --- 2. Ikona (Email) ---
                  Icon(
                    state.isSuccess ? Icons.mark_email_read_outlined : Icons.mark_email_unread_outlined,
                    size: 80,
                    color: state.isSuccess ? Colors.green : Colors.deepPurple,
                  ),
                  
                  const SizedBox(height: 24),

                  // --- 3. Nagłówek ---
                  Text(
                    state.isSuccess ? "Sprawdź skrzynkę" : "Przypomnij hasło",
                    style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: Colors.black87,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  
                  const SizedBox(height: 8),

                  // --- 4. Podtytuł (Instrukcja) ---
                  Text(
                    state.isSuccess 
                      ? "Jeśli podany adres email istnieje w naszej bazie, wysłaliśmy na niego link do resetowania hasła."
                      : "Podaj adres email, na który wyślemy link do\nresetowania hasła.",
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      color: Colors.grey[600],
                      height: 1.5,
                    ),
                    textAlign: TextAlign.center,
                  ),

                  const SizedBox(height: 32),

                  // --- 5. Pole Email ---
                  // Ukrywamy pole lub blokujemy po sukcesie, żeby użytkownik skupił się na komunikacie
                  if (!state.isSuccess)
                    TextFormField(
                      controller: _emailCtrl,
                      keyboardType: TextInputType.emailAddress,
                      textInputAction: TextInputAction.done,
                      onFieldSubmitted: (_) => _submit(),
                      enabled: !state.isLoading,
                      decoration: const InputDecoration(
                        labelText: "Adres email",
                        prefixIcon: Icon(Icons.email_outlined),
                        border: OutlineInputBorder(),
                        hintText: "np. tom@example.com",
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Wpisz adres email';
                        }
                        if (!value.contains('@') || !value.contains('.')) {
                          return 'Niepoprawny format email';
                        }
                        return null;
                      },
                    ),

                  const SizedBox(height: 24),

                  // --- Wyświetlanie błędu ---
                  if (state.error != null)
                    Padding(
                      padding: const EdgeInsets.only(bottom: 16.0),
                      child: Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.red.shade50,
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.red.shade200),
                        ),
                        child: Row(
                          children: [
                            const Icon(Icons.error_outline, color: Colors.red),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Text(
                                state.error!,
                                style: TextStyle(color: Colors.red.shade900),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),

                  // --- 6. Przycisk Akcji ---
                  if (!state.isSuccess)
                    FilledButton(
                      onPressed: state.isLoading ? null : _submit,
                      style: FilledButton.styleFrom(
                        padding: const EdgeInsets.symmetric(vertical: 16),
                        textStyle: const TextStyle(fontSize: 16),
                      ),
                      child: state.isLoading
                          ? const SizedBox(
                              width: 24,
                              height: 24,
                              child: CircularProgressIndicator(
                                color: Colors.white,
                                strokeWidth: 2,
                              ),
                            )
                          : const Text("WYŚLIJ LINK RESETUJĄCY"),
                    )
                  else
                    // Przycisk powrotu do logowania po sukcesie
                    FilledButton.icon(
                      onPressed: _navigateToLogin,
                      style: FilledButton.styleFrom(
                        padding: const EdgeInsets.symmetric(vertical: 16),
                        backgroundColor: Colors.green,
                        textStyle: const TextStyle(fontSize: 16),
                      ),
                      icon: const Icon(Icons.login),
                      label: const Text("WRÓĆ DO LOGOWANIA"),
                    ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/auth/presentation/register_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:maia_flutter_client/core/navigation_provider.dart';
import '../../captcha/presentation/widgets/captcha_box.dart';
import '../../captcha/presentation/captcha_controller.dart';
import 'controllers/register_controller.dart';

class RegisterPage extends ConsumerStatefulWidget {
  const RegisterPage({super.key});

  @override
  ConsumerState<RegisterPage> createState() => _RegisterPageState();
}

class _RegisterPageState extends ConsumerState<RegisterPage> {
  final _formKey = GlobalKey<FormState>();

  // Kontrolery
  final _emailCtrl = TextEditingController();
  final _userCtrl = TextEditingController();
  final _passCtrl = TextEditingController();
  final _captchaInputCtrl = TextEditingController();

  // Lokalny stan widoku
  bool _isPasswordVisible = false;

  @override
  void initState() {
    super.initState();
    // Dodajemy listener, który wyczyści sugestię/błąd jak user zacznie pisać w username
    _userCtrl.addListener(() {
      final regState = ref.read(registerControllerProvider);
      // Sprawdzamy stan rejestracji
      if (regState.usernameSuggestion != null || regState.error != null) {
        // Wywołujemy metodę czyszczącą tylko jeśli faktycznie jest co czyścić
        // (żeby nie odświeżać UI przy każdym znaku bez potrzeby)
        ref.read(registerControllerProvider.notifier).clearSuggestion();
      }
    });
  }

  @override
  void dispose() {
    _emailCtrl.dispose();
    _userCtrl.dispose();
    _passCtrl.dispose();
    _captchaInputCtrl.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    // 1. Walidacja lokalna formularza
    if (!_formKey.currentState!.validate()) return;

    // 2. Walidacja czy captcha w ogóle załadowana
    final captchaState = ref.read(captchaControllerProvider);
    if (captchaState.captcha == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Błąd Captchy. Odśwież obrazek.')),
      );
      return;
    }

    // UX: Ukryj klawiaturę
    FocusScope.of(context).unfocus();

    // 3. Strzał do API
    final success = await ref
        .read(registerControllerProvider.notifier)
        .register(
          email: _emailCtrl.text,
          username: _userCtrl.text,
          password: _passCtrl.text,
          captchaId: captchaState.captcha!.id,
          captchaAnswer: _captchaInputCtrl.text,
        );

    // 4. Obsługa wyniku
    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Konto założone! Możesz się zalogować.'),
          backgroundColor: Colors.green,
          behavior: SnackBarBehavior.floating,
        ),
      );

      // Czyścimy formularz
      _emailCtrl.clear();
      _userCtrl.clear();
      _passCtrl.clear();
      _captchaInputCtrl.clear();

      // Przekierowanie do logowania (Index 5 w MainShell)
      ref.read(navigationIndexProvider.notifier).state = 5;

      // Pobranie nowej captchy "na zaś"
      ref.read(captchaControllerProvider.notifier).fetchCaptcha();
    } else {
      // W przypadku błędu (np. zły kod captcha), musimy pobrać nowy obrazek,
      // bo stary token na serwerze został "spalony" przy próbie weryfikacji.
      if (mounted) {
        _captchaInputCtrl.clear();
        ref.read(captchaControllerProvider.notifier).fetchCaptcha();
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // ZMIANA: Watchujemy stan rejestracji
    final regState = ref.watch(registerControllerProvider);

    return Scaffold(
      // Body jest centrowane i scrollowalne - identycznie jak w LoginPage
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 400),
            child: Form(
              key: _formKey,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  // --- NAGŁÓWEK ---
                  const Icon(
                    Icons.person_add_alt_1_outlined,
                    size: 80,
                    color: Colors.deepPurple,
                  ),
                  const SizedBox(height: 24),
                  Text(
                    "Utwórz konto",
                    style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: Colors.black87,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    "Dołącz do nas i zacznij naukę.",
                    style: Theme.of(
                      context,
                    ).textTheme.bodyMedium?.copyWith(color: Colors.grey[600]),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 32),

                  // --- EMAIL ---
                  TextFormField(
                    controller: _emailCtrl,
                    decoration: const InputDecoration(
                      labelText: "Adres email",
                      prefixIcon: Icon(Icons.email_outlined),
                      border: OutlineInputBorder(),
                    ),
                    keyboardType: TextInputType.emailAddress,
                    textInputAction: TextInputAction.next,
                    enabled: !regState.isLoading,
                    validator: (v) {
                      if (v == null || v.isEmpty) return 'Wpisz email';
                      if (!v.contains('@')) return 'Niepoprawny format email';
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // --- USERNAME ---
                  TextFormField(
                    controller: _userCtrl,
                    decoration: const InputDecoration(
                      labelText: "Nazwa użytkownika",
                      prefixIcon: Icon(Icons.person_outline),
                      border: OutlineInputBorder(),
                    ),
                    textInputAction: TextInputAction.next,
                    enabled: !regState.isLoading,
                    validator: (v) {
                      if (v == null || v.isEmpty){
                        return 'Wpisz nazwę użytkownika';
                      }
                      if (v.length < 3){
                        return 'Minimum 3 znaki';
                      }
                      return null;
                    },
                  ),
                  //------------------ USERNAME SUGGESTION ---------
                  if (regState.usernameSuggestion != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 8.0),
                      child: InkWell(
                        onTap: () {
                          // Wpisujemy sugestię do pola
                          _userCtrl.text = regState.usernameSuggestion!;
                          // Czyścimy błąd w kontrolerze
                          ref
                              .read(registerControllerProvider.notifier)
                              .clearSuggestion();
                        },
                        child: Container(
                          padding: const EdgeInsets.all(12),
                          decoration: BoxDecoration(
                            color: Colors.blue.shade50,
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(color: Colors.blue.shade200),
                          ),
                          child: Row(
                            children: [
                              const Icon(
                                Icons.info_outline,
                                color: Colors.blue,
                              ),
                              const SizedBox(width: 8),
                              Expanded(
                                child: Text(
                                  "Login zajęty. Kliknij, aby użyć: ${regState.usernameSuggestion}",
                                  style: TextStyle(color: Colors.blue.shade900),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  //------------------------------------------------
                  const SizedBox(height: 16),

                  // --- HASŁO (z okiem) ---
                  TextFormField(
                    controller: _passCtrl,
                    obscureText: !_isPasswordVisible, // Logika ukrywania
                    decoration: InputDecoration(
                      labelText: "Hasło",
                      prefixIcon: const Icon(Icons.lock_outline),
                      border: const OutlineInputBorder(),
                      // Ikona oka
                      suffixIcon: IconButton(
                        icon: Icon(
                          _isPasswordVisible
                              ? Icons.visibility
                              : Icons.visibility_off,
                        ),
                        onPressed: () {
                          setState(() {
                            _isPasswordVisible = !_isPasswordVisible;
                          });
                        },
                      ),
                    ),
                    textInputAction: TextInputAction.next,
                    enabled: !regState.isLoading,
                    validator: (v) {
                      if (v == null || v.isEmpty) return 'Wpisz hasło';

                      // Sprawdzamy wszystkie warunki naraz
                      bool hasMinLength = v.length >= 6;
                      bool hasDigit = RegExp(r'\d').hasMatch(v);
                      bool hasLetter = RegExp(r'[a-zA-Z]').hasMatch(v);

                      // Jeśli którykolwiek warunek nie jest spełniony, zwracamy pełną instrukcję
                      // Zwracamy odrazu bład na wszystkie warunki, żeby użytkownik miał
                      // lepsze UI/UX experience, i zeby odrazu znał wszystkie warunki prawidlowego hasla - nie usuwac tego komentarza
                      if (!hasMinLength || !hasDigit || !hasLetter) {
                        return 'Hasło musi mieć min. 6 znaków, literę i cyfrę';
                      }

                      return null;
                    },
                  ),
                  const SizedBox(height: 24),

                  // --- CAPTCHA ---
                  const Text(
                    "Weryfikacja bezpieczeństwa",
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 8),
                  CaptchaBox(answerController: _captchaInputCtrl),

                  const SizedBox(height: 24),

                  // --- ERROR BOX (Wystylizowany jak w Login) ---
                  if (regState.error != null &&
                      regState.usernameSuggestion == null)
                    Padding(
                      padding: const EdgeInsets.only(bottom: 16.0),
                      child: Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.red.shade50,
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.red.shade200),
                        ),
                        child: Row(
                          children: [
                            const Icon(Icons.error_outline, color: Colors.red),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Text(
                                regState.error!,
                                style: TextStyle(color: Colors.red.shade900),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),

                  // --- PRZYCISK REJESTRACJI ---
                  FilledButton(
                    onPressed: regState.isLoading ? null : _submit,
                    style: FilledButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      textStyle: const TextStyle(fontSize: 16),
                    ),
                    child: regState.isLoading
                        ? const SizedBox(
                            width: 24,
                            height: 24,
                            child: CircularProgressIndicator(
                              color: Colors.white,
                              strokeWidth: 2,
                            ),
                          )
                        : const Text("UTWÓRZ KONTO"),
                  ),

                  const SizedBox(height: 16),

                  // --- LINK DO LOGOWANIA ---
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Text("Masz już konto?"),
                      TextButton(
                        onPressed: regState.isLoading
                            ? null
                            : () {
                                // Nawigacja do logowania (Index 5 w AppShell)
                                ref
                                        .read(navigationIndexProvider.notifier)
                                        .state =
                                    5;
                              },
                        child: const Text("Zaloguj się"),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/features/auth/presentation/controllers/register_controller.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/network/api_error_handler.dart';
import '../../data/auth_repository.dart';
import '../../domain/exceptions/auth_exceptions.dart';

class RegisterState {
  final bool isLoading;
  final String? error;
  final String? usernameSuggestion;

  const RegisterState({
    this.isLoading = false, 
    this.error, 
    this.usernameSuggestion
  });

  RegisterState copyWith({bool? isLoading, String? error, String? usernameSuggestion}) {
    return RegisterState(
      isLoading: isLoading ?? this.isLoading,
      error: error, 
      usernameSuggestion: usernameSuggestion,
    );
  }
  
  // Helper do czyszczenia sugestii
  RegisterState clearSuggestion() {
    return RegisterState(isLoading: isLoading, error: null, usernameSuggestion: null);
  }
}

class RegisterController extends StateNotifier<RegisterState> {
  final AuthRepository _authRepository;

  RegisterController(this._authRepository) : super(const RegisterState());

  void clearSuggestion() {
    if (state.usernameSuggestion != null || state.error != null) {
      state = state.clearSuggestion();
    }
  }

  Future<bool> register({
    required String email,
    required String username,
    required String password,
    required String captchaId,
    required String captchaAnswer,
  }) async {
    state = const RegisterState(isLoading: true); // Reset stanu przy starcie

    try {
      await _authRepository.register(
        email: email,
        username: username,
        password: password,
        captchaId: captchaId,
        captchaAnswer: captchaAnswer,
      );
      state = state.copyWith(isLoading: false);
      // Rejestracja zazwyczaj nie loguje z automatu (chyba że API tak działa),
      // więc nie ustawiamy tutaj authController.setAuthenticated(true).
      // Zwracamy true, żeby UI wiedział o sukcesie.
      return true;
    } on UsernameTakenException catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.message,
        usernameSuggestion: e.suggestion,
      );
      return false;
    } catch (e) {
      final msg = ApiErrorHandler.getErrorMessage(e);
      state = state.copyWith(isLoading: false, error: msg);
      return false;
    }
  }
}

final registerControllerProvider = StateNotifierProvider.autoDispose<RegisterController, RegisterState>((ref) {
  return RegisterController(ref.watch(authRepositoryProvider));
});


===============================
Ścieżka do pliku: ./lib/features/auth/presentation/controllers/forgot_password_controller.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/network/api_error_handler.dart';
import '../../data/auth_repository.dart';

// Stan widoku
class ForgotPasswordState {
  final bool isLoading;
  final String? error;
  final bool isSuccess;

  const ForgotPasswordState({
    this.isLoading = false,
    this.error,
    this.isSuccess = false,
  });

  ForgotPasswordState copyWith({
    bool? isLoading,
    String? error, 
    bool? isSuccess,
  }) {
    return ForgotPasswordState(
      isLoading: isLoading ?? this.isLoading,
      error: error,
      isSuccess: isSuccess ?? this.isSuccess,
    );
  }
}

class ForgotPasswordController extends StateNotifier<ForgotPasswordState> {
  final AuthRepository _authRepository;

  ForgotPasswordController(this._authRepository) : super(const ForgotPasswordState());

  Future<bool> sendResetLink(String email) async {
    // Reset stanu przed akcją (czyścimy też error z poprzedniej próby)
    state = const ForgotPasswordState(isLoading: true, error: null);

    try {
      await _authRepository.forgotPassword(email);
      
      // Sukces (Status 202 Accepted)
      state = state.copyWith(isLoading: false, isSuccess: true);
      return true;
    } catch (e) {
      final msg = ApiErrorHandler.getErrorMessage(e);
      state = state.copyWith(isLoading: false, error: msg);
      return false;
    }
  }

  void resetState() {
    state = const ForgotPasswordState();
  }
}

// Provider
final forgotPasswordControllerProvider = 
    StateNotifierProvider.autoDispose<ForgotPasswordController, ForgotPasswordState>((ref) {
  return ForgotPasswordController(ref.watch(authRepositoryProvider));
});


===============================
Ścieżka do pliku: ./lib/features/auth/presentation/controllers/login_controller.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/network/api_error_handler.dart';
import '../../data/auth_repository.dart';
import '../../data/token_storage.dart';
import 'auth_controller.dart';

// Stan formularza logowania
class LoginState {
  final bool isLoading;
  final String? error;

  const LoginState({this.isLoading = false, this.error});

  LoginState copyWith({bool? isLoading, String? error}) {
    // Uwaga: error: error (bez nulla) pozwala wyczyścić błąd przekazując null
    return LoginState(
      isLoading: isLoading ?? this.isLoading,
      error: error, 
    );
  }
}

class LoginController extends StateNotifier<LoginState> {
  final AuthRepository _authRepository;
  final TokenStorage _tokenStorage;
  // Potrzebujemy dostępu do AuthController, żeby zmienić stan globalny po sukcesie
  final AuthController _authController;

  LoginController(this._authRepository, this._tokenStorage, this._authController)
      : super(const LoginState());

  Future<bool> login(String username, String password) async {
    state = state.copyWith(isLoading: true, error: null);

    try {
      final token = await _authRepository.login(
        username: username, 
        password: password
      );
      
      await _tokenStorage.saveToken(token);
      
      // Sukces lokalny
      state = state.copyWith(isLoading: false);
      
      // Aktualizacja stanu globalnego aplikacji
      _authController.setAuthenticated(true);
      
      return true;
    } catch (e) {
      final msg = ApiErrorHandler.getErrorMessage(e);
      state = state.copyWith(isLoading: false, error: msg);
      return false;
    }
  }
}

// Używamy autoDispose, aby stan czyścił się, gdy kontroler nie jest obserwowany 
// (choć przy IndexedStack on "żyje", ale to dobra praktyka dla formularzy)
final loginControllerProvider = StateNotifierProvider.autoDispose<LoginController, LoginState>((ref) {
  return LoginController(
    ref.watch(authRepositoryProvider),
    ref.watch(tokenStorageProvider),
    ref.read(authControllerProvider.notifier), // read, bo potrzebujemy metody, nie stanu
  );
});


===============================
Ścieżka do pliku: ./lib/features/auth/presentation/controllers/auth_controller.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/auth_repository.dart';
import '../../data/token_storage.dart';

// Stan sesji: Interesuje nas tylko czy user jest zalogowany
class AuthState {
  final bool isAuthenticated;
  final bool isAppLoading; // Do splash screena przy starcie

  const AuthState({
    this.isAuthenticated = false,
    this.isAppLoading = true, // Domyślnie true, bo przy starcie sprawdzamy storage
  });
}

class AuthController extends StateNotifier<AuthState> {
  final AuthRepository _repository;
  final TokenStorage _storage;

  AuthController(this._repository, this._storage) : super(const AuthState()) {
    checkAuthStatus();
  }

  // Sprawdza przy starcie apki, czy mamy token
  Future<void> checkAuthStatus() async {
    final token = await _storage.getToken();
    if (token != null) {
      // Opcjonalnie: Tutaj można strzelić do /api/v1/users/me żeby sprawdzić czy token jest nadal ważny
      state = const AuthState(isAuthenticated: true, isAppLoading: false);
    } else {
      state = const AuthState(isAuthenticated: false, isAppLoading: false);
    }
  }

  // Metoda wywoływana przez LoginController/RegisterController po sukcesie
  void setAuthenticated(bool isAuthenticated) {
    state = AuthState(isAuthenticated: isAuthenticated, isAppLoading: false);
  }

  Future<void> logout() async {
    final token = await _storage.getToken();
    if (token != null) {
      try {
        await _repository.logout(token.refreshToken);
      } catch (_) {
        // Ignorujemy błędy sieciowe przy wylogowaniu
      }
    }
    await _storage.clearToken();
    state = const AuthState(isAuthenticated: false, isAppLoading: false);
  }
}

// Globalny provider stanu autentykacji
final authControllerProvider = StateNotifierProvider<AuthController, AuthState>(
  (ref) {
    return AuthController(
      ref.watch(authRepositoryProvider),
      ref.watch(tokenStorageProvider),
    );
  },
);



===============================
Ścieżka do pliku: ./lib/features/auth/presentation/widgets/user_avatar_button.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/navigation_provider.dart';
import '../controllers/auth_controller.dart';

class UserAvatarButton extends ConsumerWidget {
  const UserAvatarButton({super.key});

  static const int _loginPageIndex = 5;
  static const int _settingsPageIndex = 10;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authControllerProvider);
    final bool isLoggedIn = authState.isAuthenticated;

    // --- STAN: ZALOGOWANY (Menu Popup) ---
    if (isLoggedIn) {
      return Padding(
        padding: const EdgeInsets.only(right: 8.0),
        child: PopupMenuButton<String>(
          offset: const Offset(0, 50),
          tooltip: 'Menu użytkownika',
          // Zaokrąglenie samego okienka menu
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          
          // KLUCZOWA ZMIANA:
          // Używamy parametru 'icon' zamiast 'child'.
          // Dzięki temu Flutter traktuje to jako standardową ikonę na pasku
          // i automatycznie dodaje okrągły efekt "ink splash" przy kliknięciu/najechaniu.
          icon: CircleAvatar(
            radius: 18,
            backgroundColor: Colors.deepPurple.shade100,
            child: const Icon(Icons.person, color: Colors.deepPurple, size: 20),
          ),
          
          onSelected: (value) {
            // OBSŁUGA KLIKNIĘCIA
            if (value == 'logout') {
              _handleLogout(context, ref);
            } else if (value == 'settings') {
              ref.read(navigationIndexProvider.notifier).state = _settingsPageIndex;
            }
          },
          
          itemBuilder: (BuildContext context) => <PopupMenuEntry<String>>[
            const PopupMenuItem<String>(
              enabled: false,
              child: Text(
                "Moje Konto", 
                style: TextStyle(fontWeight: FontWeight.bold, fontSize: 12, color: Colors.grey),
              ),
            ),

            const PopupMenuItem<String>(
              value: 'settings', // To musi pasować do warunku w onSelected
              child: Row(
                children: [
                  Icon(Icons.settings, color: Colors.black87, size: 20), // Spójna ikona
                  SizedBox(width: 12),
                  Text('Ustawienia', style: TextStyle(color: Colors.black87)),
                ],
              ),
            ),
            
            const PopupMenuDivider(),
            const PopupMenuItem<String>(
              value: 'logout',
              child: Row(
                children: [
                  Icon(Icons.logout, color: Colors.red, size: 20),
                  SizedBox(width: 12),
                  Text('Wyloguj się', style: TextStyle(color: Colors.black87)),
                ],
              ),
            ),
          ],
        ),
      );
    }

    // --- STAN: NIEZALOGOWANY (Przycisk Logowania) ---
    return Padding(
      padding: const EdgeInsets.only(right: 8.0),
      child: IconButton(
        tooltip: "Zaloguj się",
        // Tutaj też używamy standardowego IconButton, który ma okrągły splash
        icon: CircleAvatar(
          radius: 18,
          backgroundColor: Colors.grey.shade200,
          child: Icon(Icons.login, color: Colors.grey.shade700, size: 20),
        ),
        onPressed: () {
          ref.read(navigationIndexProvider.notifier).state = _loginPageIndex;
        },
      ),
    );
  }

  Future<void> _handleLogout(BuildContext context, WidgetRef ref) async {
    await ref.read(authControllerProvider.notifier).logout();
    
    if (context.mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text("Wylogowano pomyślnie"),
          duration: Duration(seconds: 2),
          behavior: SnackBarBehavior.floating,
        ),
      );
    }
    
    ref.read(navigationIndexProvider.notifier).state = 0;
  }
}


===============================
Ścieżka do pliku: ./lib/features/auth/domain/exceptions/auth_exceptions.dart

Zawartość pliku:

class UsernameTakenException implements Exception {
  final String message;
  final String suggestion;

  UsernameTakenException({
    required this.message, 
    required this.suggestion
  });

  @override
  String toString() => message;
}


===============================
Ścieżka do pliku: ./lib/features/auth/data/auth_repository.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// ZMIANA: Importujemy provider dedykowany dla auth
import 'auth_dio_provider.dart'; 
import 'models/auth_token.dart';
import "../domain/exceptions/auth_exceptions.dart";

final authRepositoryProvider = Provider((ref) {
  // ZMIANA: Watchujemy authDioProvider zamiast głównego dioProvider
  final dio = ref.watch(authDioProvider); 
  return AuthRepository(dio);
});

class AuthRepository {
  final Dio _dio;

  AuthRepository(this._dio);

  // Logowanie: x-www-form-urlencoded
  Future<AuthToken> login({required String username, required String password}) async {
    try {
      final response = await _dio.post(
        '/api/v1/auth/login',
        data: {
          'username': username,
          'password': password,
          'grant_type': 'password', // Wymagane przez OAuth2PasswordBearer
        },
        options: Options(
          contentType: Headers.formUrlEncodedContentType, // WAŻNE!
        ),
      );
      return AuthToken.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }

  // Rejestracja: application/json
Future<void> register({
    required String email,
    required String username,
    required String password,
    required String captchaId,
    required String captchaAnswer,
  }) async {
    try {
      await _dio.post(
        '/api/v1/auth/register',
        data: {
          'email': email,
          'username': username,
          'password': password,
          'captcha_id': captchaId,
          'captcha_answer': captchaAnswer,
        },
      );
    } on DioException catch (e) {
      // Sprawdzamy, czy to konflikt (409) i czy backend przysłał sugestię
      if (e.response?.statusCode == 409) {
        final data = e.response?.data;
        if (data is Map && data['detail'] is Map) {
          final suggestion = data['detail']['suggestion'];
          
          if (suggestion != null) {
            // Rzucamy nasz specjalny wyjątek z sugestią
            throw UsernameTakenException(
              message: "Nazwa użytkownika jest zajęta.",
              suggestion: suggestion.toString(),
            );
          }
        }
      }
      // Jeśli to nie to, rzucamy błąd dalej (trafi do ApiErrorHandler)
      rethrow;
    } catch (e) {
      rethrow;
    }
  }

  // Wylogowanie
  Future<void> logout(String refreshToken) async {
      // API wymaga wysłania refresh tokena przy wylogowaniu
      await _dio.post('/api/v1/auth/logout', data: {'refresh_token': refreshToken});
  }

  Future<void> forgotPassword(String email) async {
    try {
      // Endpoint zwraca 202 Accepted (nawet jeśli email nie istnieje - security practice)
      // lub 422 jeśli format emaila jest błędny.
      await _dio.post(
        '/api/v1/auth/forgot-password',
        data: {'email': email},
      );
    } catch (e) {
      rethrow; // Błędy sieciowe/walidacyjne zostaną obsłużone w kontrolerze przez ApiErrorHandler
    }
  }

  // ================= ZMIANA: NOWA METODA =================
  // Zgodnie z dokumentacją: DELETE /api/v1/users/me
  // Autoryzacja jest wymagana, `_dio` ma już podpięty interceptor z tokenem.
  Future<void> deleteAccount() async {
    try {
      // Endpoint zwraca 204 No Content
      await _dio.delete('/api/v1/users/me');
    } catch (e) {
      rethrow;
    }
  }
  // ================= KONIEC ZMIANY =================
}


===============================
Ścieżka do pliku: ./lib/features/auth/data/token_storage.dart

Zawartość pliku:

import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'models/auth_token.dart';

final tokenStorageProvider = Provider((ref) => TokenStorage());

class TokenStorage {
  // POPRAWKA: Usuwamy parametr encryptedSharedPreferences.
  // Dodajemy resetOnError: true -> to "Best Practice" w developmentzie.
  // Jeśli klucze szyfrowania ulegną uszkodzeniu (np. przy reinstalacji apki w devie),
  // magazyn zostanie zresetowany zamiast crashować aplikację.
  final _storage = const FlutterSecureStorage(
    aOptions: AndroidOptions(
      resetOnError: true, 
    ),
  );

  static const _keyAccess = 'access_token';
  static const _keyRefresh = 'refresh_token';

  Future<void> saveToken(AuthToken token) async {
    await _storage.write(key: _keyAccess, value: token.accessToken);
    await _storage.write(key: _keyRefresh, value: token.refreshToken);
  }

  Future<AuthToken?> getToken() async {
    // Odczyt może rzucić wyjątek jeśli klucze systemowe się zmienią, 
    // dlatego warto otoczyć to try-catch w produkcyjnym kodzie, 
    // ale resetOnError w opcjach wyżej załatwia większość problemów.
    final access = await _storage.read(key: _keyAccess);
    final refresh = await _storage.read(key: _keyRefresh);
    
    if (access != null && refresh != null) {
      return AuthToken(accessToken: access, refreshToken: refresh);
    }
    return null;
  }

  Future<void> clearToken() async {
    await _storage.delete(key: _keyAccess);
    await _storage.delete(key: _keyRefresh);
  }
}


===============================
Ścieżka do pliku: ./lib/features/auth/data/auth_dio_provider.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/config/api_config.dart';
import '../../../core/network/auth_interceptor_provider.dart';

final authDioProvider = Provider<Dio>((ref) {
  // 1. Konfiguracja bazowa
  final dio = Dio(BaseOptions(
    baseUrl: ApiConfig.authBaseUrl, // Używamy adresu z konfigu
    connectTimeout: ApiConfig.connectTimeout,
    receiveTimeout: ApiConfig.receiveTimeout,
  ));

  // 2. Dodajemy wspólny interceptor autentykacji
  // (Potrzebny np. do endpointu /logout lub /users/me)
  final authInterceptor = ref.watch(authInterceptorProvider);
  dio.interceptors.add(authInterceptor);

  // 3. Opcjonalnie: Dodaj PrettyDioLogger w trybie debug (jeśli używasz)
  
  return dio;
});


===============================
Ścieżka do pliku: ./lib/features/auth/data/models/auth_token.dart

Zawartość pliku:

class AuthToken {
  final String accessToken;
  final String refreshToken;

  AuthToken({required this.accessToken, required this.refreshToken});

  factory AuthToken.fromJson(Map<String, dynamic> json) {
    return AuthToken(
      accessToken: json['access_token'] as String,
      refreshToken: json['refresh_token'] as String,
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/auth/data/models/user_model.dart

Zawartość pliku:

class User {
  final String id;
  final String username;
  final String email;
  final String role;

  User({required this.id, required this.username, required this.email, required this.role});

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'],
      username: json['username'],
      email: json['email'],
      role: json['account_role'],
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/captcha/captcha_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/widgets/main_drawer.dart';
import 'presentation/captcha_controller.dart';
import 'presentation/widgets/captcha_box.dart';

class CaptchaPage extends ConsumerStatefulWidget {
  const CaptchaPage({super.key});

  @override
  ConsumerState<CaptchaPage> createState() => _CaptchaPageState();
}

class _CaptchaPageState extends ConsumerState<CaptchaPage> {
  final _captchaInputController = TextEditingController();

  @override
  void dispose() {
    _captchaInputController.dispose();
    super.dispose();
  }

  Future<void> _verify() async {
    // Ukrywamy klawiaturę
    FocusScope.of(context).unfocus();
    
    final answer = _captchaInputController.text;
    if (answer.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Wpisz kod!")),
      );
      return;
    }

    final success = await ref
        .read(captchaControllerProvider.notifier)
        .verifyCaptcha(answer);

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text("Captcha zweryfikowana pomyślnie!"),
          backgroundColor: Colors.green,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    // Obserwujemy stan, aby wiedzieć np. czy trwa ładowanie
    final captchaState = ref.watch(captchaControllerProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text("Captcha Test"),
        elevation: 2,
      ),
      drawer: const MainDrawer(), // Dodajemy boczny pasek
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              "Demonstracja modułu Captcha",
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            const Text(
              "Poniższy komponent jest niezależny i gotowy do użycia na ekranach logowania/rejestracji.",
              style: TextStyle(color: Colors.grey),
            ),
            const SizedBox(height: 32),

            // --- REUŻYWALNY WIDGET CAPTCHA ---
            CaptchaBox(
              answerController: _captchaInputController,
              onRefresh: () {
                // Opcjonalny callback, np. logowanie zdarzenia
                debugPrint("Użytkownik odświeżył captchę");
              },
            ),
            // ---------------------------------

            const SizedBox(height: 24),

            // Przycisk "Verify" - specyficzny dla tej strony testowej
            SizedBox(
              width: double.infinity,
              child: FilledButton.icon(
                onPressed: captchaState.isLoading ? null : _verify,
                icon: const Icon(Icons.check_circle_outline),
                label: captchaState.isLoading
                    ? const SizedBox(
                        width: 20, 
                        height: 20, 
                        child: CircularProgressIndicator(color: Colors.white, strokeWidth: 2)
                      )
                    : const Text("ZWERYFIKUJ CAPTCHĘ"),
                style: FilledButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/captcha/presentation/captcha_controller.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/captcha_repository.dart';
import '../data/models/captcha_model.dart';
import '../../../../core/network/api_error_handler.dart';

// Stan dla naszego kontrolera
class CaptchaState {
  final CaptchaModel? captcha; // Obecny obrazek i ID
  final bool isLoading;
  final String? errorMessage;
  final bool? isVerified; // null = nie sprawdzano, true = ok, false = źle

  const CaptchaState({
    this.captcha,
    this.isLoading = false,
    this.errorMessage,
    this.isVerified,
  });

  CaptchaState copyWith({
    CaptchaModel? captcha,
    bool? isLoading,
    String? errorMessage,
    bool? isVerified,
  }) {
    return CaptchaState(
      captcha: captcha ?? this.captcha,
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage, // Jeśli null to czyścimy błąd
      isVerified: isVerified ?? this.isVerified,
    );
  }
}

class CaptchaController extends StateNotifier<CaptchaState> {
  final CaptchaRepository _repository;

  CaptchaController(this._repository) : super(const CaptchaState()) {
    // Automatycznie pobierz captchę przy starcie
    fetchCaptcha();
  }

  Future<void> fetchCaptcha() async {
    state = state.copyWith(isLoading: true, errorMessage: null, isVerified: null);
    try {
      final captcha = await _repository.generateCaptcha();
      state = state.copyWith(
        isLoading: false,
        captcha: captcha,
        errorMessage: null,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: ApiErrorHandler.getErrorMessage(e),
      );
    }
  }

  Future<bool> verifyCaptcha(String answer) async {
    if (state.captcha == null) return false;

    state = state.copyWith(isLoading: true, errorMessage: null);

    try {
      final isValid = await _repository.verifyCaptcha(
        CaptchaVerifyRequest(id: state.captcha!.id, answer: answer),
      );

      state = state.copyWith(
        isLoading: false,
        isVerified: isValid,
      );
      
      // Jeśli walidacja nie przeszła, można automatycznie odświeżyć captchę, 
      // bo zazwyczaj token jest jednorazowy.
      if (!isValid) {
         // Opcjonalnie: await fetchCaptcha(); 
         // Wiele systemów wymaga nowej captchy po błędnej próbie.
      }
      
      return isValid;
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: ApiErrorHandler.getErrorMessage(e),
        isVerified: false,
      );
      return false;
    }
  }
  
  // Metoda pomocnicza do resetowania stanu weryfikacji (np. gdy użytkownik zaczyna pisać)
  void resetVerificationStatus() {
    if (state.isVerified != null) {
      state = state.copyWith(isVerified: null);
    }
  }
}

// Używamy .autoDispose, aby stan się czyścił po wyjściu z ekranu
final captchaControllerProvider = 
    StateNotifierProvider.autoDispose<CaptchaController, CaptchaState>((ref) {
  final repo = ref.watch(captchaRepositoryProvider);
  return CaptchaController(repo);
});


===============================
Ścieżka do pliku: ./lib/features/captcha/presentation/widgets/captcha_box.dart

Zawartość pliku:

import 'dart:convert'; // Do base64Decode
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../captcha_controller.dart';

class CaptchaBox extends ConsumerStatefulWidget {
  final TextEditingController answerController;
  final VoidCallback? onRefresh;

  const CaptchaBox({
    super.key, 
    required this.answerController,
    this.onRefresh,
  });

  @override
  ConsumerState<CaptchaBox> createState() => _CaptchaBoxState();
}

class _CaptchaBoxState extends ConsumerState<CaptchaBox> {
  
  @override
  void initState() {
    super.initState();
    widget.answerController.addListener(() {
      ref.read(captchaControllerProvider.notifier).resetVerificationStatus();
    });
  }

  // --- NOWA METODA POMOCNICZA ---
  // Usuwa nagłówek "data:image/png;base64," jeśli istnieje
  String _cleanBase64(String base64String) {
    if (base64String.contains(',')) {
      return base64String.split(',').last;
    }
    return base64String;
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(captchaControllerProvider);
    final controller = ref.read(captchaControllerProvider.notifier);

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // 1. Obrazek Captcha
            Container(
              height: 80,
              decoration: BoxDecoration(
                color: Colors.grey.shade200,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.grey.shade300),
              ),
              child: state.isLoading && state.captcha == null
                  ? const Center(child: CircularProgressIndicator())
                  : state.captcha != null
                      ? ClipRRect(
                          borderRadius: BorderRadius.circular(8),
                          child: Image.memory(
                            // --- TUTAJ POPRAWKA ---
                            // Używamy metody pomocniczej _cleanBase64
                            base64Decode(_cleanBase64(state.captcha!.image)), 
                            fit: BoxFit.contain, // Zmienione na contain, żeby nie ucinało tekstu captchy
                            errorBuilder: (context, error, stackTrace) {
                              debugPrint('Błąd wyświetlania obrazka: $error');
                              return const Center(child: Icon(Icons.broken_image));
                            },
                          ),
                        )
                      : const Center(child: Text("Brak Captchy")),
            ),

            const SizedBox(height: 12),

            // 2. Wiersz: Pole tekstowe + Przycisk odświeżania
            Row(
              children: [
                Expanded(
                  child: TextFormField(
                    controller: widget.answerController,
                    decoration: InputDecoration(
                      labelText: 'Wpisz kod z obrazka',
                      border: const OutlineInputBorder(),
                      contentPadding: const EdgeInsets.symmetric(horizontal: 12),
                      enabledBorder: state.isVerified == false
                          ? const OutlineInputBorder(borderSide: BorderSide(color: Colors.red))
                          : null,
                      focusedBorder: state.isVerified == false
                          ? const OutlineInputBorder(borderSide: BorderSide(color: Colors.red, width: 2))
                          : null,
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                IconButton.filledTonal(
                  onPressed: state.isLoading 
                    ? null 
                    : () {
                        controller.fetchCaptcha();
                        widget.answerController.clear();
                        if(widget.onRefresh != null) widget.onRefresh!();
                      },
                  icon: state.isLoading
                      ? const SizedBox(
                          width: 20, 
                          height: 20, 
                          child: CircularProgressIndicator(strokeWidth: 2)
                        )
                      : const Icon(Icons.refresh),
                  tooltip: "Nowy kod",
                ),
              ],
            ),
            
            // 3. Informacja o błędzie
            if (state.errorMessage != null)
              Padding(
                padding: const EdgeInsets.only(top: 8.0),
                child: Text(
                  state.errorMessage!,
                  style: const TextStyle(color: Colors.red, fontSize: 12),
                ),
              ),
              
            if (state.isVerified == false)
              const Padding(
                padding: EdgeInsets.only(top: 8.0),
                child: Text(
                  "Niepoprawny kod. Spróbuj ponownie.",
                  style: TextStyle(color: Colors.red, fontSize: 12, fontWeight: FontWeight.bold),
                ),
              ),
              
             if (state.isVerified == true)
              const Padding(
                padding: EdgeInsets.only(top: 8.0),
                child: Text(
                  "Kod poprawny!",
                  style: TextStyle(color: Colors.green, fontSize: 12, fontWeight: FontWeight.bold),
                ),
              ),
          ],
        ),
      ),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/captcha/data/captcha_dio_provider.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Provider dedykowany dla mikroserwisu Captcha (port 8001)
final captchaDioProvider = Provider<Dio>((ref) {
  final dio = Dio(BaseOptions(
    // Dostosuj adres IP do swojego środowiska (podobnie jak w dio_provider.dart)
    // Jeśli używasz emulatora: http://10.0.2.2:8001
    // Jeśli fizyczne urządzenie/web: Twój adres LAN lub domena
    //baseUrl: 'http://127.0.0.1:8001', 
    baseUrl: 'https://dev-captcha.rafal-kruszyna.org',
    connectTimeout: const Duration(seconds: 5),
    receiveTimeout: const Duration(seconds: 5),
  ));
  return dio;
});


===============================
Ścieżka do pliku: ./lib/features/captcha/data/captcha_repository.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import './captcha_dio_provider.dart';
import 'models/captcha_model.dart';

// Provider repozytorium
final captchaRepositoryProvider = Provider<CaptchaRepository>((ref) {
  final dio = ref.watch(captchaDioProvider);
  return CaptchaRepository(dio);
});

class CaptchaRepository {
  final Dio _dio;

  CaptchaRepository(this._dio);

  Future<CaptchaModel> generateCaptcha() async {
    try {
      final response = await _dio.get('/api/v1/captcha');
      return CaptchaModel.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }

  Future<bool> verifyCaptcha(CaptchaVerifyRequest request) async {
    try {
      final response = await _dio.post(
        '/api/v1/captcha/verify',
        data: request.toJson(),
      );
      final result = CaptchaVerifyResponse.fromJson(response.data);
      return result.isValid;
    } catch (e) {
      // Jeśli serwer zwróci 422 (błąd walidacji), to technicznie nie jest poprawna captcha
      // Możesz tu obsłużyć to inaczej, ale na razie uznajmy to za false lub rzućmy błąd.
      rethrow; 
    }
  }
}


===============================
Ścieżka do pliku: ./lib/features/captcha/data/models/captcha_model.dart

Zawartość pliku:

class CaptchaModel {
  final String id; // UUID
  final String image; // Base64 string

  CaptchaModel({required this.id, required this.image});

  factory CaptchaModel.fromJson(Map<String, dynamic> json) {
    return CaptchaModel(
      id: json['id'] as String,
      image: json['image'] as String,
    );
  }
}

class CaptchaVerifyRequest {
  final String id;
  final String answer;

  CaptchaVerifyRequest({required this.id, required this.answer});

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'answer': answer,
    };
  }
}

class CaptchaVerifyResponse {
  final bool isValid;

  CaptchaVerifyResponse({required this.isValid});

  factory CaptchaVerifyResponse.fromJson(Map<String, dynamic> json) {
    return CaptchaVerifyResponse(
      isValid: json['is_valid'] as bool,
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/settings/presentation/settings_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:maia_flutter_client/core/navigation_provider.dart';
import 'controllers/settings_controller.dart';

class SettingsPage extends ConsumerStatefulWidget {
  const SettingsPage({super.key});

  @override
  ConsumerState<SettingsPage> createState() => _SettingsPageState();
}

class _SettingsPageState extends ConsumerState<SettingsPage> {
  
  // Metoda wywołująca dialog z potwierdzeniem
  Future<void> _confirmAccountDeletion(BuildContext context) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: const Row(
            children: [
              Icon(Icons.warning_amber_rounded, color: Colors.red),
              SizedBox(width: 12),
              Text("Usuń konto"),
            ],
          ),
          content: const Text(
            "Czy na pewno chcesz usunąć swoje konto? "
            "Operacja ta jest nieodwracalna. Wszystkie Twoje dane, "
            "postępy w nauce i historia zostaną trwale zanonimizowane lub usunięte.",
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(dialogContext).pop(false),
              child: const Text("ANULUJ"),
            ),
            FilledButton(
              style: FilledButton.styleFrom(
                backgroundColor: Colors.red,
                foregroundColor: Colors.white,
              ),
              onPressed: () => Navigator.of(dialogContext).pop(true),
              child: const Text("TAK, USUŃ KONTO"),
            ),
          ],
        );
      },
    );

    // Jeśli użytkownik potwierdził w dialogu
    if (confirmed == true && mounted) {
      _executeDeletion();
    }
  }

  Future<void> _executeDeletion() async {
    final success = await ref.read(settingsControllerProvider.notifier).deleteAccount();

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Twoje konto zostało usunięte. Przykro nam, że odchodzisz!'),
          backgroundColor: Colors.blueGrey,
          behavior: SnackBarBehavior.floating,
        ),
      );
      // Przekierowanie na stronę główną (Index 0) po wylogowaniu
      ref.read(navigationIndexProvider.notifier).state = 0;
    }
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(settingsControllerProvider);

    return Center(
      child: SingleChildScrollView(
        padding: const EdgeInsets.all(24.0),
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 600), // Lekko szersze na ustawienia
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // --- Nagłówek ---
              const Row(
                children: [
                  Icon(Icons.settings, size: 32, color: Colors.deepPurple),
                  SizedBox(width: 12),
                  Text(
                    "Ustawienia konta",
                    style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                  ),
                ],
              ),
              const SizedBox(height: 32),

              // Tutaj w przyszłości pojawią się inne karty (np. Powiadomienia, Język)
              Card(
                elevation: 1,
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        "Preferencje",
                        style: TextStyle(fontSize: 18, fontWeight: FontWeight.w600),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        "Wkrótce pojawią się tutaj opcje konfiguracyjne aplikacji...",
                        style: TextStyle(color: Colors.grey.shade600),
                      ),
                    ],
                  ),
                ),
              ),

              const SizedBox(height: 48),

              // ================= DANGER ZONE =================
              const Text(
                "Strefa niebezpieczna",
                style: TextStyle(
                  fontSize: 14, 
                  fontWeight: FontWeight.bold, 
                  color: Colors.red,
                  letterSpacing: 1.2,
                ),
              ),
              const SizedBox(height: 8),

              Container(
                padding: const EdgeInsets.all(20),
                decoration: BoxDecoration(
                  color: Colors.red.shade50,
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: Colors.red.shade200, width: 2),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Icon(Icons.person_off_outlined, color: Colors.red.shade700, size: 28),
                        const SizedBox(width: 12),
                        Text(
                          "Usunięcie konta",
                          style: TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: Colors.red.shade900,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    Text(
                      "Usunięcie konta spowoduje bezpowrotną utratę wszystkich danych związanych z Twoim profilem. "
                      "Tej operacji nie można cofnąć.",
                      style: TextStyle(color: Colors.red.shade900, height: 1.5),
                    ),
                    const SizedBox(height: 24),
                    
                    // Box z błędem wewnątrz Danger Zone (jeśli API wyrzuci błąd przy usuwaniu)
                    if (state.error != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: 16.0),
                        child: Container(
                          padding: const EdgeInsets.all(12),
                          decoration: BoxDecoration(
                            color: Colors.white,
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(color: Colors.red),
                          ),
                          child: Row(
                            children: [
                              const Icon(Icons.error, color: Colors.red),
                              const SizedBox(width: 12),
                              Expanded(
                                child: Text(
                                  state.error!,
                                  style: const TextStyle(color: Colors.red, fontWeight: FontWeight.w600),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),

                    // Przycisk akcji
                    SizedBox(
                      width: double.infinity,
                      child: FilledButton.icon(
                        onPressed: state.isLoading 
                            ? null 
                            : () => _confirmAccountDeletion(context),
                        style: FilledButton.styleFrom(
                          backgroundColor: Colors.red.shade600,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(vertical: 16),
                        ),
                        icon: state.isLoading 
                            ? const SizedBox.shrink() 
                            : const Icon(Icons.delete_forever),
                        label: state.isLoading
                            ? const SizedBox(
                                width: 20, height: 20,
                                child: CircularProgressIndicator(color: Colors.white, strokeWidth: 2),
                              )
                            : const Text("TRWALE USUŃ KONTO"),
                      ),
                    ),
                  ],
                ),
              ),
              // ================= END DANGER ZONE =================
            ],
          ),
        ),
      ),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/settings/presentation/controllers/settings_controller.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/network/api_error_handler.dart';
import '../../../auth/data/auth_repository.dart';
import '../../../auth/presentation/controllers/auth_controller.dart';

// Stan dla ustawień
class SettingsState {
  final bool isLoading;
  final String? error;

  const SettingsState({
    this.isLoading = false,
    this.error,
  });

  SettingsState copyWith({bool? isLoading, String? error}) {
    return SettingsState(
      isLoading: isLoading ?? this.isLoading,
      error: error, // Przekazanie nulla wyczyści błąd
    );
  }
}

class SettingsController extends StateNotifier<SettingsState> {
  final AuthRepository _repository;
  final AuthController _authController;

  SettingsController(this._repository, this._authController) : super(const SettingsState());

  Future<bool> deleteAccount() async {
    state = const SettingsState(isLoading: true, error: null);

    try {
      // Wywołanie API do usunięcia konta
      await _repository.deleteAccount();
      
      // Jeżeli API zwróci 204, wylogowujemy użytkownika lokalnie z aplikacji
      // i czyścimy tokeny. Wywołujemy globalny AuthController.
      await _authController.logout();
      
      state = const SettingsState(isLoading: false);
      return true;
    } catch (e) {
      final msg = ApiErrorHandler.getErrorMessage(e);
      state = state.copyWith(isLoading: false, error: msg);
      return false;
    }
  }
}

// Provider kontrolera
final settingsControllerProvider = StateNotifierProvider.autoDispose<SettingsController, SettingsState>((ref) {
  return SettingsController(
    ref.watch(authRepositoryProvider),
    ref.read(authControllerProvider.notifier),
  );
});


===============================
Ścieżka do pliku: ./lib/core/app_sizes.dart

Zawartość pliku:

class AppSizes{
  static const double maxMobileWidth = 550.0;
}


===============================
Ścieżka do pliku: ./lib/core/navigation_provider.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';

final navigationIndexProvider = StateProvider<int>((ref) => 0);


===============================
Ścieżka do pliku: ./lib/core/config/api_config.dart

Zawartość pliku:

class ApiConfig {
  // Unikamy instancjonowania tej klasy
  ApiConfig._();

  // Adresy bazowe dla środowiska DEV
  // W przyszłości można tu dodać logikę do przełączania na PROD
  static const String authBaseUrl = 'https://dev-auth.rafal-kruszyna.org';
  static const String sentencesBaseUrl = 'https://dev-sentences.rafal-kruszyna.org';
  static const String captchaBaseUrl = 'https://dev-captcha.rafal-kruszyna.org';
  
  // Timeouty
  static const Duration connectTimeout = Duration(seconds: 10);
  static const Duration receiveTimeout = Duration(seconds: 10);
}


===============================
Ścieżka do pliku: ./lib/core/widgets/main_drawer.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import "../../features/auth/presentation/controllers/auth_controller.dart";
import '../navigation_provider.dart';

class MainDrawer extends ConsumerWidget {
  const MainDrawer({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedIndex = ref.watch(navigationIndexProvider);
    // Obserwujemy stan autentykacji
    final authState = ref.watch(authControllerProvider);
    final isLoggedIn = authState.isAuthenticated;

    return Drawer(
      child: ListView(
        padding: EdgeInsets.zero,
        children: [
          DrawerHeader(
            decoration: BoxDecoration(color: Colors.deepPurple),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                Text(
                  'English Learner',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  isLoggedIn ? 'Witaj, użytkowniku!' : 'Tryb Gościa',
                  style: const TextStyle(color: Colors.white70, fontSize: 14),
                ),
                Text(
                  'Twój postęp: 45%',
                  style: TextStyle(color: Colors.white70, fontSize: 14),
                ),
              ],
            ),
          ),
          _DrawerTile(
            title: 'Ogłoszenia parafialne',
            icon: Icons.home,
            index: 0,
            isSelected: selectedIndex == 0,
          ),
          _DrawerTile(
            title: 'Slownik',
            icon: Icons.menu_book,
            index: 1,
            isSelected: selectedIndex == 1,
          ),
          _DrawerTile(
            title: 'Slowka',
            icon: Icons.school,
            index: 2,
            isSelected: selectedIndex == 2,
          ),
          _DrawerTile(
            title: 'Zwroty',
            icon: Icons.chat,
            index: 3,
            isSelected: selectedIndex == 3,
          ),
          _DrawerTile(
            title: 'Rejestracja',
            icon: Icons.chat,
            index: 4,
            isSelected: selectedIndex == 4,
          ),
          _DrawerTile(
            title: 'Logowanie',
            icon: Icons.login,
            index: 5,
            isSelected: selectedIndex == 5,
          ),
          const Divider(),
          const Padding(
            padding: EdgeInsets.only(left: 16, top: 8, bottom: 8),
            child: Text(
              "DEV TOOLS",
              style: TextStyle(color: Colors.grey, fontSize: 12),
            ),
          ),
          _DrawerTile(
            title: 'Test',
            icon: Icons.quiz,
            index: 6,
            isSelected: selectedIndex == 6,
          ),
          _DrawerTile(
            title: 'Health Check',
            icon: Icons.dns,
            index: 7,
            isSelected: selectedIndex == 7,
          ),
          _DrawerTile(
            title: 'Captcha Test',
            icon: Icons.security,
            index: 8,
            isSelected: selectedIndex == 8,
          ),
        ],
      ),
    );
  }
}

// _DrawerTile pozostaje bez zmian jak w Twoim pliku
class _DrawerTile extends ConsumerWidget {
  final String title;
  final IconData icon;
  final int index;
  final bool isSelected;

  const _DrawerTile({
    required this.title,
    required this.icon,
    required this.index,
    required this.isSelected,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ListTile(
      leading: Icon(icon, color: isSelected ? Colors.deepPurple : null),
      title: Text(
        title,
        style: TextStyle(
          color: isSelected ? Colors.deepPurple : null,
          fontWeight: isSelected ? FontWeight.bold : null,
        ),
      ),
      selected: isSelected,
      selectedTileColor: Colors.deepPurple.withValues(alpha: 0.1),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      onTap: () {
        ref.read(navigationIndexProvider.notifier).state = index;
        Navigator.pop(context);
      },
    );
  }
}



===============================
Ścieżka do pliku: ./lib/core/network/auth_interceptor_provider.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../features/auth/data/token_storage.dart';

// Provider zwracający skonfigurowany Interceptor
final authInterceptorProvider = Provider<Interceptor>((ref) {
  final storage = ref.watch(tokenStorageProvider);
  return AuthInterceptor(storage);
});

class AuthInterceptor extends Interceptor {
  final TokenStorage _storage;

  AuthInterceptor(this._storage);

  @override
  Future<void> onRequest(RequestOptions options, RequestInterceptorHandler handler) async {
    // Pobierz token
    final token = await _storage.getToken();

    // Dodaj nagłówek jeśli token istnieje
    if (token != null) {
      options.headers['Authorization'] = 'Bearer ${token.accessToken}';
    }

    return handler.next(options);
  }

  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    // Tu w przyszłości dodasz logikę odświeżania tokena (Refresh Token)
    // jeśli err.response?.statusCode == 401
    return handler.next(err);
  }
}


===============================
Ścieżka do pliku: ./lib/core/network/dio_provider.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/api_config.dart'; // Import configu
import 'auth_interceptor_provider.dart'; // Import interceptora

final dioProvider = Provider<Dio>((ref) {
  final dio = Dio(BaseOptions(
    baseUrl: ApiConfig.sentencesBaseUrl, // Adres mikroserwisu zdań
    connectTimeout: ApiConfig.connectTimeout,
    receiveTimeout: ApiConfig.receiveTimeout,
  ));

  // Używamy tego samego interceptora co w authDioProvider (DRY!)
  final authInterceptor = ref.watch(authInterceptorProvider);
  dio.interceptors.add(authInterceptor);

  return dio;
});


===============================
Ścieżka do pliku: ./lib/core/network/api_error_handler.dart

Zawartość pliku:

import 'package:dio/dio.dart';

class ApiErrorHandler {
  static String getErrorMessage(Object error) {
    if (error is DioException) {
      switch (error.type) {
        case DioExceptionType.connectionTimeout:
        case DioExceptionType.sendTimeout:
        case DioExceptionType.receiveTimeout:
          return "Upłynął limit czasu połączenia. Sprawdź internet.";

        case DioExceptionType.badResponse:
          return _handleBadResponse(error.response);

        case DioExceptionType.connectionError:
          return "Brak połączenia z serwerem. Sprawdź internet.";

        case DioExceptionType.cancel:
          return "Żądanie zostało anulowane.";

        default:
          return "Wystąpił nieznany błąd sieciowy.";
      }
    } else {
      return "Wystąpił niespodziewany błąd: ${error.toString()}";
    }
  }

  static String _handleBadResponse(Response? response) {
    if (response == null) return "Nieznany błąd serwera.";

    final dynamic data = response.data;
    final int? statusCode = response.statusCode;

    // KROK 1: Sprawdź, czy serwer przysłał konkretny komunikat błędu.
    if (data is Map) {
      // Obsługa błędu 422 (FastAPI Validation Error)
      if (statusCode == 422 && data['detail'] is List) {
        final list = data['detail'] as List;
        if (list.isNotEmpty && list.first is Map) {
          final firstMsg = list.first['msg'];

          // --- POPRAWKA TUTAJ ---
          // Musimy przetłumaczyć wiadomość wyciągniętą z listy!
          final translatedMsg = _translateMessage(firstMsg.toString());

          return "Błąd walidacji: $translatedMsg";
        }
      }

      // Standardowa obsługa (400, 401, 409...) - detail to String
      if (data['detail'] != null && data['detail'] is String) {
        return _translateMessage(data['detail']);
      }
    }

    // KROK 2: Fallback (Estymacja po kodzie)
    switch (statusCode) {
      case 400:
        return "Nieprawidłowe żądanie (400).";
      case 401:
        return "Błąd autentykacji. Zaloguj się ponownie.";
      case 403:
        return "Brak dostępu do zasobu.";
      case 404:
        return "Nie znaleziono zasobu (404).";
      case 409:
        return "Konflikt danych (409).";
      case 429:
        return "Zbyt wiele zapytań. Zwolnij chwilę.";
      case 500:
      case 502:
        return "Błąd serwera ($statusCode). Spróbuj później.";
      case 503:
        return "Serwer jest niedostępny (Trwają prace techniczne lub przeciążenie).";
      default:
        return "Wystąpił błąd ($statusCode).";
    }
  }

  static String _translateMessage(String msg) {
    // Prosty słownik tłumaczeń najczęstszych błędów z backendu

    // --- NOWE TŁUMACZENIA DLA USERNAME (Auth Service) ---
    if (msg.contains("Username must be at least 3 characters long")) {
      return "Nazwa użytkownika musi mieć co najmniej 3 znaki.";
    }
    if (msg.contains("Username cannot be longer than 30 characters")) {
      return "Nazwa użytkownika nie może mieć więcej niż 30 znaków.";
    }
    if (msg.contains("Username can only contain letters, numbers")) {
      return "Nazwa użytkownika może zawierać tylko litery, cyfry, podkreślenia (_) i myślniki (-).";
    }
    if (msg.contains("This username is reserved")) {
      return "Ta nazwa użytkownika jest zastrzeżona i nie może zostać użyta.";
    }
    if (msg.contains("Username cannot contain '@' symbol")) {
      return "Nazwa użytkownika nie może zawierać znaku '@'.";
    }
    if (msg.contains("consecutive underscores or hyphens")) {
      return "Nazwa użytkownika nie może zawierać podwójnych podkreśleń lub myślników.";
    }
    // ----------------------------------------------------

    if (msg.contains("User with this email already exists")) {
      return "Użytkownik o tym adresie email już istnieje.";
    }
    if (msg.contains("User with this username already exists")) {
      return "Ta nazwa użytkownika jest już zajęta.";
    }
    if (msg.contains("Username already taken")) {
      return "Ta nazwa użytkownika jest już zajęta.";
    }
    if (msg.contains("Incorrect email or password")) {
      return "Niepoprawny email lub hasło.";
    }
    if (msg.contains("Inactive user")) {
      return "Konto jest nieaktywne.";
    }
    if (msg.contains("Invalid captcha")) {
      return "Niepoprawny kod Captcha.";
    }
    if (msg.contains("Invalid CAPTCHA answer")) {
      return "Niepoprawny kod Captcha.";
    }
    if (msg.contains("Email already registered")) {
      return "Ten adres email jest już zarejestrowany.";
    }
    if (msg.contains("value is not a valid email address")) {
      return "Niepoprawny format adresu email.";
    }
    if (msg.contains("Password must be at least 6 characters long")) {
      return "Hasło musi mieć co najmniej 6 znaków.";
    }
    if (msg.contains("Password must contain at least one digit")) {
      return "Hasło musi zawierać co najmniej jedną cyfrę.";
    }
    if (msg.contains("Password must contain at least one letter")) {
      return "Hasło musi zawierać co najmniej jedną literę.";
    }
    if (msg.contains("String should have at least 6 characters")) {
      return "Wartość jest za krótka (wymagane min. 6 znaków).";
    }
    //auth service error
    if(msg.contains("Database error: Resource is locked. Service temporarily unavailable.")){
      return "Serwis jest chwilowo zajęty (baza danych zablokowana). Spróbuj ponownie za chwilę.";
    }
    //auth service error
    if(msg.contains("Database error: Internal operation failed.")){
      return "Wystąpił wewnętrzny błąd bazy danych. Spróbuj ponownie.";
    }

    // Jeśli nie mamy tłumaczenia, zwracamy oryginał (np. "Password is too short")
    return msg;
  }
}


