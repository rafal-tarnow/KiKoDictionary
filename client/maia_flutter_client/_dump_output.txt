===============================
Ścieżka do pliku: ./lib/app.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:maia_flutter_client/features/auth/presentation/login_page.dart';
import 'package:maia_flutter_client/features/auth/presentation/register_page.dart';
import 'package:maia_flutter_client/features/auth/presentation/widgets/user_avatar_button.dart';
import 'core/navigation_provider.dart';
import 'core/widgets/main_drawer.dart';
import 'features/home/home_page.dart';
import 'features/home/home_app_bar.dart';
import 'features/dictionary/dictionary_page.dart';
import 'features/words/words_page.dart';
import 'features/sentences/sentences_page.dart';
import 'features/sentences/sentences_app_bar.dart';
import 'features/test/test_page.dart';
import 'features/test/test_app_bar.dart';
import 'core/app_sizes.dart'; // Import stałych
import 'features/health/services_health_page.dart';
import 'features/captcha/captcha_page.dart';

class MainShell extends ConsumerWidget {
  const MainShell({super.key});

  static const List<Widget> _pages = [
    HomePage(),
    DictionaryPage(),
    WordsPage(),
    SentencesPage(),
    RegisterPage(),
    LoginPage(),
    TestPage(),
    ServicesHealthPage(),
    CaptchaPage(),
  ];

  static final List<PreferredSizeWidget> _appBars = [
    const HomeAppBar(),
    AppBar(
      title: const Text("Dictionary"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    AppBar(
      title: const Text("Words"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    const SentencesAppBar(),
    AppBar(
      title: const Text("Rejestracja"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    AppBar(
      title: const Text("Logowanie"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    const TestAppBar(),
    AppBar(
      title: const Text("Health Check"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
    AppBar(
      title: const Text("Captcha Demo"),
      elevation: 2,
      actions: const [UserAvatarButton()],
    ),
  ];

  // static const List<String> _titles = [
  //   'Ogłoszenia parafialne',
  //   'Dictionary',
  //   'Words',
  //   'Sentences',
  //   'Test',
  //   'Health Check',
  // ];

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedIndex = ref.watch(navigationIndexProvider);

    return Container(
      //szare tło aplikacji
      // Zamieniamy surfaceVariant na surfaceContainerHighest
      color: const Color(0xFFE0E0E0),
      // color: Theme.of(
      //   context,
      // ).colorScheme.surfaceContainer,
      //color: const Color(0xFFE0E0E0),
      // color: Theme.of(
      //   context,
      // ).colorScheme.surfaceContainerHighest.withOpacity(0.5),
      child: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: AppSizes.maxMobileWidth),
          child: Container(
            // Ten kontener dodaje cień i ogranicza Scaffold
            decoration: BoxDecoration(
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withValues(alpha: 0.05),
                  blurRadius: 10,
                ),
              ],
            ),
            child: ClipRect(
              //ClipRect jest potrzebny bo inaczej boczny Drawer rysuje sie poza oknem aplikacji w widoku np na tablecie, dlatego trzeba przyciac Drawer do glownego słupka aplikacji
              child: Scaffold(
                //backgroundColor: Theme.of(context).colorScheme.surface,
                backgroundColor: const Color(0xFFFFFFFF),
                appBar: _appBars[selectedIndex],
                // appBar: AppBar(
                //   title: Text(_titles[selectedIndex]),
                //   elevation: 2,
                // ),
                drawer: const MainDrawer(),
                //body: _pages[selectedIndex],
                body: IndexedStack(index: selectedIndex, children: _pages),
              ),
            ),
          ),
        ),
      ),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/main.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'app.dart';

void main() {
  // ProviderScope przechowuje stan wszystkich providerów
  runApp(const ProviderScope(child: MyApp()));
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'English Learning App',
      theme: ThemeData(
        //colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      home: const MainShell(),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/features/home/home_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';

class HomePage extends StatelessWidget {
  const HomePage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(child: Text('Strona Główna - Nauka Angielskiego')),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/home/home_app_bar.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:maia_flutter_client/features/auth/presentation/widgets/user_avatar_button.dart';

class HomeAppBar extends StatelessWidget implements PreferredSizeWidget {
  const HomeAppBar({super.key});

  @override
  Widget build(BuildContext context) {
    return AppBar(
      title: const Text("Ogłoszenia parafialne"),
      elevation: 2,
      // Nie musisz dodawać leading/hamburgera - Flutter doda go sam!
      actions: [
        IconButton(
          icon: const Icon(Icons.notifications),
          onPressed: () {},
        ),
        const UserAvatarButton(),
      ],
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}


===============================
Ścieżka do pliku: ./lib/features/auth/presentation/login_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // Do AutofillHints
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:maia_flutter_client/core/navigation_provider.dart';
import 'auth_controller.dart';

class LoginPage extends ConsumerStatefulWidget {
  const LoginPage({super.key});

  @override
  ConsumerState<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends ConsumerState<LoginPage> {
  final _formKey = GlobalKey<FormState>();
  
  // W UI nazywamy to _emailCtrl, żeby wiedzieć co wpisuje user,
  // ale do controllera przekażemy to jako "username" (zgodnie ze standardem OAuth2).
  final _emailCtrl = TextEditingController();
  final _passCtrl = TextEditingController();

  // Lokalny stan widoku (dla ukrywania hasła)
  bool _isPasswordVisible = false;

  @override
  void dispose() {
    _emailCtrl.dispose();
    _passCtrl.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    // 1. Walidacja formularza
    if (!_formKey.currentState!.validate()) return;

    // Ukryj klawiaturę (UX)
    FocusScope.of(context).unfocus();

    // Zapisz stan autofill (dla password managerów)
    TextInput.finishAutofillContext();

    // 2. Wywołanie logiki biznesowej
    // Używamy read, bo wykonujemy akcję jednorazową
    final success = await ref.read(authControllerProvider.notifier).login(
      _emailCtrl.text.trim(),
      _passCtrl.text,
    );

    // 3. Obsługa wyniku (tylko nawigacja/sukces, błędy są w stanie authState)
    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Zalogowano pomyślnie!'),
          backgroundColor: Colors.green,
          behavior: SnackBarBehavior.floating,
        ),
      );

      // Przekierowanie na stronę główną (Index 0)
      ref.read(navigationIndexProvider.notifier).state = 0;
    }
  }

  @override
  Widget build(BuildContext context) {
    // Obserwujemy stan autentykacji (np. czy trwa ładowanie, czy jest błąd)
    final authState = ref.watch(authControllerProvider);

    return Scaffold(
      // AppBar opcjonalny, zależy czy strona jest w Drawerze czy osobno
      // Tutaj zakładam, że będzie w MainShell, więc AppBar dostarczy shell.
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 400),
            child: Form(
              key: _formKey,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  // --- Nagłówek ---
                  const Icon(Icons.lock_person_outlined, size: 80, color: Colors.deepPurple),
                  const SizedBox(height: 24),
                  Text(
                    "Witaj ponownie!",
                    style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: Colors.black87,
                        ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    "Zaloguj się, aby kontynuować naukę.",
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                          color: Colors.grey[600],
                        ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 32),

                  // --- Email Field ---
                  TextFormField(
                    controller: _emailCtrl,
                      // Logika UI wymusza email
                      keyboardType: TextInputType.emailAddress,
                      autofillHints: const [AutofillHints.email],
                    decoration: const InputDecoration(
                      labelText: "Adres email",
                      prefixIcon: Icon(Icons.email_outlined),
                      border: OutlineInputBorder(),
                      hintText: "np. tom@example.com",
                    ),
                    textInputAction: TextInputAction.next, // Przycisk "Dalej"
                    enabled: !authState.isLoading,
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Wpisz adres email';
                        }
                        // Walidacja formatu
                        if (!value.contains('@') || !value.contains('.')) {
                          return 'Niepoprawny format email';
                        }
                        return null;
                      },
                  ),
                  const SizedBox(height: 16),

                  // --- Password Field ---
                  TextFormField(
                    controller: _passCtrl,
                    obscureText: !_isPasswordVisible,
                    decoration: InputDecoration(
                      labelText: "Hasło",
                      prefixIcon: const Icon(Icons.lock_outline),
                      border: const OutlineInputBorder(),
                      suffixIcon: IconButton(
                        icon: Icon(
                          _isPasswordVisible ? Icons.visibility : Icons.visibility_off,
                        ),
                        onPressed: () {
                          setState(() {
                            _isPasswordVisible = !_isPasswordVisible;
                          });
                        },
                      ),
                    ),
                    textInputAction: TextInputAction.done, // Przycisk "Gotowe"
                    onFieldSubmitted: (_) => _submit(), // Enter zatwierdza
                    enabled: !authState.isLoading,
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Wpisz hasło';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 24),

                  // --- Error Message Display ---
                  // Wyświetlamy błąd globalny z Controllera (np. 401 Unauthorized)
                  if (authState.error != null)
                    Padding(
                      padding: const EdgeInsets.only(bottom: 16.0),
                      child: Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.red.shade50,
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.red.shade200),
                        ),
                        child: Row(
                          children: [
                            const Icon(Icons.error_outline, color: Colors.red),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Text(
                                authState.error!,
                                style: TextStyle(color: Colors.red.shade900),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),

                  // --- Submit Button ---
                  FilledButton(
                    onPressed: authState.isLoading ? null : _submit,
                    style: FilledButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      textStyle: const TextStyle(fontSize: 16),
                    ),
                    child: authState.isLoading
                        ? const SizedBox(
                            width: 24,
                            height: 24,
                            child: CircularProgressIndicator(
                              color: Colors.white,
                              strokeWidth: 2,
                            ),
                          )
                        : const Text("ZALOGUJ SIĘ"),
                  ),
                  
                  const SizedBox(height: 16),
                  
                  // --- Link do rejestracji ---
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Text("Nie masz konta?"),
                      TextButton(
                        onPressed: authState.isLoading 
                            ? null 
                            : () {
                                // Nawigacja do rejestracji (Index 4 w AppShell)
                                ref.read(navigationIndexProvider.notifier).state = 4; 
                              },
                        child: const Text("Zarejestruj się"),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/auth/presentation/register_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:maia_flutter_client/core/navigation_provider.dart';
import '../../captcha/presentation/widgets/captcha_box.dart';
import '../../captcha/presentation/captcha_controller.dart';
import 'auth_controller.dart';

class RegisterPage extends ConsumerStatefulWidget {
  const RegisterPage({super.key});

  @override
  ConsumerState<RegisterPage> createState() => _RegisterPageState();
}

class _RegisterPageState extends ConsumerState<RegisterPage> {
  final _formKey = GlobalKey<FormState>();
  
  // Kontrolery
  final _emailCtrl = TextEditingController();
  final _userCtrl = TextEditingController();
  final _passCtrl = TextEditingController();
  final _captchaInputCtrl = TextEditingController();

  // Lokalny stan widoku
  bool _isPasswordVisible = false;

  @override
  void dispose() {
    _emailCtrl.dispose();
    _userCtrl.dispose();
    _passCtrl.dispose();
    _captchaInputCtrl.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    // 1. Walidacja lokalna formularza
    if (!_formKey.currentState!.validate()) return;

    // 2. Walidacja czy captcha w ogóle załadowana
    final captchaState = ref.read(captchaControllerProvider);
    if (captchaState.captcha == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Błąd Captchy. Odśwież obrazek.')),
      );
      return;
    }

    // UX: Ukryj klawiaturę
    FocusScope.of(context).unfocus();

    // 3. Strzał do API
    final success = await ref.read(authControllerProvider.notifier).register(
      email: _emailCtrl.text,
      username: _userCtrl.text,
      password: _passCtrl.text,
      captchaId: captchaState.captcha!.id,
      captchaAnswer: _captchaInputCtrl.text,
    );

    // 4. Obsługa wyniku
    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Konto założone! Możesz się zalogować.'),
          backgroundColor: Colors.green,
          behavior: SnackBarBehavior.floating,
        ),
      );

      // Czyścimy formularz
      _emailCtrl.clear();
      _userCtrl.clear();
      _passCtrl.clear();
      _captchaInputCtrl.clear();
      
      // Przekierowanie do logowania (Index 5 w MainShell)
      ref.read(navigationIndexProvider.notifier).state = 5; 
      
      // Pobranie nowej captchy "na zaś"
      ref.read(captchaControllerProvider.notifier).fetchCaptcha();
    } else {
      // W przypadku błędu (np. zły kod captcha), musimy pobrać nowy obrazek,
      // bo stary token na serwerze został "spalony" przy próbie weryfikacji.
      if (mounted) {
        _captchaInputCtrl.clear();
        ref.read(captchaControllerProvider.notifier).fetchCaptcha();
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final authState = ref.watch(authControllerProvider);

    return Scaffold(
      // Body jest centrowane i scrollowalne - identycznie jak w LoginPage
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 400),
            child: Form(
              key: _formKey,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  // --- NAGŁÓWEK ---
                  const Icon(Icons.person_add_alt_1_outlined, size: 80, color: Colors.deepPurple),
                  const SizedBox(height: 24),
                  Text(
                    "Utwórz konto",
                    style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: Colors.black87,
                        ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    "Dołącz do nas i zacznij naukę.",
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                          color: Colors.grey[600],
                        ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 32),

                  // --- EMAIL ---
                  TextFormField(
                    controller: _emailCtrl,
                    decoration: const InputDecoration(
                      labelText: "Adres email",
                      prefixIcon: Icon(Icons.email_outlined),
                      border: OutlineInputBorder(),
                    ),
                    keyboardType: TextInputType.emailAddress,
                    textInputAction: TextInputAction.next,
                    enabled: !authState.isLoading,
                    validator: (v) {
                      if (v == null || v.isEmpty) return 'Wpisz email';
                      if (!v.contains('@')) return 'Niepoprawny format email';
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // --- USERNAME ---
                  TextFormField(
                    controller: _userCtrl,
                    decoration: const InputDecoration(
                      labelText: "Nazwa użytkownika",
                      prefixIcon: Icon(Icons.person_outline),
                      border: OutlineInputBorder(),
                    ),
                    textInputAction: TextInputAction.next,
                    enabled: !authState.isLoading,
                    validator: (v) {
                      if (v == null || v.isEmpty) return 'Wpisz nazwę użytkownika';
                      if (v.length < 3) return 'Minimum 3 znaki';
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // --- HASŁO (z okiem) ---
                  TextFormField(
                    controller: _passCtrl,
                    obscureText: !_isPasswordVisible, // Logika ukrywania
                    decoration: InputDecoration(
                      labelText: "Hasło",
                      prefixIcon: const Icon(Icons.lock_outline),
                      border: const OutlineInputBorder(),
                      // Ikona oka
                      suffixIcon: IconButton(
                        icon: Icon(
                          _isPasswordVisible ? Icons.visibility : Icons.visibility_off,
                        ),
                        onPressed: () {
                          setState(() {
                            _isPasswordVisible = !_isPasswordVisible;
                          });
                        },
                      ),
                    ),
                    textInputAction: TextInputAction.next,
                    enabled: !authState.isLoading,
                    validator: (v) {
                      if (v == null || v.isEmpty) return 'Wpisz hasło';

                      // Sprawdzamy wszystkie warunki naraz
                      bool hasMinLength = v.length >= 6;
                      bool hasDigit = RegExp(r'\d').hasMatch(v);
                      bool hasLetter = RegExp(r'[a-zA-Z]').hasMatch(v);

                      // Jeśli którykolwiek warunek nie jest spełniony, zwracamy pełną instrukcję
                      // Zwracamy odrazu bład na wszystkie warunki, żeby użytkownik miał 
                      // lepsze UI/UX experience, i zeby odrazu znał wszystkie warunki prawidlowego hasla - nie usuwac tego komentarza
                      if (!hasMinLength || !hasDigit || !hasLetter) {
                        return 'Hasło musi mieć min. 6 znaków, literę i cyfrę';
                      }

                      return null;
                    },
                  ),
                  const SizedBox(height: 24),

                  // --- CAPTCHA ---
                  const Text("Weryfikacja bezpieczeństwa", style: TextStyle(fontWeight: FontWeight.bold)),
                  const SizedBox(height: 8),
                  CaptchaBox(answerController: _captchaInputCtrl),
                  
                  const SizedBox(height: 24),

                  // --- ERROR BOX (Wystylizowany jak w Login) ---
                  if (authState.error != null)
                    Padding(
                      padding: const EdgeInsets.only(bottom: 16.0),
                      child: Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.red.shade50,
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.red.shade200),
                        ),
                        child: Row(
                          children: [
                            const Icon(Icons.error_outline, color: Colors.red),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Text(
                                authState.error!,
                                style: TextStyle(color: Colors.red.shade900),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),

                  // --- PRZYCISK REJESTRACJI ---
                  FilledButton(
                    onPressed: authState.isLoading ? null : _submit,
                    style: FilledButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      textStyle: const TextStyle(fontSize: 16),
                    ),
                    child: authState.isLoading
                        ? const SizedBox(
                            width: 24,
                            height: 24,
                            child: CircularProgressIndicator(
                              color: Colors.white,
                              strokeWidth: 2,
                            ),
                          )
                        : const Text("UTWÓRZ KONTO"),
                  ),

                  const SizedBox(height: 16),

                  // --- LINK DO LOGOWANIA ---
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Text("Masz już konto?"),
                      TextButton(
                        onPressed: authState.isLoading 
                            ? null 
                            : () {
                                // Nawigacja do logowania (Index 5 w AppShell)
                                ref.read(navigationIndexProvider.notifier).state = 5; 
                              },
                        child: const Text("Zaloguj się"),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/auth/presentation/auth_controller.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:maia_flutter_client/core/network/api_error_handler.dart';
import '../data/auth_repository.dart';
import '../data/token_storage.dart';

// Stan autentykacji
class AuthState {
  final bool isAuthenticated;
  final bool isLoading;
  final String? error;

  const AuthState({
    this.isAuthenticated = false, 
    this.isLoading = true, // Domyślnie true, bo przy starcie sprawdzamy storage
    this.error
  });
  
  AuthState copyWith({bool? isAuthenticated, bool? isLoading, String? error}) {
    return AuthState(
      isAuthenticated: isAuthenticated ?? this.isAuthenticated,
      isLoading: isLoading ?? this.isLoading,
      error: error,
    );
  }
}

class AuthController extends StateNotifier<AuthState> {
  final AuthRepository _repository;
  final TokenStorage _storage;

  AuthController(this._repository, this._storage) : super(const AuthState()) {
    checkAuthStatus();
  }

  // Sprawdza przy starcie apki, czy mamy token
  Future<void> checkAuthStatus() async {
    final token = await _storage.getToken();
    if (token != null) {
      // Opcjonalnie: Tutaj można strzelić do /api/v1/users/me żeby sprawdzić czy token jest nadal ważny
      state = const AuthState(isAuthenticated: true, isLoading: false);
    } else {
      state = const AuthState(isAuthenticated: false, isLoading: false);
    }
  }

Future<bool> login(String username, String password) async {
    // Resetujemy błąd i włączamy loading
    state = state.copyWith(isLoading: true, error: null);
    
    try {
      final token = await _repository.login(username: username, password: password);
      await _storage.saveToken(token);
      
      // SUKCES
      state = const AuthState(isAuthenticated: true, isLoading: false);
      return true;
    } catch (e) {
      // BŁĄD: Używamy Twojego ApiErrorHandler, który już obsługuje 400, 401, 422 itd.
      final msg = ApiErrorHandler.getErrorMessage(e);
      
      state = state.copyWith(
        isLoading: false, 
        error: msg, 
        isAuthenticated: false
      );
      return false;
    }
  }

  Future<bool> register({
    required String email,
    required String username,
    required String password,
    required String captchaId,
    required String captchaAnswer,
  }) async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      await _repository.register(
        email: email,
        username: username,
        password: password,
        captchaId: captchaId,
        captchaAnswer: captchaAnswer,
      );
      state = state.copyWith(isLoading: false);
      return true; // Sukces rejestracji
    } catch (e) {
      // ZMIANA: Usuwamy prefiks "Błąd rejestracji. ", bo ErrorHandler zwróci nam już konkretny opis.
      // Dzięki temu user zobaczy: "Użytkownik o tym adresie email już istnieje."
      // zamiast: "Błąd rejestracji. Użytkownik o tym adresie email już istnieje."
      final msg = ApiErrorHandler.getErrorMessage(e);
      state = state.copyWith(isLoading: false, error: msg);
      return false;
    }
  }

  Future<void> logout() async {
    final token = await _storage.getToken();
    if (token != null) {
       try {
         await _repository.logout(token.refreshToken);
       } catch (_) {
         // Ignorujemy błędy sieciowe przy wylogowaniu
       }
    }
    await _storage.clearToken();
    state = const AuthState(isAuthenticated: false, isLoading: false);
  }
}

// Globalny provider stanu autentykacji
final authControllerProvider = StateNotifierProvider<AuthController, AuthState>((ref) {
  return AuthController(
    ref.watch(authRepositoryProvider),
    ref.watch(tokenStorageProvider),
  );
});


===============================
Ścieżka do pliku: ./lib/features/auth/presentation/widgets/user_avatar_button.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../../core/navigation_provider.dart';
import '../auth_controller.dart';

class UserAvatarButton extends ConsumerWidget {
  const UserAvatarButton({super.key});

  static const int _loginPageIndex = 5;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authControllerProvider);
    final bool isLoggedIn = authState.isAuthenticated;

    // --- STAN: ZALOGOWANY (Menu Popup) ---
    if (isLoggedIn) {
      return Padding(
        padding: const EdgeInsets.only(right: 8.0),
        child: PopupMenuButton<String>(
          offset: const Offset(0, 50),
          tooltip: 'Menu użytkownika',
          // Zaokrąglenie samego okienka menu
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          
          // KLUCZOWA ZMIANA:
          // Używamy parametru 'icon' zamiast 'child'.
          // Dzięki temu Flutter traktuje to jako standardową ikonę na pasku
          // i automatycznie dodaje okrągły efekt "ink splash" przy kliknięciu/najechaniu.
          icon: CircleAvatar(
            radius: 18,
            backgroundColor: Colors.deepPurple.shade100,
            child: const Icon(Icons.person, color: Colors.deepPurple, size: 20),
          ),
          
          onSelected: (value) {
            if (value == 'logout') {
              _handleLogout(context, ref);
            }
          },
          
          itemBuilder: (BuildContext context) => <PopupMenuEntry<String>>[
            const PopupMenuItem<String>(
              enabled: false,
              child: Text(
                "Moje Konto", 
                style: TextStyle(fontWeight: FontWeight.bold, fontSize: 12, color: Colors.grey),
              ),
            ),
            const PopupMenuDivider(),
            const PopupMenuItem<String>(
              value: 'logout',
              child: Row(
                children: [
                  Icon(Icons.logout, color: Colors.red, size: 20),
                  SizedBox(width: 12),
                  Text('Wyloguj się', style: TextStyle(color: Colors.black87)),
                ],
              ),
            ),
          ],
        ),
      );
    }

    // --- STAN: NIEZALOGOWANY (Przycisk Logowania) ---
    return Padding(
      padding: const EdgeInsets.only(right: 8.0),
      child: IconButton(
        tooltip: "Zaloguj się",
        // Tutaj też używamy standardowego IconButton, który ma okrągły splash
        icon: CircleAvatar(
          radius: 18,
          backgroundColor: Colors.grey.shade200,
          child: Icon(Icons.login, color: Colors.grey.shade700, size: 20),
        ),
        onPressed: () {
          ref.read(navigationIndexProvider.notifier).state = _loginPageIndex;
        },
      ),
    );
  }

  Future<void> _handleLogout(BuildContext context, WidgetRef ref) async {
    await ref.read(authControllerProvider.notifier).logout();
    
    if (context.mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text("Wylogowano pomyślnie"),
          duration: Duration(seconds: 2),
          behavior: SnackBarBehavior.floating,
        ),
      );
    }
    
    ref.read(navigationIndexProvider.notifier).state = 0;
  }
}


===============================
Ścieżka do pliku: ./lib/features/auth/data/auth_repository.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// ZMIANA: Importujemy provider dedykowany dla auth
import 'auth_dio_provider.dart'; 
import 'models/auth_token.dart';

final authRepositoryProvider = Provider((ref) {
  // ZMIANA: Watchujemy authDioProvider zamiast głównego dioProvider
  final dio = ref.watch(authDioProvider); 
  return AuthRepository(dio);
});

class AuthRepository {
  final Dio _dio;

  AuthRepository(this._dio);

  // Logowanie: x-www-form-urlencoded
  Future<AuthToken> login({required String username, required String password}) async {
    try {
      final response = await _dio.post(
        '/api/v1/auth/login',
        data: {
          'username': username,
          'password': password,
          'grant_type': 'password', // Wymagane przez OAuth2PasswordBearer
        },
        options: Options(
          contentType: Headers.formUrlEncodedContentType, // WAŻNE!
        ),
      );
      return AuthToken.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }

  // Rejestracja: application/json
  Future<void> register({
    required String email,
    required String username,
    required String password,
    required String captchaId,
    required String captchaAnswer,
  }) async {
    try {
      await _dio.post(
        '/api/v1/auth/register',
        data: {
          'email': email,
          'username': username,
          'password': password,
          'captcha_id': captchaId,
          'captcha_answer': captchaAnswer,
        },
      );
    } catch (e) {
      rethrow;
    }
  }

  // Wylogowanie
  Future<void> logout(String refreshToken) async {
      // API wymaga wysłania refresh tokena przy wylogowaniu
      await _dio.post('/api/v1/auth/logout', data: {'refresh_token': refreshToken});
  }
}


===============================
Ścieżka do pliku: ./lib/features/auth/data/token_storage.dart

Zawartość pliku:

import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'models/auth_token.dart';

final tokenStorageProvider = Provider((ref) => TokenStorage());

class TokenStorage {
  // POPRAWKA: Usuwamy parametr encryptedSharedPreferences.
  // Dodajemy resetOnError: true -> to "Best Practice" w developmentzie.
  // Jeśli klucze szyfrowania ulegną uszkodzeniu (np. przy reinstalacji apki w devie),
  // magazyn zostanie zresetowany zamiast crashować aplikację.
  final _storage = const FlutterSecureStorage(
    aOptions: AndroidOptions(
      resetOnError: true, 
    ),
  );

  static const _keyAccess = 'access_token';
  static const _keyRefresh = 'refresh_token';

  Future<void> saveToken(AuthToken token) async {
    await _storage.write(key: _keyAccess, value: token.accessToken);
    await _storage.write(key: _keyRefresh, value: token.refreshToken);
  }

  Future<AuthToken?> getToken() async {
    // Odczyt może rzucić wyjątek jeśli klucze systemowe się zmienią, 
    // dlatego warto otoczyć to try-catch w produkcyjnym kodzie, 
    // ale resetOnError w opcjach wyżej załatwia większość problemów.
    final access = await _storage.read(key: _keyAccess);
    final refresh = await _storage.read(key: _keyRefresh);
    
    if (access != null && refresh != null) {
      return AuthToken(accessToken: access, refreshToken: refresh);
    }
    return null;
  }

  Future<void> clearToken() async {
    await _storage.delete(key: _keyAccess);
    await _storage.delete(key: _keyRefresh);
  }
}


===============================
Ścieżka do pliku: ./lib/features/auth/data/auth_dio_provider.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/config/api_config.dart';
import '../../../core/network/auth_interceptor_provider.dart';

final authDioProvider = Provider<Dio>((ref) {
  // 1. Konfiguracja bazowa
  final dio = Dio(BaseOptions(
    baseUrl: ApiConfig.authBaseUrl, // Używamy adresu z konfigu
    connectTimeout: ApiConfig.connectTimeout,
    receiveTimeout: ApiConfig.receiveTimeout,
  ));

  // 2. Dodajemy wspólny interceptor autentykacji
  // (Potrzebny np. do endpointu /logout lub /users/me)
  final authInterceptor = ref.watch(authInterceptorProvider);
  dio.interceptors.add(authInterceptor);

  // 3. Opcjonalnie: Dodaj PrettyDioLogger w trybie debug (jeśli używasz)
  
  return dio;
});


===============================
Ścieżka do pliku: ./lib/features/auth/data/models/auth_token.dart

Zawartość pliku:

class AuthToken {
  final String accessToken;
  final String refreshToken;

  AuthToken({required this.accessToken, required this.refreshToken});

  factory AuthToken.fromJson(Map<String, dynamic> json) {
    return AuthToken(
      accessToken: json['access_token'] as String,
      refreshToken: json['refresh_token'] as String,
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/auth/data/models/user_model.dart

Zawartość pliku:

class User {
  final String id;
  final String username;
  final String email;
  final String role;

  User({required this.id, required this.username, required this.email, required this.role});

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'],
      username: json['username'],
      email: json['email'],
      role: json['account_role'],
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/captcha/captcha_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/widgets/main_drawer.dart';
import 'presentation/captcha_controller.dart';
import 'presentation/widgets/captcha_box.dart';

class CaptchaPage extends ConsumerStatefulWidget {
  const CaptchaPage({super.key});

  @override
  ConsumerState<CaptchaPage> createState() => _CaptchaPageState();
}

class _CaptchaPageState extends ConsumerState<CaptchaPage> {
  final _captchaInputController = TextEditingController();

  @override
  void dispose() {
    _captchaInputController.dispose();
    super.dispose();
  }

  Future<void> _verify() async {
    // Ukrywamy klawiaturę
    FocusScope.of(context).unfocus();
    
    final answer = _captchaInputController.text;
    if (answer.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Wpisz kod!")),
      );
      return;
    }

    final success = await ref
        .read(captchaControllerProvider.notifier)
        .verifyCaptcha(answer);

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text("Captcha zweryfikowana pomyślnie!"),
          backgroundColor: Colors.green,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    // Obserwujemy stan, aby wiedzieć np. czy trwa ładowanie
    final captchaState = ref.watch(captchaControllerProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text("Captcha Test"),
        elevation: 2,
      ),
      drawer: const MainDrawer(), // Dodajemy boczny pasek
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              "Demonstracja modułu Captcha",
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            const Text(
              "Poniższy komponent jest niezależny i gotowy do użycia na ekranach logowania/rejestracji.",
              style: TextStyle(color: Colors.grey),
            ),
            const SizedBox(height: 32),

            // --- REUŻYWALNY WIDGET CAPTCHA ---
            CaptchaBox(
              answerController: _captchaInputController,
              onRefresh: () {
                // Opcjonalny callback, np. logowanie zdarzenia
                debugPrint("Użytkownik odświeżył captchę");
              },
            ),
            // ---------------------------------

            const SizedBox(height: 24),

            // Przycisk "Verify" - specyficzny dla tej strony testowej
            SizedBox(
              width: double.infinity,
              child: FilledButton.icon(
                onPressed: captchaState.isLoading ? null : _verify,
                icon: const Icon(Icons.check_circle_outline),
                label: captchaState.isLoading
                    ? const SizedBox(
                        width: 20, 
                        height: 20, 
                        child: CircularProgressIndicator(color: Colors.white, strokeWidth: 2)
                      )
                    : const Text("ZWERYFIKUJ CAPTCHĘ"),
                style: FilledButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/captcha/presentation/captcha_controller.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/captcha_repository.dart';
import '../data/models/captcha_model.dart';
import '../../../../core/network/api_error_handler.dart';

// Stan dla naszego kontrolera
class CaptchaState {
  final CaptchaModel? captcha; // Obecny obrazek i ID
  final bool isLoading;
  final String? errorMessage;
  final bool? isVerified; // null = nie sprawdzano, true = ok, false = źle

  const CaptchaState({
    this.captcha,
    this.isLoading = false,
    this.errorMessage,
    this.isVerified,
  });

  CaptchaState copyWith({
    CaptchaModel? captcha,
    bool? isLoading,
    String? errorMessage,
    bool? isVerified,
  }) {
    return CaptchaState(
      captcha: captcha ?? this.captcha,
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage, // Jeśli null to czyścimy błąd
      isVerified: isVerified ?? this.isVerified,
    );
  }
}

class CaptchaController extends StateNotifier<CaptchaState> {
  final CaptchaRepository _repository;

  CaptchaController(this._repository) : super(const CaptchaState()) {
    // Automatycznie pobierz captchę przy starcie
    fetchCaptcha();
  }

  Future<void> fetchCaptcha() async {
    state = state.copyWith(isLoading: true, errorMessage: null, isVerified: null);
    try {
      final captcha = await _repository.generateCaptcha();
      state = state.copyWith(
        isLoading: false,
        captcha: captcha,
        errorMessage: null,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: ApiErrorHandler.getErrorMessage(e),
      );
    }
  }

  Future<bool> verifyCaptcha(String answer) async {
    if (state.captcha == null) return false;

    state = state.copyWith(isLoading: true, errorMessage: null);

    try {
      final isValid = await _repository.verifyCaptcha(
        CaptchaVerifyRequest(id: state.captcha!.id, answer: answer),
      );

      state = state.copyWith(
        isLoading: false,
        isVerified: isValid,
      );
      
      // Jeśli walidacja nie przeszła, można automatycznie odświeżyć captchę, 
      // bo zazwyczaj token jest jednorazowy.
      if (!isValid) {
         // Opcjonalnie: await fetchCaptcha(); 
         // Wiele systemów wymaga nowej captchy po błędnej próbie.
      }
      
      return isValid;
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: ApiErrorHandler.getErrorMessage(e),
        isVerified: false,
      );
      return false;
    }
  }
  
  // Metoda pomocnicza do resetowania stanu weryfikacji (np. gdy użytkownik zaczyna pisać)
  void resetVerificationStatus() {
    if (state.isVerified != null) {
      state = state.copyWith(isVerified: null);
    }
  }
}

// Używamy .autoDispose, aby stan się czyścił po wyjściu z ekranu
final captchaControllerProvider = 
    StateNotifierProvider.autoDispose<CaptchaController, CaptchaState>((ref) {
  final repo = ref.watch(captchaRepositoryProvider);
  return CaptchaController(repo);
});


===============================
Ścieżka do pliku: ./lib/features/captcha/presentation/widgets/captcha_box.dart

Zawartość pliku:

import 'dart:convert'; // Do base64Decode
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../captcha_controller.dart';

class CaptchaBox extends ConsumerStatefulWidget {
  final TextEditingController answerController;
  final VoidCallback? onRefresh;

  const CaptchaBox({
    super.key, 
    required this.answerController,
    this.onRefresh,
  });

  @override
  ConsumerState<CaptchaBox> createState() => _CaptchaBoxState();
}

class _CaptchaBoxState extends ConsumerState<CaptchaBox> {
  
  @override
  void initState() {
    super.initState();
    widget.answerController.addListener(() {
      ref.read(captchaControllerProvider.notifier).resetVerificationStatus();
    });
  }

  // --- NOWA METODA POMOCNICZA ---
  // Usuwa nagłówek "data:image/png;base64," jeśli istnieje
  String _cleanBase64(String base64String) {
    if (base64String.contains(',')) {
      return base64String.split(',').last;
    }
    return base64String;
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(captchaControllerProvider);
    final controller = ref.read(captchaControllerProvider.notifier);

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // 1. Obrazek Captcha
            Container(
              height: 80,
              decoration: BoxDecoration(
                color: Colors.grey.shade200,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.grey.shade300),
              ),
              child: state.isLoading && state.captcha == null
                  ? const Center(child: CircularProgressIndicator())
                  : state.captcha != null
                      ? ClipRRect(
                          borderRadius: BorderRadius.circular(8),
                          child: Image.memory(
                            // --- TUTAJ POPRAWKA ---
                            // Używamy metody pomocniczej _cleanBase64
                            base64Decode(_cleanBase64(state.captcha!.image)), 
                            fit: BoxFit.contain, // Zmienione na contain, żeby nie ucinało tekstu captchy
                            errorBuilder: (context, error, stackTrace) {
                              debugPrint('Błąd wyświetlania obrazka: $error');
                              return const Center(child: Icon(Icons.broken_image));
                            },
                          ),
                        )
                      : const Center(child: Text("Brak Captchy")),
            ),

            const SizedBox(height: 12),

            // 2. Wiersz: Pole tekstowe + Przycisk odświeżania
            Row(
              children: [
                Expanded(
                  child: TextFormField(
                    controller: widget.answerController,
                    decoration: InputDecoration(
                      labelText: 'Wpisz kod z obrazka',
                      border: const OutlineInputBorder(),
                      contentPadding: const EdgeInsets.symmetric(horizontal: 12),
                      enabledBorder: state.isVerified == false
                          ? const OutlineInputBorder(borderSide: BorderSide(color: Colors.red))
                          : null,
                      focusedBorder: state.isVerified == false
                          ? const OutlineInputBorder(borderSide: BorderSide(color: Colors.red, width: 2))
                          : null,
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                IconButton.filledTonal(
                  onPressed: state.isLoading 
                    ? null 
                    : () {
                        controller.fetchCaptcha();
                        widget.answerController.clear();
                        if(widget.onRefresh != null) widget.onRefresh!();
                      },
                  icon: state.isLoading
                      ? const SizedBox(
                          width: 20, 
                          height: 20, 
                          child: CircularProgressIndicator(strokeWidth: 2)
                        )
                      : const Icon(Icons.refresh),
                  tooltip: "Nowy kod",
                ),
              ],
            ),
            
            // 3. Informacja o błędzie
            if (state.errorMessage != null)
              Padding(
                padding: const EdgeInsets.only(top: 8.0),
                child: Text(
                  state.errorMessage!,
                  style: const TextStyle(color: Colors.red, fontSize: 12),
                ),
              ),
              
            if (state.isVerified == false)
              const Padding(
                padding: EdgeInsets.only(top: 8.0),
                child: Text(
                  "Niepoprawny kod. Spróbuj ponownie.",
                  style: TextStyle(color: Colors.red, fontSize: 12, fontWeight: FontWeight.bold),
                ),
              ),
              
             if (state.isVerified == true)
              const Padding(
                padding: EdgeInsets.only(top: 8.0),
                child: Text(
                  "Kod poprawny!",
                  style: TextStyle(color: Colors.green, fontSize: 12, fontWeight: FontWeight.bold),
                ),
              ),
          ],
        ),
      ),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/captcha/data/captcha_dio_provider.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Provider dedykowany dla mikroserwisu Captcha (port 8001)
final captchaDioProvider = Provider<Dio>((ref) {
  final dio = Dio(BaseOptions(
    // Dostosuj adres IP do swojego środowiska (podobnie jak w dio_provider.dart)
    // Jeśli używasz emulatora: http://10.0.2.2:8001
    // Jeśli fizyczne urządzenie/web: Twój adres LAN lub domena
    //baseUrl: 'http://127.0.0.1:8001', 
    baseUrl: 'https://dev-captcha.rafal-kruszyna.org',
    connectTimeout: const Duration(seconds: 5),
    receiveTimeout: const Duration(seconds: 5),
  ));
  return dio;
});


===============================
Ścieżka do pliku: ./lib/features/captcha/data/captcha_repository.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import './captcha_dio_provider.dart';
import 'models/captcha_model.dart';

// Provider repozytorium
final captchaRepositoryProvider = Provider<CaptchaRepository>((ref) {
  final dio = ref.watch(captchaDioProvider);
  return CaptchaRepository(dio);
});

class CaptchaRepository {
  final Dio _dio;

  CaptchaRepository(this._dio);

  Future<CaptchaModel> generateCaptcha() async {
    try {
      final response = await _dio.get('/api/v1/captcha');
      return CaptchaModel.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }

  Future<bool> verifyCaptcha(CaptchaVerifyRequest request) async {
    try {
      final response = await _dio.post(
        '/api/v1/captcha/verify',
        data: request.toJson(),
      );
      final result = CaptchaVerifyResponse.fromJson(response.data);
      return result.isValid;
    } catch (e) {
      // Jeśli serwer zwróci 422 (błąd walidacji), to technicznie nie jest poprawna captcha
      // Możesz tu obsłużyć to inaczej, ale na razie uznajmy to za false lub rzućmy błąd.
      rethrow; 
    }
  }
}


===============================
Ścieżka do pliku: ./lib/features/captcha/data/models/captcha_model.dart

Zawartość pliku:

class CaptchaModel {
  final String id; // UUID
  final String image; // Base64 string

  CaptchaModel({required this.id, required this.image});

  factory CaptchaModel.fromJson(Map<String, dynamic> json) {
    return CaptchaModel(
      id: json['id'] as String,
      image: json['image'] as String,
    );
  }
}

class CaptchaVerifyRequest {
  final String id;
  final String answer;

  CaptchaVerifyRequest({required this.id, required this.answer});

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'answer': answer,
    };
  }
}

class CaptchaVerifyResponse {
  final bool isValid;

  CaptchaVerifyResponse({required this.isValid});

  factory CaptchaVerifyResponse.fromJson(Map<String, dynamic> json) {
    return CaptchaVerifyResponse(
      isValid: json['is_valid'] as bool,
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/health/services_health_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:maia_flutter_client/core/config/api_config.dart';
import 'widgets/server_monitor_tile.dart';

class ServicesHealthPage extends StatelessWidget {
  const ServicesHealthPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      //backgroundColor: const Color(0xFFFFFFFF),

      body: SingleChildScrollView(
        // Odpowiednik ScrollablePage
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // --- DEV SERVERS ---
            _buildSectionHeader("Dev servers"),
            const ServerMonitorTile(
              serviceName: "captcha-microservice",
              serverUrl: ApiConfig.captchaBaseUrl,
            ),
            const ServerMonitorTile(
              serviceName: "auth-microservice",
              serverUrl: ApiConfig.authBaseUrl,
            ),
            const ServerMonitorTile(
              serviceName: "sentences-microservice",
              serverUrl: ApiConfig.sentencesBaseUrl,
            ),

            const SizedBox(height: 24),

            // --- PRODUCTION ---
            _buildSectionHeader("Production"),
            const ServerMonitorTile(
              serviceName: "captcha-microservice",
              serverUrl:
                  "https://maia-captcha.rafal-kruszyna.org", // port 443 jest domyślny dla https
            ),
            const ServerMonitorTile(
              serviceName: "auth-microservice",
              serverUrl: "https://maia-auth.rafal-kruszyna.org",
            ),
            const ServerMonitorTile(
              serviceName: "sentences-microservice",
              serverUrl: "https://maia-sentences.rafal-kruszyna.org",
            ),

            const SizedBox(height: 24),

            // --- PRODUCTION LOCAL ---
            _buildSectionHeader("Production local"),
            const ServerMonitorTile(
              serviceName: "captcha-microservice",
              serverUrl: "http://192.168.0.102:8001",
            ),
            const ServerMonitorTile(
              serviceName: "users-microservice",
              serverUrl: "http://192.168.0.102:8002",
            ),
            const ServerMonitorTile(
              serviceName: "sentences-microservice",
              serverUrl: "http://192.168.0.102:8003",
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
      child: Text(
        title,
        style: const TextStyle(
          fontSize: 18, // pointSize 15 w QML to mniej więcej 18-20 w Flutter
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/features/health/server_health_provider.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';
import './services/health_check_service.dart';

final healthCheckServiceProvider = Provider((ref) => HealthCheckService());

// StreamProvider automatycznie obsługuje stan Loading/Error/Data
// .family pozwala przekazać URL
final serverHealthProvider = StreamProvider.autoDispose.family<bool, String>((ref, url) async* {
  final service = ref.watch(healthCheckServiceProvider);

  // 1. Sprawdź natychmiast przy starcie
  yield await service.checkHost(url);

  // 2. Uruchom pętlę (Timer) - co 5 sekund (jak w C++ interval)
  // Stream.periodic działa jak QTimer
  final stream = Stream.periodic(const Duration(seconds: 5), (_) {
    return service.checkHost(url);
  });

  // 3. Emituj wyniki z pętli
  await for (final isAlive in stream) {
    yield await isAlive; // await tutaj, bo checkHost zwraca Future
  }
});


===============================
Ścieżka do pliku: ./lib/features/health/services/health_check_service.dart

Zawartość pliku:

import 'package:dio/dio.dart';

class HealthCheckService {
  final Dio _dio;

  HealthCheckService()
      : _dio = Dio(BaseOptions(
          connectTimeout: const Duration(seconds: 3),
          receiveTimeout: const Duration(seconds: 3),
          contentType: 'application/json',
          validateStatus: (status) => status == 200, // Tylko 200 nas interesuje
        ));

  /// Sprawdza konkretny endpoint wymagany przez C++ logic
  Future<bool> checkHost(String baseUrl) async {
    // Usuń slash na końcu jeśli jest
    final cleanUrl = baseUrl.endsWith('/')
        ? baseUrl.substring(0, baseUrl.length - 1)
        : baseUrl;
    
    // Konkretny endpoint z Twojego kodu C++
    final targetUrl = '$cleanUrl/health/live';

    try {
      // Cache breaker, żeby nie pobierać starego wyniku
      final response = await _dio.get(
        targetUrl, 
        queryParameters: {'t': DateTime.now().millisecondsSinceEpoch},
      );

      if (response.statusCode == 200 && response.data is Map) {
        // Sprawdzenie logiki biznesowej: {"status": "ok"}
        return response.data['status'] == 'ok';
      }
      return false;
    } catch (e) {
      return false;
    }
  }
}


===============================
Ścieżka do pliku: ./lib/features/health/widgets/server_monitor_tile.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../server_health_provider.dart';

class ServerMonitorTile extends ConsumerWidget {
  final String serverUrl;
  final String serviceName;

  const ServerMonitorTile({
    super.key,
    required this.serverUrl,
    required this.serviceName,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Obserwujemy StreamProvidera
    final AsyncValue<bool> healthState = ref.watch(serverHealthProvider(serverUrl));

    return Card(
      margin: const EdgeInsets.symmetric(vertical: 4),
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Row(
          children: [
            // Ikona statusu z obsługą ładowania
            _buildStatusIndicator(healthState),
            
            const SizedBox(width: 16),
            
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    serviceName,
                    style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
                  ),
                  Text(
                    serverUrl,
                    style: TextStyle(color: Colors.grey[600], fontSize: 12),
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatusIndicator(AsyncValue<bool> state) {
    return state.when(
      // Gdy mamy dane (true/false)
      data: (isAlive) {
        return Container(
          width: 24,
          height: 24,
          decoration: BoxDecoration(
            color: isAlive ? Colors.green : Colors.red,
            shape: BoxShape.circle,
          ),
          child: Icon(
            isAlive ? Icons.check : Icons.close,
            color: Colors.white,
            size: 16,
          ),
        );
      },
      // Gdy się ładuje (pierwsze zapytanie)
      loading: () => const SizedBox(
        width: 24,
        height: 24,
        child: CircularProgressIndicator(strokeWidth: 2),
      ),
      // Gdy wystąpi błąd w samym Streamie (rzadkie przy try-catch w serwisie)
      error: (_, _) => const Icon(Icons.error_outline, color: Colors.grey),
    );
  }
}


===============================
Ścieżka do pliku: ./lib/features/words/words_page.dart

Zawartość pliku:

import 'package:flutter/material.dart';

class WordsPage extends StatelessWidget {
  const WordsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return  Scaffold(
      body: Center(child: Text('Nauka slowek - niebawem')),
    );
  }
}



===============================
Ścieżka do pliku: ./lib/core/app_sizes.dart

Zawartość pliku:

class AppSizes{
  static const double maxMobileWidth = 550.0;
}


===============================
Ścieżka do pliku: ./lib/core/navigation_provider.dart

Zawartość pliku:

import 'package:flutter_riverpod/flutter_riverpod.dart';

final navigationIndexProvider = StateProvider<int>((ref) => 0);


===============================
Ścieżka do pliku: ./lib/core/config/api_config.dart

Zawartość pliku:

class ApiConfig {
  // Unikamy instancjonowania tej klasy
  ApiConfig._();

  // Adresy bazowe dla środowiska DEV
  // W przyszłości można tu dodać logikę do przełączania na PROD
  static const String authBaseUrl = 'https://dev-auth.rafal-kruszyna.org';
  static const String sentencesBaseUrl = 'https://dev-sentences.rafal-kruszyna.org';
  static const String captchaBaseUrl = 'https://dev-captcha.rafal-kruszyna.org';
  
  // Timeouty
  static const Duration connectTimeout = Duration(seconds: 10);
  static const Duration receiveTimeout = Duration(seconds: 10);
}


===============================
Ścieżka do pliku: ./lib/core/widgets/main_drawer.dart

Zawartość pliku:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import "../../features/auth/presentation/auth_controller.dart";
import '../navigation_provider.dart';

class MainDrawer extends ConsumerWidget {
  const MainDrawer({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedIndex = ref.watch(navigationIndexProvider);
    // Obserwujemy stan autentykacji
    final authState = ref.watch(authControllerProvider);
    final isLoggedIn = authState.isAuthenticated;

    return Drawer(
      child: ListView(
        padding: EdgeInsets.zero,
        children: [
          DrawerHeader(
            decoration: BoxDecoration(color: Colors.deepPurple),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                Text(
                  'English Learner',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  isLoggedIn ? 'Witaj, użytkowniku!' : 'Tryb Gościa',
                  style: const TextStyle(color: Colors.white70, fontSize: 14),
                ),
                Text(
                  'Twój postęp: 45%',
                  style: TextStyle(color: Colors.white70, fontSize: 14),
                ),
              ],
            ),
          ),
          _DrawerTile(
            title: 'Ogłoszenia parafialne',
            icon: Icons.home,
            index: 0,
            isSelected: selectedIndex == 0,
          ),
          _DrawerTile(
            title: 'Slownik',
            icon: Icons.menu_book,
            index: 1,
            isSelected: selectedIndex == 1,
          ),
          _DrawerTile(
            title: 'Slowka',
            icon: Icons.school,
            index: 2,
            isSelected: selectedIndex == 2,
          ),
          _DrawerTile(
            title: 'Zwroty',
            icon: Icons.chat,
            index: 3,
            isSelected: selectedIndex == 3,
          ),
          _DrawerTile(
            title: 'Rejestracja',
            icon: Icons.chat,
            index: 4,
            isSelected: selectedIndex == 4,
          ),
          _DrawerTile(
            title: 'Logowanie',
            icon: Icons.login,
            index: 5,
            isSelected: selectedIndex == 5,
          ),
          const Divider(),
          const Padding(
            padding: EdgeInsets.only(left: 16, top: 8, bottom: 8),
            child: Text(
              "DEV TOOLS",
              style: TextStyle(color: Colors.grey, fontSize: 12),
            ),
          ),
          _DrawerTile(
            title: 'Test',
            icon: Icons.quiz,
            index: 6,
            isSelected: selectedIndex == 6,
          ),
          _DrawerTile(
            title: 'Health Check',
            icon: Icons.dns,
            index: 7,
            isSelected: selectedIndex == 7,
          ),
          _DrawerTile(
            title: 'Captcha Test',
            icon: Icons.security,
            index: 8,
            isSelected: selectedIndex == 8,
          ),
        ],
      ),
    );
  }
}

// _DrawerTile pozostaje bez zmian jak w Twoim pliku
class _DrawerTile extends ConsumerWidget {
  final String title;
  final IconData icon;
  final int index;
  final bool isSelected;

  const _DrawerTile({
    required this.title,
    required this.icon,
    required this.index,
    required this.isSelected,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ListTile(
      leading: Icon(icon, color: isSelected ? Colors.deepPurple : null),
      title: Text(
        title,
        style: TextStyle(
          color: isSelected ? Colors.deepPurple : null,
          fontWeight: isSelected ? FontWeight.bold : null,
        ),
      ),
      selected: isSelected,
      selectedTileColor: Colors.deepPurple.withValues(alpha: 0.1),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      onTap: () {
        ref.read(navigationIndexProvider.notifier).state = index;
        Navigator.pop(context);
      },
    );
  }
}



===============================
Ścieżka do pliku: ./lib/core/network/auth_interceptor_provider.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../features/auth/data/token_storage.dart';

// Provider zwracający skonfigurowany Interceptor
final authInterceptorProvider = Provider<Interceptor>((ref) {
  final storage = ref.watch(tokenStorageProvider);
  return AuthInterceptor(storage);
});

class AuthInterceptor extends Interceptor {
  final TokenStorage _storage;

  AuthInterceptor(this._storage);

  @override
  Future<void> onRequest(RequestOptions options, RequestInterceptorHandler handler) async {
    // Pobierz token
    final token = await _storage.getToken();

    // Dodaj nagłówek jeśli token istnieje
    if (token != null) {
      options.headers['Authorization'] = 'Bearer ${token.accessToken}';
    }

    return handler.next(options);
  }

  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    // Tu w przyszłości dodasz logikę odświeżania tokena (Refresh Token)
    // jeśli err.response?.statusCode == 401
    return handler.next(err);
  }
}


===============================
Ścieżka do pliku: ./lib/core/network/dio_provider.dart

Zawartość pliku:

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/api_config.dart'; // Import configu
import 'auth_interceptor_provider.dart'; // Import interceptora

final dioProvider = Provider<Dio>((ref) {
  final dio = Dio(BaseOptions(
    baseUrl: ApiConfig.sentencesBaseUrl, // Adres mikroserwisu zdań
    connectTimeout: ApiConfig.connectTimeout,
    receiveTimeout: ApiConfig.receiveTimeout,
  ));

  // Używamy tego samego interceptora co w authDioProvider (DRY!)
  final authInterceptor = ref.watch(authInterceptorProvider);
  dio.interceptors.add(authInterceptor);

  return dio;
});


===============================
Ścieżka do pliku: ./lib/core/network/api_error_handler.dart

Zawartość pliku:

import 'package:dio/dio.dart';

class ApiErrorHandler {
  static String getErrorMessage(Object error) {
    if (error is DioException) {
      switch (error.type) {
        case DioExceptionType.connectionTimeout:
        case DioExceptionType.sendTimeout:
        case DioExceptionType.receiveTimeout:
          return "Upłynął limit czasu połączenia. Sprawdź internet.";

        case DioExceptionType.badResponse:
          return _handleBadResponse(error.response);

        case DioExceptionType.connectionError:
          return "Brak połączenia z serwerem. Sprawdź internet.";

        case DioExceptionType.cancel:
          return "Żądanie zostało anulowane.";

        default:
          return "Wystąpił nieznany błąd sieciowy.";
      }
    } else {
      return "Wystąpił niespodziewany błąd: ${error.toString()}";
    }
  }

  static String _handleBadResponse(Response? response) {
    if (response == null) return "Nieznany błąd serwera.";

    final dynamic data = response.data;
    final int? statusCode = response.statusCode;

    // KROK 1: Sprawdź, czy serwer przysłał konkretny komunikat błędu.
    if (data is Map) {
      // Obsługa błędu 422 (FastAPI Validation Error)
      if (statusCode == 422 && data['detail'] is List) {
        final list = data['detail'] as List;
        if (list.isNotEmpty && list.first is Map) {
          final firstMsg = list.first['msg'];

          // --- POPRAWKA TUTAJ ---
          // Musimy przetłumaczyć wiadomość wyciągniętą z listy!
          final translatedMsg = _translateMessage(firstMsg.toString());

          return "Błąd walidacji: $translatedMsg";
        }
      }

      // Standardowa obsługa (400, 401, 409...) - detail to String
      if (data['detail'] != null && data['detail'] is String) {
        return _translateMessage(data['detail']);
      }
    }

    // KROK 2: Fallback (Estymacja po kodzie)
    switch (statusCode) {
      case 400:
        return "Nieprawidłowe żądanie (400).";
      case 401:
        return "Błąd autentykacji. Zaloguj się ponownie.";
      case 403:
        return "Brak dostępu do zasobu.";
      case 404:
        return "Nie znaleziono zasobu (404).";
      case 409:
        return "Konflikt danych (409).";
      case 429:
        return "Zbyt wiele zapytań. Zwolnij chwilę.";
      case 500:
      case 502:
        return "Błąd serwera ($statusCode). Spróbuj później.";
      case 503:
        return "Serwer jest niedostępny (Trwają prace techniczne lub przeciążenie).";
      default:
        return "Wystąpił błąd ($statusCode).";
    }
  }

  static String _translateMessage(String msg) {
    // Prosty słownik tłumaczeń najczęstszych błędów z backendu

    // --- NOWE TŁUMACZENIA DLA USERNAME (Auth Service) ---
    if (msg.contains("Username must be at least 3 characters long")) {
      return "Nazwa użytkownika musi mieć co najmniej 3 znaki.";
    }
    if (msg.contains("Username cannot be longer than 30 characters")) {
      return "Nazwa użytkownika nie może mieć więcej niż 30 znaków.";
    }
    if (msg.contains("Username can only contain letters, numbers")) {
      return "Nazwa użytkownika może zawierać tylko litery, cyfry, podkreślenia (_) i myślniki (-).";
    }
    if (msg.contains("This username is reserved")) {
      return "Ta nazwa użytkownika jest zastrzeżona i nie może zostać użyta.";
    }
    if (msg.contains("Username cannot contain '@' symbol")) {
      return "Nazwa użytkownika nie może zawierać znaku '@'.";
    }
    if (msg.contains("consecutive underscores or hyphens")) {
      return "Nazwa użytkownika nie może zawierać podwójnych podkreśleń lub myślników.";
    }
    // ----------------------------------------------------

    if (msg.contains("User with this email already exists")) {
      return "Użytkownik o tym adresie email już istnieje.";
    }
    if (msg.contains("User with this username already exists")) {
      return "Ta nazwa użytkownika jest już zajęta.";
    }
    if (msg.contains("Username already taken")) {
      return "Ta nazwa użytkownika jest już zajęta.";
    }
    if (msg.contains("Incorrect username or password")) {
      return "Niepoprawna nazwa użytkownika lub hasło.";
    }
    if (msg.contains("Inactive user")) {
      return "Konto jest nieaktywne.";
    }
    if (msg.contains("Invalid captcha")) {
      return "Niepoprawny kod Captcha.";
    }
    if (msg.contains("Invalid CAPTCHA answer")) {
      return "Niepoprawny kod Captcha.";
    }
    if (msg.contains("Email already registered")) {
      return "Ten adres email jest już zarejestrowany.";
    }
    if (msg.contains("value is not a valid email address")) {
      return "Niepoprawny format adresu email.";
    }
    if (msg.contains("Password must be at least 6 characters long")) {
      return "Hasło musi mieć co najmniej 6 znaków.";
    }
    if (msg.contains("Password must contain at least one digit")) {
      return "Hasło musi zawierać co najmniej jedną cyfrę.";
    }
    if (msg.contains("Password must contain at least one letter")) {
      return "Hasło musi zawierać co najmniej jedną literę.";
    }
    if (msg.contains("String should have at least 6 characters")) {
      return "Wartość jest za krótka (wymagane min. 6 znaków).";
    }
    //auth service error
    if(msg.contains("Database error: Resource is locked. Service temporarily unavailable.")){
      return "Serwis jest chwilowo zajęty (baza danych zablokowana). Spróbuj ponownie za chwilę.";
    }
    //auth service error
    if(msg.contains("Database error: Internal operation failed.")){
      return "Wystąpił wewnętrzny błąd bazy danych. Spróbuj ponownie.";
    }

    // Jeśli nie mamy tłumaczenia, zwracamy oryginał (np. "Password is too short")
    return msg;
  }
}


